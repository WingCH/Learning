[
  {
    "markdown": "[Skip to main content](#__docusaurus_skipToContent_fallback)\n\nOn this page\n\nWith everything we've seen so far, we can already build a fully functional\napplication. However, you may have questions regarding performance.\n\nIn this page, we will cover a few tips and tricks to possibly optimize your code.\n\ncaution\n\nBefore doing any optimization, make sure to benchmark your application.\nThe added complexity of the optimizations may not be worth minor gains.\n\n## Filtering widget/provider rebuild using \"select\". [​](\\#filtering-widgetprovider-rebuild-using-select \"Direct link to Filtering widget/provider rebuild using \\\"select\\\".\")\n\nYou have have noticed that, by default, using `ref.watch` causes\nconsumers/providers to rebuild whenever _any_ of the properties of an\nobject changes.\n\nFor instance, watching a `User` and only using its \"name\" will still cause\nthe consumer to rebuild if the \"age\" changes.\n\nBut in case you have a consumer using only a subset of the properties,\nyou want to avoid rebuilding the widget when the other properties change.\n\nThis can be achieved by using the `select` functionality of providers.\n\nWhen doing so, `ref.watch` will no-longer return the full object,\nbut rather the selected properties.\n\nAnd your consumers/providers will now rebuild only if those selected\nproperties change.\n\n```codeBlockLines_e6Vv\nclass User {\n  late String firstName, lastName;\n}\n\n@riverpod\nUser example(Ref ref) => User()\n  ..firstName = 'John'\n  ..lastName = 'Doe';\n\nclass ConsumerExample extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // Instead of writing:\n    // String name = ref.watch(provider).firstName!;\n    // We can write:\n    String name = ref.watch(exampleProvider.select((it) => it.firstName));\n    // This will cause the widget to only listen to changes on \"firstName\".\n\n    return Text('Hello $name');\n  }\n}\n\n```\n\ninfo\n\nIt is possible to call `select` as many times as you wish.\nYou are free to call it once per property you desire.\n\ncaution\n\nThe selected properties are expected to be immutable.\nReturning a `List` and then mutating that list will not trigger a rebuild.\n\ncaution\n\nUsing `select` slightly slows down individual read operations and\nincrease a tiny bit the complexity of your code.\n\nIt may not be worth using it if those \"other properties\"\nrarely change.\n\n### Selecting asynchronous properties [​](\\#selecting-asynchronous-properties \"Direct link to Selecting asynchronous properties\")\n\nIn case you are trying to optimize a provider listening to another provider,\nchances are that other provider is asynchronous.\n\nNormally, you would `ref.watch(anotherProvider.future)` to get the value.\n\nThe issue is, `select` will apply on an `AsyncValue` – which is not something\nyou can await.\n\nFor this purpose, you can instead use `selectAsync`. It is unique to asynchronous\ncode, and enables performing a `select` operation on the data emitted by a provider.\n\nIts usage is similar to that of `select`, but returns a `Future` instead:\n\n```codeBlockLines_e6Vv\n@riverpod\nObject? example(Ref ref) async {\n  // Wait for a user to be available, and listen to only the \"firstName\" property\n  final firstName = await ref.watch(\n    userProvider.selectAsync((it) => it.firstName),\n  );\n\n  // TODO use \"firstName\" to fetch something else\n}\n\n```\n\n- [Filtering widget/provider rebuild using \"select\".](#filtering-widgetprovider-rebuild-using-select)\n  - [Selecting asynchronous properties](#selecting-asynchronous-properties)",
    "metadata": {
      "url": "https://riverpod.dev/docs/advanced/select",
      "ogUrl": "https://riverpod.dev/docs/advanced/select",
      "title": "Optimizing performance | Riverpod",
      "og:url": "https://riverpod.dev/docs/advanced/select",
      "ogImage": "https://riverpod.dev/img/cover.png",
      "ogTitle": "Optimizing performance | Riverpod",
      "language": "en",
      "og:image": "https://riverpod.dev/img/cover.png",
      "og:title": "Optimizing performance | Riverpod",
      "viewport": "width=device-width, initial-scale=1.0",
      "generator": "Docusaurus v2.4.3",
      "sourceURL": "https://riverpod.dev/docs/advanced/select",
      "statusCode": 200,
      "description": "With everything we've seen so far, we can already build a fully functional",
      "twitter:card": "summary_large_image",
      "ogDescription": "With everything we've seen so far, we can already build a fully functional",
      "twitter:image": "https://riverpod.dev/img/cover.png",
      "docusaurus_tag": "docs-default-current",
      "og:description": "With everything we've seen so far, we can already build a fully functional",
      "docsearch:version": "current",
      "docusaurus_locale": "en",
      "ogLocaleAlternate": [],
      "docsearch:language": "en",
      "docusaurus_version": "current",
      "docsearch:docusaurus_tag": "docs-default-current"
    }
  },
  {
    "markdown": "[Skip to main content](#__docusaurus_skipToContent_fallback)\n\ncaution\n\nThe content of this page may be outdated.\n\nIt will be updated in the future, but for now you may want to refer to the content\nin the top of the sidebar instead (introduction/essentials/case-studies/...)\n\n`StateNotifierProvider` is a provider that is used to listen to and expose a\n[StateNotifier](https://pub.dev/documentation/state_notifier/latest/state_notifier/StateNotifier-class.html) (from the package [state\\_notifier](https://pub.dev/packages/state_notifier), which Riverpod re-exports).\n\nIt is typically used for:\n\n- exposing an **immutable** state which can change over time after reacting to\ncustom events.\n- centralizing the logic for modifying some state (aka \"business logic\") in a\nsingle place, improving maintainability over time.\n\ninfo\n\nPrefer using [NotifierProvider](/docs/providers/notifier_provider) instead.\n\nAs a usage example, we could use `StateNotifierProvider` to implement a todo-list.\nDoing so would allow us to expose methods such as `addTodo` to let the UI\nmodify the list of todos on user interactions:\n\n```codeBlockLines_e6Vv\n\n// The state of our StateNotifier should be immutable.\n// We could also use packages like Freezed to help with the implementation.\n@immutable\nclass Todo {\n  const Todo({required this.id, required this.description, required this.completed});\n\n  // All properties should be `final` on our class.\n  final String id;\n  final String description;\n  final bool completed;\n\n  // Since Todo is immutable, we implement a method that allows cloning the\n  // Todo with slightly different content.\n  Todo copyWith({String? id, String? description, bool? completed}) {\n    return Todo(\n      id: id ?? this.id,\n      description: description ?? this.description,\n      completed: completed ?? this.completed,\n    );\n  }\n}\n\n// The StateNotifier class that will be passed to our StateNotifierProvider.\n// This class should not expose state outside of its \"state\" property, which means\n// no public getters/properties!\n// The public methods on this class will be what allow the UI to modify the state.\nclass TodosNotifier extends StateNotifier<List<Todo>> {\n  // We initialize the list of todos to an empty list\n  TodosNotifier(): super([]);\n\n  // Let's allow the UI to add todos.\n  void addTodo(Todo todo) {\n    // Since our state is immutable, we are not allowed to do `state.add(todo)`.\n    // Instead, we should create a new list of todos which contains the previous\n    // items and the new one.\n    // Using Dart's spread operator here is helpful!\n    state = [...state, todo];\n    // No need to call \"notifyListeners\" or anything similar. Calling \"state =\"\n    // will automatically rebuild the UI when necessary.\n  }\n\n  // Let's allow removing todos\n  void removeTodo(String todoId) {\n    // Again, our state is immutable. So we're making a new list instead of\n    // changing the existing list.\n    state = [\\\n      for (final todo in state)\\\n        if (todo.id != todoId) todo,\\\n    ];\n  }\n\n  // Let's mark a todo as completed\n  void toggle(String todoId) {\n    state = [\\\n      for (final todo in state)\\\n        // we're marking only the matching todo as completed\\\n        if (todo.id == todoId)\\\n          // Once more, since our state is immutable, we need to make a copy\\\n          // of the todo. We're using our `copyWith` method implemented before\\\n          // to help with that.\\\n          todo.copyWith(completed: !todo.completed)\\\n        else\\\n          // other todos are not modified\\\n          todo,\\\n    ];\n  }\n}\n\n// Finally, we are using StateNotifierProvider to allow the UI to interact with\n// our TodosNotifier class.\nfinal todosProvider = StateNotifierProvider<TodosNotifier, List<Todo>>((ref) {\n  return TodosNotifier();\n});\n\n```\n\nNow that we have defined a `StateNotifierProvider`, we can use it to interact\nwith the list of todos in our UI:\n\n```codeBlockLines_e6Vv\n\nclass TodoListView extends ConsumerWidget {\n  const TodoListView({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // rebuild the widget when the todo list changes\n    List<Todo> todos = ref.watch(todosProvider);\n\n    // Let's render the todos in a scrollable list view\n    return ListView(\n      children: [\\\n        for (final todo in todos)\\\n          CheckboxListTile(\\\n            value: todo.completed,\\\n            // When tapping on the todo, change its completed status\\\n            onChanged: (value) => ref.read(todosProvider.notifier).toggle(todo.id),\\\n            title: Text(todo.description),\\\n          ),\\\n      ],\n    );\n  }\n}\n\n```",
    "metadata": {
      "url": "https://riverpod.dev/docs/providers/state_notifier_provider",
      "ogUrl": "https://riverpod.dev/docs/providers/state_notifier_provider",
      "title": "StateNotifierProvider | Riverpod",
      "og:url": "https://riverpod.dev/docs/providers/state_notifier_provider",
      "ogImage": "https://riverpod.dev/img/cover.png",
      "ogTitle": "StateNotifierProvider | Riverpod",
      "language": "en",
      "og:image": "https://riverpod.dev/img/cover.png",
      "og:title": "StateNotifierProvider | Riverpod",
      "viewport": "width=device-width, initial-scale=1.0",
      "generator": "Docusaurus v2.4.3",
      "sourceURL": "https://riverpod.dev/docs/providers/state_notifier_provider",
      "statusCode": 200,
      "description": "The content of this page may be outdated.",
      "twitter:card": "summary_large_image",
      "ogDescription": "The content of this page may be outdated.",
      "twitter:image": "https://riverpod.dev/img/cover.png",
      "docusaurus_tag": "docs-default-current",
      "og:description": "The content of this page may be outdated.",
      "docsearch:version": "current",
      "docusaurus_locale": "en",
      "ogLocaleAlternate": [],
      "docsearch:language": "en",
      "docusaurus_version": "current",
      "docsearch:docusaurus_tag": "docs-default-current"
    }
  },
  {
    "markdown": "[Skip to main content](#__docusaurus_skipToContent_fallback)\n\nOn this page\n\nRiverpod natively offers a way to listen to all events happening\nin the provider tree.\n\nThis can be used to log all the events or to report errors to a\nremote service.\n\nThis is achieved by using the `ProviderObserver` class,\nand passing it to `ProviderScope`/ `ProviderContainer`.\n\n## Defining a ProviderObserver [​](\\#defining-a-providerobserver \"Direct link to Defining a ProviderObserver\")\n\nA `ProviderObserver` is a class that should be extended.\n\nIt offers various methods which can be overridden to listen to events:\n\n- `didAddProvider`, called when a provider is added to the tree\n- `didUpdateProvider`, called when a provider is updated\n- `didDisposeProvider`, called when a provider is disposed\n- `providerDidFail`, when a synchronous provider throws an error\n\n```codeBlockLines_e6Vv\nclass MyObserver extends ProviderObserver {\n  @override\n  void didAddProvider(\n    ProviderBase<Object?> provider,\n    Object? value,\n    ProviderContainer container,\n  ) {\n    print('Provider $provider was initialized with $value');\n  }\n\n  @override\n  void didDisposeProvider(\n    ProviderBase<Object?> provider,\n    ProviderContainer container,\n  ) {\n    print('Provider $provider was disposed');\n  }\n\n  @override\n  void didUpdateProvider(\n    ProviderBase<Object?> provider,\n    Object? previousValue,\n    Object? newValue,\n    ProviderContainer container,\n  ) {\n    print('Provider $provider updated from $previousValue to $newValue');\n  }\n\n  @override\n  void providerDidFail(\n    ProviderBase<Object?> provider,\n    Object error,\n    StackTrace stackTrace,\n    ProviderContainer container,\n  ) {\n    print('Provider $provider threw $error at $stackTrace');\n  }\n}\n\n```\n\n## Using a ProviderObserver [​](\\#using-a-providerobserver \"Direct link to Using a ProviderObserver\")\n\nNow that we've defined an observer, we need to use it.\n\nTo do so, we should pass it to either `ProviderScope` or `ProviderContainer`:\n\n```codeBlockLines_e6Vv\nrunApp(\n  ProviderScope(\n    observers: [\\\n      MyObserver(),\\\n    ],\n    child: MyApp(),\n  )\n);\n\n```\n\n```codeBlockLines_e6Vv\nfinal container = ProviderContainer(\n  observers: [\\\n    MyObserver(),\\\n  ],\n);\n\n```\n\n- [Defining a ProviderObserver](#defining-a-providerobserver)\n- [Using a ProviderObserver](#using-a-providerobserver)",
    "metadata": {
      "url": "https://riverpod.dev/docs/essentials/provider_observer",
      "ogUrl": "https://riverpod.dev/docs/essentials/provider_observer",
      "title": "Logging and error reporting | Riverpod",
      "og:url": "https://riverpod.dev/docs/essentials/provider_observer",
      "ogImage": "https://riverpod.dev/img/cover.png",
      "ogTitle": "Logging and error reporting | Riverpod",
      "language": "en",
      "og:image": "https://riverpod.dev/img/cover.png",
      "og:title": "Logging and error reporting | Riverpod",
      "viewport": "width=device-width, initial-scale=1.0",
      "generator": "Docusaurus v2.4.3",
      "sourceURL": "https://riverpod.dev/docs/essentials/provider_observer",
      "statusCode": 200,
      "description": "Riverpod natively offers a way to listen to all events happening",
      "twitter:card": "summary_large_image",
      "ogDescription": "Riverpod natively offers a way to listen to all events happening",
      "twitter:image": "https://riverpod.dev/img/cover.png",
      "docusaurus_tag": "docs-default-current",
      "og:description": "Riverpod natively offers a way to listen to all events happening",
      "docsearch:version": "current",
      "docusaurus_locale": "en",
      "ogLocaleAlternate": [],
      "docsearch:language": "en",
      "docusaurus_version": "current",
      "docsearch:docusaurus_tag": "docs-default-current"
    }
  },
  {
    "markdown": "[Skip to main content](#__docusaurus_skipToContent_fallback)\n\nOn this page\n\ncaution\n\nThe content of this page may be outdated.\n\nIt will be updated in the future, but for now you may want to refer to the content\nin the top of the sidebar instead (introduction/essentials/case-studies/...)\n\nNow that we have installed [Riverpod](https://github.com/rrousselgit/riverpod), let's talk about \"providers\".\n\nProviders are the most important part of a [Riverpod](https://github.com/rrousselgit/riverpod) application.\nA provider is an object that encapsulates a piece of state and allows listening\nto that state.\n\n## Why use providers? [​](\\#why-use-providers \"Direct link to Why use providers?\")\n\nWrapping a piece of state in a provider:\n\n- Allows easily accessing that state in multiple locations.\nProviders are a complete replacement for patterns like Singletons,\nService Locators, Dependency Injection or InheritedWidgets.\n\n- Simplifies combining this state with others.\nEver struggled to merge multiple objects into one? This scenario is built\ndirectly inside providers.\n\n- Enables performance optimizations.\nWhether for filtering widget rebuilds or for caching expensive state computations;\nproviders ensure that only what is impacted by a state change is recomputed.\n\n- Increases the testability of your application.\nWith providers, you do not need complex `setUp`/ `tearDown` steps. Furthermore,\nany provider can be overridden to behave differently during a test, which\nallows easily testing a very specific behavior.\n\n- Allows easy integration with advanced features, such as logging or\npull-to-refresh.\n\n\n## Creating a provider [​](\\#creating-a-provider \"Direct link to Creating a provider\")\n\nProviders come in many variants, but they all work the same way.\n\nThe most common usage is to declare them as global constants like so:\n\n```codeBlockLines_e6Vv\n\n@riverpod\nMyValue my(Ref ref) {\n  return MyValue();\n}\n\n```\n\nnote\n\nDo not be frightened by the global aspect of providers.\nProviders are fully immutable. Declaring a provider is no different from declaring\na function, and providers are testable and maintainable.\n\nThis snippet consists of three components:\n\n- `final myProvider`, the declaration of a variable.\nThis variable is what we will use in the future to read the state of our provider.\nProviders should always be `final`.\n\n- `Provider`, the provider that we decided to use.\n[Provider](/docs/providers/provider) is the most basic of all providers. It exposes an object that never\nchanges.\nWe could replace [Provider](/docs/providers/provider) with other providers like [StreamProvider](/docs/providers/stream_provider) or\n[NotifierProvider](/docs/providers/notifier_provider), to change how the value is interacted with.\n\n- A function that creates the shared state.\nThat function will always receive an object called `ref` as a parameter. This object\nallows us to read other providers, perform some operations when the state\nof our provider will be destroyed, and much more.\n\n\nThe type of the object returned by the function passed to a provider depends on\nthe provider used.\nFor example, the function of a [Provider](/docs/providers/provider) can create any object.\nOn the other hand, [StreamProvider](/docs/providers/stream_provider)'s callback will be expected to return a [Stream](https://api.dart.dev/stable/2.8.4/dart-async/Stream-class.html).\n\ninfo\n\nYou can declare as many providers as you want without limitations.\nAs opposed to when using `package:provider`, [Riverpod](https://github.com/rrousselgit/riverpod) allows creating multiple\nproviders exposing a state of the same \"type\":\n\n```codeBlockLines_e6Vv\n\n@riverpod\nString city(Ref ref) => 'London';\n@riverpod\nString country(Ref ref) => 'England';\n\n```\n\nThe fact that both providers create a `String` does not cause any problem.\n\ncaution\n\nFor providers to work, you must add [ProviderScope](https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/ProviderScope-class.html) at the root of your\nFlutter applications:\n\n```codeBlockLines_e6Vv\nvoid main() {\n  runApp(ProviderScope(child: MyApp()));\n}\n\n```\n\n## Different Types of Providers [​](\\#different-types-of-providers \"Direct link to Different Types of Providers\")\n\nThere are multiple types of providers for multiple different use cases.\n\nWith all of these providers available, it is sometimes difficult to understand when to use one provider type over another.\nUse the table below to choose a provider that fits what you want to provide to the widget tree.\n\n| Provider Type | Provider Create Function | Example Use Case |\n| --- | --- | --- |\n| [Provider](/docs/providers/provider) | Returns any type | A service class / computed property (filtered list) |\n| [StateProvider](/docs/providers/state_provider) | Returns any type | A filter condition / simple state object |\n| [FutureProvider](/docs/providers/future_provider) | Returns a Future of any type | A result from an API call |\n| [StreamProvider](/docs/providers/stream_provider) | Returns a Stream of any type | A stream of results from an API |\n| [NotifierProvider](/docs/providers/notifier_provider) | Returns a subclass of (Async)Notifier | A complex state object that is immutable except through an interface |\n| [StateNotifierProvider](/docs/providers/state_notifier_provider) | Returns a subclass of StateNotifier | A complex state object that is immutable except through an interface. Prefer using a notifierProvider |\n| [ChangeNotifierProvider](https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/ChangeNotifierProvider-class.html) | Returns a subclass of ChangeNotifier | A complex state object that requires mutability |\n\ncaution\n\nWhile all providers have their purpose, [ChangeNotifierProvider](https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/ChangeNotifierProvider-class.html) s are not recommended for scalable applications. See [Why Immutability](/docs/concepts/why_immutability). It exists in the\n`flutter_riverpod` package to provide an easy migration path from\n`package:provider`, and allows for some flutter specific use-cases such as\nintegration with some Navigator 2 packages. :::\n\n## Provider Modifiers [​](\\#provider-modifiers \"Direct link to Provider Modifiers\")\n\nAll Providers have a built-in way to add extra functionalities to your different providers.\n\nThey may add new features to the `ref` object or change slightly how the provider\nis consumed.\nModifiers can be used on all providers, with a syntax similar to named constructor:\n\n```codeBlockLines_e6Vv\nfinal myAutoDisposeProvider = StateProvider.autoDispose<int>((ref) => 0);\nfinal myFamilyProvider = Provider.family<String, int>((ref, id) => '$id');\n\n```\n\nAt the moment, there are two modifiers available:\n\n- [.autoDispose](/docs/concepts/modifiers/auto_dispose), which will make the provider automatically destroy its state when it is no longer being listened to.\n- [.family](/docs/concepts/modifiers/family), which allows creating a provider from external parameters.\n\nA provider can use multiple modifiers at once:\n\n```codeBlockLines_e6Vv\nfinal userProvider = FutureProvider.autoDispose.family<User, int>((ref, userId) async {\n  return fetchUser(userId);\n});\n\n```\n\n:::\n\nThat's it for this guide!\n\nYou can continue with [Reading a Provider](/docs/concepts/reading).\nAlternatively, you can see [Combining Provider States](/docs/concepts/combining_providers).\n\n- [Why use providers?](#why-use-providers)\n- [Creating a provider](#creating-a-provider)\n- [Different Types of Providers](#different-types-of-providers)",
    "metadata": {
      "url": "https://riverpod.dev/docs/concepts/providers",
      "ogUrl": "https://riverpod.dev/docs/concepts/providers",
      "title": "Providers | Riverpod",
      "og:url": "https://riverpod.dev/docs/concepts/providers",
      "ogImage": "https://riverpod.dev/img/cover.png",
      "ogTitle": "Providers | Riverpod",
      "language": "en",
      "og:image": "https://riverpod.dev/img/cover.png",
      "og:title": "Providers | Riverpod",
      "viewport": "width=device-width, initial-scale=1.0",
      "generator": "Docusaurus v2.4.3",
      "sourceURL": "https://riverpod.dev/docs/concepts/providers",
      "statusCode": 200,
      "description": "The content of this page may be outdated.",
      "twitter:card": "summary_large_image",
      "ogDescription": "The content of this page may be outdated.",
      "twitter:image": "https://riverpod.dev/img/cover.png",
      "docusaurus_tag": "docs-default-current",
      "og:description": "The content of this page may be outdated.",
      "docsearch:version": "current",
      "docusaurus_locale": "en",
      "ogLocaleAlternate": [],
      "docsearch:language": "en",
      "docusaurus_version": "current",
      "docsearch:docusaurus_tag": "docs-default-current"
    }
  },
  {
    "markdown": "[Skip to main content](#__docusaurus_skipToContent_fallback)\n\nOn this page\n\nA core part of the Riverpod API is the ability to test your providers in isolation.\n\nFor a proper test suite, there are a few challenges to overcome:\n\n- Tests should not share state. This means that new tests should\nnot be affected by the previous tests.\n- Tests should give us the ability to mock certain functionalities\nto achieve the desired state.\n- The test environment should be as close as possible to the real\nenvironment.\n\nFortunately, Riverpod makes it easy to achieve all of these goals.\n\n## Setting up a test [​](\\#setting-up-a-test \"Direct link to Setting up a test\")\n\nWhen defining a test with Riverpod, there are two main scenarios:\n\n- Unit tests, usually with no Flutter dependency.\nThis can be useful for testing the behavior of a provider in isolation.\n- Widget tests, usually with a Flutter dependency.\nThis can be useful for testing the behavior of a widget that uses a provider.\n\n### Unit tests [​](\\#unit-tests \"Direct link to Unit tests\")\n\nUnit tests are defined using the `test` function from [package:test](https://pub.dev/packages/test).\n\nThe main difference with any other test is that we will want to create\na `ProviderContainer` object. This object will enable our test to interact\nwith providers.\n\nIt is encouraged to make a testing utility for both creating and disposing\nof a `ProviderContainer` object:\n\n```codeBlockLines_e6Vv\nimport 'package:riverpod/riverpod.dart';\nimport 'package:test/test.dart';\n\n/// A testing utility which creates a [ProviderContainer] and automatically\n/// disposes it at the end of the test.\nProviderContainer createContainer({\n  ProviderContainer? parent,\n  List<Override> overrides = const [],\n  List<ProviderObserver>? observers,\n}) {\n  // Create a ProviderContainer, and optionally allow specifying parameters.\n  final container = ProviderContainer(\n    parent: parent,\n    overrides: overrides,\n    observers: observers,\n  );\n\n  // When the test ends, dispose the container.\n  addTearDown(container.dispose);\n\n  return container;\n}\n\n```\n\nThen, we can define a `test` using this utility:\n\n```codeBlockLines_e6Vv\nvoid main() {\n  test('Some description', () {\n    // Create a ProviderContainer for this test.\n    // DO NOT share ProviderContainers between tests.\n    final container = createContainer();\n\n    // TODO: use the container to test your application.\n    expect(\n      container.read(provider),\n      equals('some value'),\n    );\n  });\n}\n\n```\n\nNow that we have a ProviderContainer, we can use it to read providers using:\n\n- `container.read`, to read the current value of a provider.\n- `container.listen`, to listen to a provider and be notified of changes.\n\ncaution\n\nBe careful when using `container.read` when providers are automatically disposed.\n\nIf your provider is not listened to, chances are that its state will get destroyed\nin the middle of your test.\n\nIn that case, consider using `container.listen`.\n\nIts return value enables reading the current value of provider anyway,\nbut will also ensure that the provider is not disposed in the middle of your test:\n\n```codeBlockLines_e6Vv\n    final subscription = container.listen<String>(provider, (_, __) {});\n\n    expect(\n      // Equivalent to `container.read(provider)`\n      // But the provider will not be disposed unless \"subscription\" is disposed.\n      subscription.read(),\n      'Some value',\n    );\n\n\n```\n\n### Widget tests [​](\\#widget-tests \"Direct link to Widget tests\")\n\nWidget tests are defined using the `testWidgets` function from [package:flutter\\_test](https://pub.dev/packages/flutter_test).\n\nIn this case, the main difference with usual Widget tests is that we must add\na `ProviderScope` widget at the root of `tester.pumpWidget`:\n\n```codeBlockLines_e6Vv\nvoid main() {\n  testWidgets('Some description', (tester) async {\n    await tester.pumpWidget(\n      const ProviderScope(child: YourWidgetYouWantToTest()),\n    );\n  });\n}\n\n```\n\nThis is similar to what we do when we enable Riverpod in our Flutter app.\n\nThen, we can use `tester` to interact with our widget.\nAlternatively if you want to interact with providers, you can obtain\na `ProviderContainer`.\nOne can be obtained using `ProviderScope.containerOf(buildContext)`.\n\nBy using `tester`, we can therefore write the following:\n\n```codeBlockLines_e6Vv\n    final element = tester.element(find.byType(YourWidgetYouWantToTest));\n    final container = ProviderScope.containerOf(element);\n\n\n```\n\nWe can then use it to read providers. Here's a full example:\n\n```codeBlockLines_e6Vv\nvoid main() {\n  testWidgets('Some description', (tester) async {\n    await tester.pumpWidget(\n      const ProviderScope(child: YourWidgetYouWantToTest()),\n    );\n\n    final element = tester.element(find.byType(YourWidgetYouWantToTest));\n    final container = ProviderScope.containerOf(element);\n\n    // TODO interact with your providers\n    expect(\n      container.read(provider),\n      'some value',\n    );\n  });\n}\n\n```\n\n## Mocking providers [​](\\#mocking-providers \"Direct link to Mocking providers\")\n\nSo far, we've seen how to set up a test and basic interactions with providers.\nHowever, in some cases, we may want to mock a provider.\n\nThe cool part: All providers can be mocked by default, without any additional setup.\n\nThis is possible by specifying the `overrides` parameter on either\n`ProviderScope` or `ProviderContainer`.\n\nConsider the following provider:\n\n```codeBlockLines_e6Vv\n// An eagerly initialized provider.\n@riverpod\nFuture<String> example(Ref ref) async => 'Hello world';\n\n```\n\nWe can mock it using:\n\n```codeBlockLines_e6Vv\n    // In unit tests, by reusing our previous \"createContainer\" utility.\n    final container = createContainer(\n      // We can specify a list of providers to mock:\n      overrides: [\\\n        // In this case, we are mocking \"exampleProvider\".\\\n        exampleProvider.overrideWith((ref) {\\\n          // This function is the typical initialization function of a provider.\\\n          // This is where you normally call \"ref.watch\" and return the initial state.\\\n\\\n          // Let's replace the default \"Hello world\" with a custom value.\\\n          // Then, interacting with `exampleProvider` will return this value.\\\n          return 'Hello from tests';\\\n        }),\\\n      ],\n    );\n\n    // We can also do the same thing in widget tests using ProviderScope:\n    await tester.pumpWidget(\n      ProviderScope(\n        // ProviderScopes have the exact same \"overrides\" parameter\n        overrides: [\\\n          // Same as before\\\n          exampleProvider.overrideWith((ref) => 'Hello from tests'),\\\n        ],\n        child: const YourWidgetYouWantToTest(),\n      ),\n    );\n\n\n```\n\n## Spying on changes in a provider [​](\\#spying-on-changes-in-a-provider \"Direct link to Spying on changes in a provider\")\n\nSince we obtained a `ProviderContainer` in our tests, it is possible to\nuse it to \"listen\" to a provider:\n\n```codeBlockLines_e6Vv\n    container.listen<String>(\n      provider,\n      (previous, next) {\n        print('The provider changed from $previous to $next');\n      },\n    );\n\n\n```\n\nYou can then combine this with packages such as [mockito](https://pub.dev/packages/mockito)\nor [mocktail](https://pub.dev/packages/mocktail) to use their `verify` API.\n\nOr more simply, you can add all changes in a list and assert on it.\n\n## Awaiting asynchronous providers [​](\\#awaiting-asynchronous-providers \"Direct link to Awaiting asynchronous providers\")\n\nIn Riverpod, it is very common for providers to return a Future/Stream.\n\nIn that case, chances are that our tests need to await for that asynchronous operation\nto be completed.\n\nOne way to do so is to read the `.future` of a provider:\n\n```codeBlockLines_e6Vv\n    // TODO: use the container to test your application.\n    // Our expectation is asynchronous, so we should use \"expectLater\"\n    await expectLater(\n      // We read \"provider.future\" instead of \"provider\".\n      // This is possible on asynchronous providers, and returns a future\n      // which will resolve with the value of the provider.\n      container.read(provider.future),\n      // We can verify that the future resolves with the expected value.\n      // Alternatively we can use \"throwsA\" for errors.\n      completion('some value'),\n    );\n\n\n```\n\n## Mocking Notifiers [​](\\#mocking-notifiers \"Direct link to Mocking Notifiers\")\n\nIt is generally discouraged to mock Notifiers. This is because Notifiers cannot be\ninstantiated on their own, and only work when used as part of a Provider.\n\nInstead, you should likely introduce a level of abstraction in the logic of your\nNotifier, such that you can mock that abstraction.\nFor instance, rather than mocking a Notifier, you could mock a \"repository\"\nthat the Notifier uses to fetch data from.\n\nIf you insist on mocking a Notifier, there is a special consideration\nto create such a mock: Your mock must subclass the original Notifier\nbase class: You cannot \"implement\" Notifier, as this would break the interface.\n\nAs such, when mocking a Notifier, instead of writing the following mockito code:\n\n```codeBlockLines_e6Vv\nclass MyNotifierMock with Mock implements MyNotifier {}\n\n```\n\nYou should instead write:\n\n```codeBlockLines_e6Vv\n@riverpod\nclass MyNotifier extends _$MyNotifier {\n  @override\n  int build() => throw UnimplementedError();\n}\n\n// Your mock needs to subclass the Notifier base-class corresponding\n// to whatever your notifier uses\nclass MyNotifierMock extends _$MyNotifier with Mock implements MyNotifier {}\n\n```\n\nFor this to work, your mock will have to be placed in the same file as the\nNotifier you are mocking. Otherwise you would not have access to the `_$MyNotifier` class.\n\nThen, to use your notifier you could do:\n\n```codeBlockLines_e6Vv\nvoid main() {\n  test('Some description', () {\n    final container = createContainer(\n      // Override the provider to have it create our mock Notifier.\n      overrides: [myNotifierProvider.overrideWith(MyNotifierMock.new)],\n    );\n\n    // Then obtain the mocked notifier through the container:\n    final notifier = container.read(myNotifierProvider.notifier);\n\n    // You can then interact with the notifier as you would with the real one:\n    notifier.state = 42;\n  });\n}\n\n```\n\n- [Setting up a test](#setting-up-a-test)\n  - [Unit tests](#unit-tests)\n  - [Widget tests](#widget-tests)\n- [Mocking providers](#mocking-providers)\n- [Spying on changes in a provider](#spying-on-changes-in-a-provider)\n- [Awaiting asynchronous providers](#awaiting-asynchronous-providers)\n- [Mocking Notifiers](#mocking-notifiers)",
    "metadata": {
      "url": "https://riverpod.dev/docs/essentials/testing",
      "ogUrl": "https://riverpod.dev/docs/essentials/testing",
      "title": "Testing your providers | Riverpod",
      "og:url": "https://riverpod.dev/docs/essentials/testing",
      "ogImage": "https://riverpod.dev/img/cover.png",
      "ogTitle": "Testing your providers | Riverpod",
      "language": "en",
      "og:image": "https://riverpod.dev/img/cover.png",
      "og:title": "Testing your providers | Riverpod",
      "viewport": "width=device-width, initial-scale=1.0",
      "generator": "Docusaurus v2.4.3",
      "sourceURL": "https://riverpod.dev/docs/essentials/testing",
      "statusCode": 200,
      "description": "A core part of the Riverpod API is the ability to test your providers in isolation.",
      "twitter:card": "summary_large_image",
      "ogDescription": "A core part of the Riverpod API is the ability to test your providers in isolation.",
      "twitter:image": "https://riverpod.dev/img/cover.png",
      "docusaurus_tag": "docs-default-current",
      "og:description": "A core part of the Riverpod API is the ability to test your providers in isolation.",
      "docsearch:version": "current",
      "docusaurus_locale": "en",
      "ogLocaleAlternate": [],
      "docsearch:language": "en",
      "docusaurus_version": "current",
      "docsearch:docusaurus_tag": "docs-default-current"
    }
  },
  {
    "markdown": "[Skip to main content](#__docusaurus_skipToContent_fallback)\n\nOn this page\n\nWith the release of version `0.14.0` of Riverpod, the syntax for using [StateNotifierProvider](/docs/providers/state_notifier_provider) changed\n(see [https://github.com/rrousselGit/riverpod/issues/341](https://github.com/rrousselGit/riverpod/issues/341) for the explanation).\n\nFor the entire article, consider the following [StateNotifier](https://pub.dev/documentation/state_notifier/latest/state_notifier/StateNotifier-class.html):\n\n```codeBlockLines_e6Vv\nclass MyModel {}\n\nclass MyStateNotifier extends StateNotifier<MyModel> {\n  MyStateNotifier(): super(MyModel());\n}\n\n```\n\n## The changes [​](\\#the-changes \"Direct link to The changes\")\n\n- [StateNotifierProvider](/docs/providers/state_notifier_provider) takes an extra generic parameter, which should be\nthe type of the state of your [StateNotifier](https://pub.dev/documentation/state_notifier/latest/state_notifier/StateNotifier-class.html).\n\nBefore:\n\n\n\n\n\n```codeBlockLines_e6Vv\nfinal provider = StateNotifierProvider<MyStateNotifier>((ref) {\n    return MyStateNotifier();\n});\n\n```\n\n\n\n\n\n\n\n\n\nAfter:\n\n\n\n\n\n```codeBlockLines_e6Vv\nfinal provider = StateNotifierProvider<MyStateNotifier, MyModel>((ref) {\n    return MyStateNotifier();\n});\n\n```\n\n- to obtain the [StateNotifier](https://pub.dev/documentation/state_notifier/latest/state_notifier/StateNotifier-class.html), you should now read `myProvider.notifier` instead of just `myProvider`:\n\nBefore:\n\n\n\n\n\n```codeBlockLines_e6Vv\nWidget build(BuildContext context, ScopedReader watch) {\n    MyStateNotifier notifier = watch(provider);\n}\n\n```\n\n\n\n\n\n\n\n\n\nAfter:\n\n\n\n\n\n```codeBlockLines_e6Vv\nWidget build(BuildContext context, ScopedReader watch) {\n    MyStateNotifier notifier = watch(provider.notifier);\n}\n\n```\n\n- to listen to the state of the [StateNotifier](https://pub.dev/documentation/state_notifier/latest/state_notifier/StateNotifier-class.html), you should now read `myProvider` instead of `myProvider.state`:\n\nBefore:\n\n\n\n\n\n```codeBlockLines_e6Vv\nWidget build(BuildContext context, ScopedReader watch) {\n    MyModel state = watch(provider.state);\n}\n\n```\n\n\n\n\n\n\n\n\n\nAfter:\n\n\n\n\n\n```codeBlockLines_e6Vv\nWidget build(BuildContext context, ScopedReader watch) {\n    MyModel state = watch(provider);\n}\n\n```\n\n\n## Using the migration tool to automatically upgrade your projects to the new syntax [​](\\#using-the-migration-tool-to-automatically-upgrade-your-projects-to-the-new-syntax \"Direct link to Using the migration tool to automatically upgrade your projects to the new syntax\")\n\nWith version 0.14.0 came the release of a command line tool for Riverpod,\nwhich can help you migrate your projects.\n\n### Installing the command line [​](\\#installing-the-command-line \"Direct link to Installing the command line\")\n\nTo install the migration tool, run:\n\n```codeBlockLines_e6Vv\ndart pub global activate riverpod_cli\n\n```\n\nYou should now be able to run:\n\n```codeBlockLines_e6Vv\nriverpod --help\n\n```\n\n### Usage [​](\\#usage \"Direct link to Usage\")\n\nNow that the command line is installed, we can start using it.\n\n- First, open the project you want to migrate in your terminal.\n- **Do not** upgrade Riverpod.\n\nThe migration tool will upgrade the version of Riverpod for you.\n- Make sure that your project does not contain errors.\n- Execute:\n\n\n\n\n```codeBlockLines_e6Vv\nriverpod migrate\n\n```\n\n\nThe tool will then analyze your project and suggest changes. For example you may see:\n\n```codeBlockLines_e6Vv\nWidget build(BuildContext context, ScopedReader watch) {\n-  MyModel state = watch(provider.state);\n+  MyModel state = watch(provider);\n}\n\nAccept change (y = yes, n = no [default], A = yes to all, q = quit)?\n\n```\n\nTo accept the change, simply press `y`. Otherwise to reject it, press `n`.\n\n- [The changes](#the-changes)\n- [Using the migration tool to automatically upgrade your projects to the new syntax](#using-the-migration-tool-to-automatically-upgrade-your-projects-to-the-new-syntax)\n  - [Installing the command line](#installing-the-command-line)\n  - [Usage](#usage)",
    "metadata": {
      "url": "https://riverpod.dev/docs/migration/0.13.0_to_0.14.0",
      "ogUrl": "https://riverpod.dev/docs/migration/0.13.0_to_0.14.0",
      "title": "^0.13.0 to ^0.14.0 | Riverpod",
      "og:url": "https://riverpod.dev/docs/migration/0.13.0_to_0.14.0",
      "ogImage": "https://riverpod.dev/img/cover.png",
      "ogTitle": "^0.13.0 to ^0.14.0 | Riverpod",
      "language": "en",
      "og:image": "https://riverpod.dev/img/cover.png",
      "og:title": "^0.13.0 to ^0.14.0 | Riverpod",
      "viewport": "width=device-width, initial-scale=1.0",
      "generator": "Docusaurus v2.4.3",
      "sourceURL": "https://riverpod.dev/docs/migration/0.13.0_to_0.14.0",
      "statusCode": 200,
      "description": "With the release of version 0.14.0 of Riverpod, the syntax for using [StateNotifierProvider] changed",
      "twitter:card": "summary_large_image",
      "ogDescription": "With the release of version 0.14.0 of Riverpod, the syntax for using [StateNotifierProvider] changed",
      "twitter:image": "https://riverpod.dev/img/cover.png",
      "docusaurus_tag": "docs-default-current",
      "og:description": "With the release of version 0.14.0 of Riverpod, the syntax for using [StateNotifierProvider] changed",
      "docsearch:version": "current",
      "docusaurus_locale": "en",
      "ogLocaleAlternate": [],
      "docsearch:language": "en",
      "docusaurus_version": "current",
      "docsearch:docusaurus_tag": "docs-default-current"
    }
  },
  {
    "markdown": "[Skip to main content](#__docusaurus_skipToContent_fallback)\n\nOn this page\n\nIn a previous article, we saw how we could define a \"provider\" to make\na simple _GET_ HTTP request.\n\nBut often, HTTP requests depend on external parameters.\n\nFor example, previously we used the [Bored API](https://boredapi.com/)\nto suggest a random activity to users.\nBut maybe users would want to filter the type of activity they want to do,\nor have price requirements, etc...\n\nThese parameters are not known in advance. So we need a way to pass\nthese parameters from our UI to our providers.\n\n## Updating our providers to accept arguments [​](\\#updating-our-providers-to-accept-arguments \"Direct link to Updating our providers to accept arguments\")\n\nAs a reminder, previously we defined our provider like this:\n\n```codeBlockLines_e6Vv\n// A \"functional\" provider\n@riverpod\nFuture<Activity> activity(Ref ref) async {\n  // TODO: perform a network request to fetch an activity\n  return fetchActivity();\n}\n\n// Or alternatively, a \"notifier\"\n@riverpod\nclass ActivityNotifier2 extends _$ActivityNotifier2 {\n  @override\n  Future<Activity> build() async {\n    // TODO: perform a network request to fetch an activity\n    return fetchActivity();\n  }\n}\n\n```\n\nTo pass parameters to our providers, we can simply add our parameters on the annotated function itself. For example, we could update our provider to accept a \\`String\\` argument corresponding to the type of activity desired:\n\n```codeBlockLines_e6Vv\n@riverpod\nFuture<Activity> activity(\n  Ref ref,\n  // We can add arguments to the provider.\n  // The type of the parameter can be whatever you wish.\n  String activityType,\n) async {\n  // We can use the \"activityType\" argument to build the URL.\n  // This will point to \"https://boredapi.com/api/activity?type=<activityType>\"\n  final response = await http.get(\n    Uri(\n      scheme: 'https',\n      host: 'boredapi.com',\n      path: '/api/activity',\n      // No need to manually encode the query parameters, the \"Uri\" class does it for us.\n      queryParameters: {'type': activityType},\n    ),\n  );\n  final json = jsonDecode(response.body) as Map<String, dynamic>;\n  return Activity.fromJson(json);\n}\n\n@riverpod\nclass ActivityNotifier2 extends _$ActivityNotifier2 {\n  /// Notifier arguments are specified on the build method.\n  /// There can be as many as you want, have any name, and even be optional/named.\n  @override\n  Future<Activity> build(String activityType) async {\n    // Arguments are also available with \"this.<argumentName>\"\n    print(this.activityType);\n\n    // TODO: perform a network request to fetch an activity\n    return fetchActivity();\n  }\n}\n\n```\n\ncaution\n\nWhen passing arguments to providers, it is highly encouraged to\nenable \"autoDispose\" on the provider.\n\nFailing to do so may result in memory leaks.\n\nSee [Clearing cache and reacting to state disposal](/docs/essentials/auto_dispose) for more details.\n\n## Updating our UI to pass arguments [​](\\#updating-our-ui-to-pass-arguments \"Direct link to Updating our UI to pass arguments\")\n\nPreviously, widgets consumed our provider like this:\n\n```codeBlockLines_e6Vv\n    AsyncValue<Activity> activity = ref.watch(activityProvider);\n\n```\n\nBut now that our provider receives arguments, the syntax to consume it is slightly\ndifferent. The provider is now a function, which needs to be invoked with the parameters\nrequested.\n\nWe could update our UI to pass a hard-coded type of activity like this:\n\n```codeBlockLines_e6Vv\n    AsyncValue<Activity> activity = ref.watch(\n      // The provider is now a function expecting the activity type.\n      // Let's pass a constant string for now, for the sake of simplicity.\n      activityProvider('recreational'),\n    );\n\n```\n\nThe parameters passed to the provider corresponds to the parameters\nof the annotated function, minus the \"ref\" parameter.\n\ninfo\n\nIt is entirely possible to listen to the same provider with different arguments\nsimultaneously.\n\nFor example, our UI could render both \"recreational\" _and_ \"cooking\" activities:\n\n```codeBlockLines_e6Vv\n    return Consumer(\n      builder: (context, ref, child) {\n        final recreational = ref.watch(activityProvider('recreational'));\n        final cooking = ref.watch(activityProvider('cooking'));\n\n        // We can then render both activities.\n        // Both requests will happen in parallel and correctly be cached.\n        return Column(\n          children: [\\\n            Text(recreational.valueOrNull?.activity ?? ''),\\\n            Text(cooking.valueOrNull?.activity ?? ''),\\\n          ],\n        );\n      },\n    );\n\n\n```\n\n## Caching considerations and parameter restrictions [​](\\#caching-considerations-and-parameter-restrictions \"Direct link to Caching considerations and parameter restrictions\")\n\nWhen passing parameters to providers, the computation is still cached.\nThe difference is that the computation is now cached per-argument.\n\nThis means that if two widgets consumes the same provider with the same\nparameters, only a single network request will be made.\n\nBut if two widgets consumes the same provider with different parameters,\ntwo network requests will be made.\n\nFor this to work, Riverpod relies on the `==` operator of the parameters.\n\nAs such, it is important that the parameters passed to the provider\nhave consistent equality.\n\ncaution\n\nA common mistake is to directly instantiate a new object as the parameter\nof a provider, when that object does not override `==`.\n\nFor example, you may be tempted to pass a `List` like so:\n\n```codeBlockLines_e6Vv\n    // We could update activityProvider to accept a list of strings instead.\n    // Then be tempted to create that list directly in the watch call.\n    ref.watch(activityProvider(['recreational', 'cooking']));\n\n```\n\nThe problem with this code is that `['recreational', 'cooking'] == ['recreational', 'cooking']` is `false`.\nAs such, Riverpod will consider that the two parameters are different,\nand attempt to make a new network request.\n\nThis would result in an infinite loop of network requests, permanently\nshowing a progress indicator to the user.\n\nTo fix this, you could either use a `const` list ( `const ['recreational', 'cooking']`)\nor use a custom list implementation that overrides `==`.\n\nTo help spot this mistake, it is recommended to use the [riverpod\\_lint](https://pub.dev/packages/riverpod_lint)\nand enable the [provider\\_parameters](https://github.com/rrousselGit/riverpod/tree/master/packages/riverpod_lint#provider_parameters)\nlint rule. Then, the previous snippet would show a warning.\nSee [Getting started](/docs/introduction/getting_started#enabling-riverpod_lintcustom_lint) for installation steps.\n\n- [Updating our providers to accept arguments](#updating-our-providers-to-accept-arguments)\n- [Updating our UI to pass arguments](#updating-our-ui-to-pass-arguments)\n- [Caching considerations and parameter restrictions](#caching-considerations-and-parameter-restrictions)",
    "metadata": {
      "url": "https://riverpod.dev/docs/essentials/passing_args",
      "ogUrl": "https://riverpod.dev/docs/essentials/passing_args",
      "title": "Passing arguments to your requests | Riverpod",
      "og:url": "https://riverpod.dev/docs/essentials/passing_args",
      "ogImage": "https://riverpod.dev/img/cover.png",
      "ogTitle": "Passing arguments to your requests | Riverpod",
      "language": "en",
      "og:image": "https://riverpod.dev/img/cover.png",
      "og:title": "Passing arguments to your requests | Riverpod",
      "viewport": "width=device-width, initial-scale=1.0",
      "generator": "Docusaurus v2.4.3",
      "sourceURL": "https://riverpod.dev/docs/essentials/passing_args",
      "statusCode": 200,
      "description": "In a previous article, we saw how we could define a \"provider\" to make",
      "twitter:card": "summary_large_image",
      "ogDescription": "In a previous article, we saw how we could define a \"provider\" to make",
      "twitter:image": "https://riverpod.dev/img/cover.png",
      "docusaurus_tag": "docs-default-current",
      "og:description": "In a previous article, we saw how we could define a \"provider\" to make",
      "docsearch:version": "current",
      "docusaurus_locale": "en",
      "ogLocaleAlternate": [],
      "docsearch:language": "en",
      "docusaurus_version": "current",
      "docsearch:docusaurus_tag": "docs-default-current"
    }
  },
  {
    "markdown": "[Skip to main content](#__docusaurus_skipToContent_fallback)\n\nOn this page\n\ncaution\n\nThe content of this page may be outdated.\n\nIt will be updated in the future, but for now you may want to refer to the content\nin the top of the sidebar instead (introduction/essentials/case-studies/...)\n\n`StreamProvider` is similar to [FutureProvider](/docs/providers/future_provider) but for [Stream](https://api.dart.dev/dart-async/Stream-class.html) s instead of\n[Future](https://api.dart.dev/dart-async/Future-class.html) s.\n\n`StreamProvider` is usually used for:\n\n- listening to Firebase or web-sockets\n- rebuilding another provider every few seconds\n\nSince [Stream](https://api.dart.dev/dart-async/Stream-class.html) s naturally expose a way for listening to updates, some may think\nthat using `StreamProvider` has a low value. In particular, you may believe that\nFlutter's [StreamBuilder](https://api.flutter.dev/flutter/widgets/StreamBuilder-class.html) would work just as well for listening to a [Stream](https://api.dart.dev/dart-async/Stream-class.html), but\nthis is a mistake.\n\nUsing `StreamProvider` over [StreamBuilder](https://api.flutter.dev/flutter/widgets/StreamBuilder-class.html) has numerous benefits:\n\n- it allows other providers to listen to the stream using [ref.watch](/docs/concepts/reading#using-refwatch-to-observe-a-provider).\n- it ensures that loading and error cases are properly handled, thanks to [AsyncValue](https://pub.dev/documentation/riverpod/latest/riverpod/AsyncValue-class.html).\n- it removes the need for having to differentiate broadcast streams vs normal streams.\n- it caches the latest value emitted by the stream, ensuring that if a\nlistener is added after an event is emitted, the listener will still have\nimmediate access to the most up-to-date event.\n- it allows easily mocking the stream during tests by overriding the `StreamProvider`.\n\n## Usage example: live chat using sockets [​](\\#usage-example-live-chat-using-sockets \"Direct link to Usage example: live chat using sockets\")\n\n`StreamProvider` is used in when we handle stream of asynchronous data\nsuch as Video Streaming, Weather broadcasting Apis or Live chat as follows:\n\n```codeBlockLines_e6Vv\n\n@riverpod\nStream<List<String>> chat(Ref ref) async* {\n  // Connect to an API using sockets, and decode the output\n  final socket = await Socket.connect('my-api', 4242);\n  ref.onDispose(socket.close);\n\n  var allMessages = const <String>[];\n  await for (final message in socket.map(utf8.decode)) {\n    // A new message has been received. Let's add it to the list of all messages.\n    allMessages = [...allMessages, message];\n    yield allMessages;\n  }\n}\n\n```\n\nThen, the UI can listen to live streaming chats like so:\n\n```codeBlockLines_e6Vv\nWidget build(BuildContext context, WidgetRef ref) {\n  final liveChats = ref.watch(chatProvider);\n\n  // Like FutureProvider, it is possible to handle loading/error states using AsyncValue.when\n  return switch (liveChats) {\n    // Display all the messages in a scrollable list view.\n    AsyncData(:final value) => ListView.builder(\n        // Show messages from bottom to top\n        reverse: true,\n        itemCount: value.length,\n        itemBuilder: (context, index) {\n          final message = value[index];\n          return Text(message);\n        },\n      ),\n    AsyncError(:final error) => Text(error.toString()),\n    _ => const CircularProgressIndicator(),\n  };\n}\n\n```\n\n- [Usage example: live chat using sockets](#usage-example-live-chat-using-sockets)",
    "metadata": {
      "url": "https://riverpod.dev/docs/providers/stream_provider",
      "ogUrl": "https://riverpod.dev/docs/providers/stream_provider",
      "title": "StreamProvider | Riverpod",
      "og:url": "https://riverpod.dev/docs/providers/stream_provider",
      "ogImage": "https://riverpod.dev/img/cover.png",
      "ogTitle": "StreamProvider | Riverpod",
      "language": "en",
      "og:image": "https://riverpod.dev/img/cover.png",
      "og:title": "StreamProvider | Riverpod",
      "viewport": "width=device-width, initial-scale=1.0",
      "generator": "Docusaurus v2.4.3",
      "sourceURL": "https://riverpod.dev/docs/providers/stream_provider",
      "statusCode": 200,
      "description": "The content of this page may be outdated.",
      "twitter:card": "summary_large_image",
      "ogDescription": "The content of this page may be outdated.",
      "twitter:image": "https://riverpod.dev/img/cover.png",
      "docusaurus_tag": "docs-default-current",
      "og:description": "The content of this page may be outdated.",
      "docsearch:version": "current",
      "docusaurus_locale": "en",
      "ogLocaleAlternate": [],
      "docsearch:language": "en",
      "docusaurus_version": "current",
      "docsearch:docusaurus_tag": "docs-default-current"
    }
  },
  {
    "markdown": "[Skip to main content](#__docusaurus_skipToContent_fallback)\n\nOn this page\n\ncaution\n\nThe content of this page may be outdated.\n\nIt will be updated in the future, but for now you may want to refer to the content\nin the top of the sidebar instead (introduction/essentials/case-studies/...)\n\n[ProviderObserver](https://pub.dev/documentation/riverpod/latest/riverpod/ProviderObserver-class.html) listens to the changes of a ProviderContainer.\n\nTo use it, extend the class ProviderObserver and override the method you want to use.\n\n[ProviderObserver](https://pub.dev/documentation/riverpod/latest/riverpod/ProviderObserver-class.html) has three methods :\n\n- `didAddProvider` is called every time a provider was initialized, and the value exposed is `value`.\n- `didDisposeProvider` is called every time a provider was disposed.\n- `didUpdateProvider` is called every time by providers when they emit a notification.\n\n### Usage : [​](\\#usage- \"Direct link to Usage :\")\n\nA simple use case for [ProviderObserver](https://pub.dev/documentation/riverpod/latest/riverpod/ProviderObserver-class.html) is to log the changes in providers by overriding the `didUpdateProvider` method.\n\n```codeBlockLines_e6Vv\n\n// A Counter example implemented with riverpod with Logger\n\nclass Logger extends ProviderObserver {\n  @override\n  void didUpdateProvider(\n    ProviderBase<Object?> provider,\n    Object? previousValue,\n    Object? newValue,\n    ProviderContainer container,\n  ) {\n    print('''\n{\n  \"provider\": \"${provider.name ?? provider.runtimeType}\",\n  \"newValue\": \"$newValue\"\n}''');\n  }\n}\n\nvoid main() {\n  runApp(\n    // Adding ProviderScope enables Riverpod for the entire project\n    // Adding our Logger to the list of observers\n    ProviderScope(observers: [Logger()], child: const MyApp()),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(home: Home());\n  }\n}\n\nfinal counterProvider = StateProvider((ref) => 0, name: 'counter');\n\nclass Home extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final count = ref.watch(counterProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Counter example')),\n      body: Center(\n        child: Text('$count'),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => ref.read(counterProvider.notifier).state++,\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}\n\n```\n\nNow, every time the value of our provider is updated, the logger will log it:\n\n```codeBlockLines_e6Vv\nI/flutter (16783): {\nI/flutter (16783):   \"provider\": \"counter\",\nI/flutter (16783):   \"newValue\": \"1\"\nI/flutter (16783): }\n\n```\n\n:\n\nFor states that are mutable such as [StateController](https://pub.dev/documentation/riverpod/latest/riverpod/StateController-class.html) (the state of [StateProvider.state](https://pub.dev/documentation/riverpod/latest/riverpod/StateProvider/state.html)) and\n[ChangeNotifier](https://api.flutter.dev/flutter/foundation/ChangeNotifier-class.html) the previousValue and newValue will be the same\n\nsince they reference the same `StateController` / `ChangeNotifier`.\n\n- [Usage :](#usage-)",
    "metadata": {
      "url": "https://riverpod.dev/docs/concepts/provider_observer",
      "ogUrl": "https://riverpod.dev/docs/concepts/provider_observer",
      "title": "ProviderObserver | Riverpod",
      "og:url": "https://riverpod.dev/docs/concepts/provider_observer",
      "ogImage": "https://riverpod.dev/img/cover.png",
      "ogTitle": "ProviderObserver | Riverpod",
      "language": "en",
      "og:image": "https://riverpod.dev/img/cover.png",
      "og:title": "ProviderObserver | Riverpod",
      "viewport": "width=device-width, initial-scale=1.0",
      "generator": "Docusaurus v2.4.3",
      "sourceURL": "https://riverpod.dev/docs/concepts/provider_observer",
      "statusCode": 200,
      "description": "The content of this page may be outdated.",
      "twitter:card": "summary_large_image",
      "ogDescription": "The content of this page may be outdated.",
      "twitter:image": "https://riverpod.dev/img/cover.png",
      "docusaurus_tag": "docs-default-current",
      "og:description": "The content of this page may be outdated.",
      "docsearch:version": "current",
      "docusaurus_locale": "en",
      "ogLocaleAlternate": [],
      "docsearch:language": "en",
      "docusaurus_version": "current",
      "docsearch:docusaurus_tag": "docs-default-current"
    }
  },
  {
    "markdown": "[Skip to main content](#__docusaurus_skipToContent_fallback)\n\nOn this page\n\nThis article recaps the differences and the similarities between Provider and Riverpod.\n\n## Defining providers [​](\\#defining-providers \"Direct link to Defining providers\")\n\nThe primary difference between both packages is how \"providers\" are defined.\n\nWith [Provider](https://pub.dev/packages/provider), providers are widgets and as such placed inside the widget tree,\ntypically inside a `MultiProvider`:\n\n```codeBlockLines_e6Vv\nclass Counter extends ChangeNotifier {\n ...\n}\n\nvoid main() {\n  runApp(\n    MultiProvider(\n      providers: [\\\n        ChangeNotifierProvider<Counter>(create: (context) => Counter()),\\\n      ],\n      child: MyApp(),\n    )\n  );\n}\n\n```\n\nWith Riverpod, providers are **not** widgets. Instead they are plain Dart objects.\n\nSimilarly, providers are defined outside of the widget tree, and instead are declared\nas global final variables.\n\nAlso, for Riverpod to work, it is necessary to add a `ProviderScope` widget above the\nentire application. As such, the equivalent of the Provider example using Riverpod\nwould be:\n\n```codeBlockLines_e6Vv\n// Providers are now top-level variables\nfinal counterProvider = ChangeNotifierProvider<Counter>((ref) => Counter());\n\nvoid main() {\n  runApp(\n    // This widget enables Riverpod for the entire project\n    ProviderScope(\n      child: MyApp(),\n    ),\n  );\n}\n\n```\n\nNotice how the provider definition simply moved up a few lines.\n\ninfo\n\nSince with Riverpod providers are plain Dart objects, it is possible to use\nRiverpod without Flutter.\n\nFor example, Riverpod can be used to write command line applications.\n\n## Reading providers: BuildContext [​](\\#reading-providers-buildcontext \"Direct link to Reading providers: BuildContext\")\n\nWith Provider, one way of reading providers is to use a Widget's `BuildContext`.\n\nFor example, if a provider was defined as:\n\n```codeBlockLines_e6Vv\nProvider<Model>(...);\n\n```\n\nthen reading it using [Provider](https://pub.dev/packages/provider) is done with:\n\n```codeBlockLines_e6Vv\nclass Example extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    Model model = context.watch<Model>();\n\n  }\n}\n\n```\n\nThe equivalent in Riverpod would be:\n\n```codeBlockLines_e6Vv\nfinal modelProvider = Provider<Model>(...);\n\nclass Example extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    Model model = ref.watch(modelProvider);\n\n  }\n}\n\n```\n\nNotice how:\n\n- Riverpod's snippet extends `ConsumerWidget` instead of `StatelessWidget`.\nThat different widget type adds one extra parameter to our `build` function:\n`WidgetRef`.\n\n- Instead of `BuildContext.watch`, in Riverpod we do `WidgetRef.watch`, using\nthe `WidgetRef` which we obtained from `ConsumerWidget`.\n\n- Riverpod does not rely on generic types. Instead it relies on the variable\ncreated using provider definition.\n\n\nNotice too how similar the wording is. Both Provider and Riverpod use the keyword\n\"watch\" to describe \"this widget should rebuild when the value changes\".\n\ninfo\n\nRiverpod uses the same terminology as Provider for reading providers.\n\n- `BuildContext.watch` -\\> `WidgetRef.watch`\n- `BuildContext.read` -\\> `WidgetRef.read`\n- `BuildContext.select` -\\> `WidgetRef.watch(myProvider.select)`\n\nThe rules for `context.watch` vs `context.read` applies to Riverpod too:\n\nInside the `build` method, use \"watch\". Inside click handlers and other events,\nuse \"read\". When in need of filtering out values and rebuilds, use \"select\".\n\n## Reading providers: Consumer [​](\\#reading-providers-consumer \"Direct link to Reading providers: Consumer\")\n\nProvider optionally comes with a widget named `Consumer` (and variants such as `Consumer2`)\nfor reading providers.\n\n`Consumer` is helpful as a performance optimization, by allowing more granular rebuilds\nof the widget tree - updating only the relevant widgets when the state changes:\n\nAs such, if a provider was defined as:\n\n```codeBlockLines_e6Vv\nProvider<Model>(...);\n\n```\n\nProvider allows reading that provider using `Consumer` with:\n\n```codeBlockLines_e6Vv\nConsumer<Model>(\n  builder: (BuildContext context, Model model, Widget? child) {\n\n  }\n)\n\n```\n\nRiverpod has the same principle. Riverpod, too, has a widget named `Consumer`\nfor the exact same purpose.\n\nIf we defined a provider as:\n\n```codeBlockLines_e6Vv\nfinal modelProvider = Provider<Model>(...);\n\n```\n\nThen using `Consumer` we could do:\n\n```codeBlockLines_e6Vv\nConsumer(\n  builder: (BuildContext context, WidgetRef ref, Widget? child) {\n    Model model = ref.watch(modelProvider);\n\n  }\n)\n\n```\n\nNotice how `Consumer` gives us a `WidgetRef` object. This is the same object\nas we saw in the previous part related to `ConsumerWidget`.\n\n### There is no `ConsumerN` equivalent in Riverpod [​](\\#there-is-no-consumern-equivalent-in-riverpod \"Direct link to there-is-no-consumern-equivalent-in-riverpod\")\n\nNotice how pkg:Provider's `Consumer2`, `Consumer3` and such aren't needed nor missed in Riverpod.\n\nWith Riverpod, if you want to read values from multiple providers, you can simply write multiple `ref.watch` statements,\nlike so:\n\n```codeBlockLines_e6Vv\nConsumer(\n  builder: (context, ref, child) {\n    Model1 model = ref.watch(model1Provider);\n    Model2 model = ref.watch(model2Provider);\n    Model3 model = ref.watch(model3Provider);\n    // ...\n  }\n)\n\n```\n\nWhen compared to pkg:Provider's `ConsumerN` APIs, the above solution feels way less heavy and it should be easier to understand.\n\n## Combining providers: ProxyProvider with stateless objects [​](\\#combining-providers-proxyprovider-with-stateless-objects \"Direct link to Combining providers: ProxyProvider with stateless objects\")\n\nWhen using Provider, the official way of combining providers is using the\n`ProxyProvider` widget (or variants such as `ProxyProvider2`).\n\nFor example we may define:\n\n```codeBlockLines_e6Vv\nclass UserIdNotifier extends ChangeNotifier {\n  String? userId;\n}\n\n// ...\n\nChangeNotifierProvider<UserIdNotifier>(create: (context) => UserIdNotifier()),\n\n```\n\nFrom there we have two options. We may combine `UserIdNotifier` to create a new\n\"stateless\" provider (typically an immutable value that possibly override ==).\nSuch as:\n\n```codeBlockLines_e6Vv\nProxyProvider<UserIdNotifier, String>(\n  update: (context, userIdNotifier, _) {\n    return 'The user ID of the the user is ${userIdNotifier.userId}';\n  }\n)\n\n```\n\nThis provider would automatically return a new `String` whenever\n`UserIdNotifier.userId` changes.\n\nWe can do something similar in Riverpod, but the syntax is different.\n\nFirst, in Riverpod, the definition of our `UserIdNotifier` would be:\n\n```codeBlockLines_e6Vv\nclass UserIdNotifier extends ChangeNotifier {\n  String? userId;\n}\n\n// ...\n\nfinal userIdNotifierProvider = ChangeNotifierProvider<UserIdNotifier>(\n  (ref) => UserIdNotifier(),\n);\n\n```\n\nFrom there, to generate our `String` based on the `userId`, we could do:\n\n```codeBlockLines_e6Vv\nfinal labelProvider = Provider<String>((ref) {\n  UserIdNotifier userIdNotifier = ref.watch(userIdNotifierProvider);\n  return 'The user ID of the the user is ${userIdNotifier.userId}';\n});\n\n```\n\nNotice the line doing `ref.watch(userIdNotifierProvider)`.\n\nThis line of code tells Riverpod to obtain the content of the `userIdNotifierProvider`\nand that whenever that value changes, `labelProvider` will be recomputed too.\nAs such, the `String` emitted by our `labelProvider` will automatically update\nwhenever the `userId` changes.\n\nThis `ref.watch` line should feel similar. This pattern was covered previously\nwhen explaining [how to read providers inside widgets](#reading-providers-buildcontext).\nIndeed, providers are now able to listen to other providers in the same way\nthat widgets do.\n\n## Combining providers: ProxyProvider with stateful objects [​](\\#combining-providers-proxyprovider-with-stateful-objects \"Direct link to Combining providers: ProxyProvider with stateful objects\")\n\nWhen combining providers, another alternative use-case is to expose\nstateful objects, such as a `ChangeNotifier` instance.\n\nFor that, we could use `ChangeNotifierProxyProvider` (or variants such as `ChangeNotifierProxyProvider2`).\n\nFor example we may define:\n\n```codeBlockLines_e6Vv\nclass UserIdNotifier extends ChangeNotifier {\n  String? userId;\n}\n\n// ...\n\nChangeNotifierProvider<UserIdNotifier>(create: (context) => UserIdNotifier()),\n\n```\n\nThen, we can define a new `ChangeNotifier` that is based on `UserIdNotifier.userId`.\nFor example we could do:\n\n```codeBlockLines_e6Vv\nclass UserNotifier extends ChangeNotifier {\n  String? _userId;\n\n  void setUserId(String? userId) {\n    if (userId != _userId) {\n      print('The user ID changed from $_userId to $userId');\n      _userId = userId;\n    }\n  }\n}\n\n// ...\n\nChangeNotifierProxyProvider<UserIdNotifier, UserNotifier>(\n  create: (context) => UserNotifier(),\n  update: (context, userIdNotifier, userNotifier) {\n    return userNotifier!\n      ..setUserId(userIdNotifier.userId);\n  },\n);\n\n```\n\nThis new provider creates a single instance of `UserNotifier` (which is never re-constructed)\nand prints a string whenever the user ID changes.\n\nDoing the same thing in provider is achieved differently.\nFirst, in Riverpod, the definition of our `UserIdNotifier` would be:\n\n```codeBlockLines_e6Vv\nclass UserIdNotifier extends ChangeNotifier {\n  String? userId;\n}\n\n// ...\n\nfinal userIdNotifierProvider = ChangeNotifierProvider<UserIdNotifier>(\n  (ref) => UserIdNotifier(),\n),\n\n```\n\nFrom there, the equivalent to the previous `ChangeNotifierProxyProvider` would be:\n\n```codeBlockLines_e6Vv\nclass UserNotifier extends ChangeNotifier {\n  String? _userId;\n\n  void setUserId(String? userId) {\n    if (userId != _userId) {\n      print('The user ID changed from $_userId to $userId');\n      _userId = userId;\n    }\n  }\n}\n\n// ...\n\nfinal userNotifierProvider = ChangeNotifierProvider<UserNotifier>((ref) {\n  final userNotifier = UserNotifier();\n  ref.listen<UserIdNotifier>(\n    userIdNotifierProvider,\n    (previous, next) {\n      if (previous?.userId != next.userId) {\n        userNotifier.setUserId(next.userId);\n      }\n    },\n  );\n\n  return userNotifier;\n});\n\n```\n\nThe core of this snippet is the `ref.listen` line.\n\nThis `ref.listen` function is a utility that allows listening to a provider,\nand whenever the provider changes, executes a function.\n\nThe `previous` and `next` parameters of that function correspond to the\nlast value before the provider changed and the new value after it changed.\n\n## Scoping Providers vs `.family` \\+ `.autoDispose` [​](\\#scoping-providers-vs-family--autodispose \"Direct link to scoping-providers-vs-family--autodispose\")\n\nIn pkg:Provider, scoping was used for two things:\n\n- destroying state when leaving a page\n- having custom state per page\n\nUsing scoping just to destroy state isn't ideal.\n\nThe problem is that scoping doesn't work well over large applications.\n\nFor example, state often is created in one page, but destroyed later in a different page after navigation.\n\nThis doesn't allow for multiple caches to be active over different pages.\n\nSimilarly, the \"custom state per page\" approach quickly becomes difficult to handle if that state\nneeds to be shared with another part of the widget tree,\nlike you'd need with modals or a with a multi-step form.\n\nRiverpod takes a different approach: first, scoping providers is kind-of discouraged; second,\n`.family` and `.autoDispose` are a complete replacement solution for this.\n\nWithin Riverpod, Providers marked as `.autoDispose` automatically destroy their state when they aren't used anymore.\n\nWhen the last widget removing a provider is unmounted, Riverpod will detect this and destroy the provider.\n\nTry using these two lifecycle methods in a provider to test this behavior:\n\n```codeBlockLines_e6Vv\nref.onCancel((){\n  print(\"No one listens to me anymore!\");\n});\nref.onDispose((){\n  print(\"If I've been defined as `.autoDispose`, I just got disposed!\");\n});\n\n```\n\nThis inherently solves the \"destroying state\" problem.\n\nAlso it is possible to mark a Provider as `.family` (and, at the same time, as `.autoDispose`).\n\nThis enables passing parameters to providers, which make multiple providers to be spawned and tracked internally.\n\nIn other words, when passing parameters, _a unique state is created per unique parameter_.\n\n```codeBlockLines_e6Vv\n\n@riverpod\nint random(Ref ref, {required int seed, required int max}) {\n  return Random(seed).nextInt(max);\n}\n\n```\n\nThis solves the \"custom state per page\" problem. Actually, there's another advantage: such state is no-longer bound to one specific page.\n\nInstead, if a different page tries to access the same state, such page will be able to do so by just reusing the parameters.\n\nIn many ways, passing parameters to providers is equivalent to a Map key.\n\nIf the key is the same, the value obtained is the same. If it's a different key, a different state will be obtained.\n\n- [Defining providers](#defining-providers)\n- [Reading providers: BuildContext](#reading-providers-buildcontext)\n- [Reading providers: Consumer](#reading-providers-consumer)\n  - [There is no `ConsumerN` equivalent in Riverpod](#there-is-no-consumern-equivalent-in-riverpod)\n- [Combining providers: ProxyProvider with stateless objects](#combining-providers-proxyprovider-with-stateless-objects)\n- [Combining providers: ProxyProvider with stateful objects](#combining-providers-proxyprovider-with-stateful-objects)\n- [Scoping Providers vs `.family` \\+ `.autoDispose`](#scoping-providers-vs-family--autodispose)",
    "metadata": {
      "url": "https://riverpod.dev/docs/from_provider/provider_vs_riverpod",
      "ogUrl": "https://riverpod.dev/docs/from_provider/provider_vs_riverpod",
      "title": "Provider vs Riverpod | Riverpod",
      "og:url": "https://riverpod.dev/docs/from_provider/provider_vs_riverpod",
      "ogImage": "https://riverpod.dev/img/cover.png",
      "ogTitle": "Provider vs Riverpod | Riverpod",
      "language": "en",
      "og:image": "https://riverpod.dev/img/cover.png",
      "og:title": "Provider vs Riverpod | Riverpod",
      "viewport": "width=device-width, initial-scale=1.0",
      "generator": "Docusaurus v2.4.3",
      "sourceURL": "https://riverpod.dev/docs/from_provider/provider_vs_riverpod",
      "statusCode": 200,
      "description": "This article recaps the differences and the similarities between Provider and Riverpod.",
      "twitter:card": "summary_large_image",
      "ogDescription": "This article recaps the differences and the similarities between Provider and Riverpod.",
      "twitter:image": "https://riverpod.dev/img/cover.png",
      "docusaurus_tag": "docs-default-current",
      "og:description": "This article recaps the differences and the similarities between Provider and Riverpod.",
      "docsearch:version": "current",
      "docusaurus_locale": "en",
      "ogLocaleAlternate": [],
      "docsearch:language": "en",
      "docusaurus_version": "current",
      "docsearch:docusaurus_tag": "docs-default-current"
    }
  },
  {
    "markdown": "[Skip to main content](#__docusaurus_skipToContent_fallback)\n\nOn this page\n\nWithin Riverpod, `ChangeNotifierProvider` is meant to be used to offer a smooth transition from\npkg:provider.\n\nIf you've just started a migration to pkg:riverpod, make sure you read the dedicated guide\n(see [Quickstart](/docs/from_provider/quickstart)).\nThis article is meant for folks that already transitioned to riverpod, but want to move away from\n`ChangeNotifier` definetively.\n\nAll in all, migrating from `ChangeNotifier` to `AsyncNotifer` requires a\nparadigm shift, but it brings great simplification with the resulting migrated\ncode. See also [Why Immutability](/docs/concepts/why_immutability).\n\nTake this (faulty) example:\n\n```codeBlockLines_e6Vv\nclass MyChangeNotifier extends ChangeNotifier {\n  MyChangeNotifier() {\n    _init();\n  }\n  List<Todo> todos = [];\n  bool isLoading = true;\n  bool hasError = false;\n\n  Future<void> _init() async {\n    try {\n      final json = await http.get('api/todos');\n      todos = [...json.map(Todo.fromJson)];\n    } on Exception {\n      hasError = true;\n    } finally {\n      isLoading = false;\n      notifyListeners();\n    }\n  }\n\n  Future<void> addTodo(int id) async {\n    isLoading = true;\n    notifyListeners();\n\n    try {\n      final json = await http.post('api/todos');\n      todos = [...json.map(Todo.fromJson)];\n      hasError = false;\n    } on Exception {\n      hasError = true;\n    } finally {\n      isLoading = false;\n      notifyListeners();\n    }\n  }\n}\n\nfinal myChangeProvider = ChangeNotifierProvider<MyChangeNotifier>((ref) {\n  return MyChangeNotifier();\n});\n\n```\n\nThis implementation shows several weak design choices such as:\n\n- The usage of `isLoading` and `hasError` to handle different asynchronous cases\n- The need to carefully handle requests with tedious `try`/ `catch`/ `finally` expressions\n- The need to inkove `notifyListeners` at the right times to make this implementation work\n- The presence of inconsistent or possibly undesirable states, e.g. initialization with an empty list\n\nNote how this example has been crafted to show how `ChangeNotifier` can lead to faulty design choices\nfor newbie developers; also, another takeaway is that mutable state might be way harder than it\ninitially promises.\n\n`Notifier`/ `AsyncNotifer`, in combination with immutable state, can lead to better design choices\nand less errors.\n\nLet's see how to migrate the above snippet, one step at a time, towards the newest APIs.\n\n## Start your migration [​](\\#start-your-migration \"Direct link to Start your migration\")\n\nFirst, we should declare the new provider / notifier: this requires some thought process which\ndepends on your unique business logic.\n\nLet's summarize the above requirements:\n\n- State is represented with `List<Todo>`, which obtained via a network call, with no parameters\n- State should _also_ expose info about its `loading`, `error` and `data` state\n- State can be mutated via some exposed methods, thus a function isn't enough\n\ntip\n\nThe above thought process boils down to answering the following questions:\n\n1. Are some side effects required?\n   - `y`: Use riverpod's class-based API\n   - `n`: Use riverpod's function-based API\n2. Does state need to be loaded asynchronously?\n   - `y`: Let `build` return a `Future<T>`\n   - `n`: Let `build` simply return `T`\n3. Are some parameters required?\n   - `y`: Let `build` (or your function) accept them\n   - `n`: Let `build` (or your function) accept no extra parameters\n\ninfo\n\nIf you're using codegen, the above thought process is enough.\n\nThere's no need to think about the right class names and their _specific_ APIs.\n\n`@riverpod` only asks you to write a class with its return type, and you're good to go.\n\nTechnically, the best fit here is to define a `AutoDisposeAsyncNotifier<List<Todo>>`,\nwhich meets all the above requirements. Let's write some pseudocode first.\n\n```codeBlockLines_e6Vv\n@riverpod\nclass MyNotifier extends _$MyNotifier {\n  @override\n  FutureOr<List<Todo>> build() {\n    // TODO ...\n    return [];\n  }\n\n  Future<void> addTodo(Todo todo) async {\n    // TODO\n  }\n}\n\n```\n\ntip\n\nRemember: use snippets in your IDE to get some guidance, or just to speed up your code writing.\nSee [Getting started](/docs/introduction/getting_started#going-further-installing-code-snippets).\n\nWith respect with `ChangeNotifier`'s implementation, we don't need to declare `todos` anymore;\nsuch variable is `state`, which is implicitly loaded with `build`.\n\nIndeed, riverpod's notifiers can expose _one_ entity at a time.\n\ntip\n\nRiverpod's API is meant to be granular; nonetheless, when migrating, you can still define a custom\nentity to hold multiple values. Consider using [Dart 3's records](https://dart.dev/language/records)\nto smooth out the migration at first.\n\n### Initialization [​](\\#initialization \"Direct link to Initialization\")\n\nInitalizing a notifier is easy: just write initialization logic inside `build`.\n\nWe can now get rid of the old `_init` function.\n\n```codeBlockLines_e6Vv\n@riverpod\nclass MyNotifier extends _$MyNotifier {\n  @override\n  FutureOr<List<Todo>> build() async {\n    final json = await http.get('api/todos');\n    return [...json.map(Todo.fromJson)];\n  }\n}\n\n```\n\nWith respect of the old `_init`, the new `build` isn't missing anything: there is no need to\ninitialize variables such as `isLoading` or `hasError` anymore.\n\nRiverpod will automatically translate any asynchronous provider, via exposing an `AsyncValue<List<Todo>>`\nand handles the intricacies of asynchronous state way better than what two simple boolean flags can do.\n\nIndeed, any `AsyncNotifier` effectively makes writing additional `try`/ `catch`/ `finally` an anti-pattern\nfor handling asynchronous state.\n\n### Mutations and Side Effects [​](\\#mutations-and-side-effects \"Direct link to Mutations and Side Effects\")\n\nJust like initialization, when performing side effects there's no need to manipulate boolean flags\nsuch as `hasError`, or to write additional `try`/ `catch`/ `finally` blocks.\n\nBelow, we've cut down all the boilerplate and successfully fully migrated the above example:\n\n```codeBlockLines_e6Vv\n@riverpod\nclass MyNotifier extends _$MyNotifier {\n  @override\n  FutureOr<List<Todo>> build() async {\n    final json = await http.get('api/todos');\n\n    return [...json.map(Todo.fromJson)];\n  }\n\n  Future<void> addTodo(Todo todo) async {\n    // optional: state = const AsyncLoading();\n    final json = await http.post('api/todos');\n    final newTodos = [...json.map(Todo.fromJson)];\n    state = AsyncData(newTodos);\n  }\n}\n\n```\n\ntip\n\nSyntax and design choices may vary, but in the end we just need to write our request and update\nstate afterwards. See [Performing side effects](/docs/essentials/side_effects).\n\n## Migration Process Summary [​](\\#migration-process-summary \"Direct link to Migration Process Summary\")\n\nLet's review the whole migration process applied above, from a operational point of view.\n\n1. We've moved the initialization, away from a custom method invoked in a constructor, to `build`\n2. We've removed `todos`, `isLoading` and `hasError` properties: internal `state` will suffice\n3. We've removed any `try`- `catch`- `finally` blocks: returning the future is enough\n4. We've applied the same simplification on the side effects ( `addTodo`)\n5. We've applied the mutations, via simply reassign `state`\n\n- [Start your migration](#start-your-migration)\n  - [Initialization](#initialization)\n  - [Mutations and Side Effects](#mutations-and-side-effects)\n- [Migration Process Summary](#migration-process-summary)",
    "metadata": {
      "url": "https://riverpod.dev/docs/migration/from_change_notifier",
      "ogUrl": "https://riverpod.dev/docs/migration/from_change_notifier",
      "title": "From `ChangeNotifier` | Riverpod",
      "og:url": "https://riverpod.dev/docs/migration/from_change_notifier",
      "ogImage": "https://riverpod.dev/img/cover.png",
      "ogTitle": "From `ChangeNotifier` | Riverpod",
      "language": "en",
      "og:image": "https://riverpod.dev/img/cover.png",
      "og:title": "From `ChangeNotifier` | Riverpod",
      "viewport": "width=device-width, initial-scale=1.0",
      "generator": "Docusaurus v2.4.3",
      "sourceURL": "https://riverpod.dev/docs/migration/from_change_notifier",
      "statusCode": 200,
      "description": "Within Riverpod, ChangeNotifierProvider is meant to be used to offer a smooth transition from",
      "twitter:card": "summary_large_image",
      "ogDescription": "Within Riverpod, ChangeNotifierProvider is meant to be used to offer a smooth transition from",
      "twitter:image": "https://riverpod.dev/img/cover.png",
      "docusaurus_tag": "docs-default-current",
      "og:description": "Within Riverpod, ChangeNotifierProvider is meant to be used to offer a smooth transition from",
      "docsearch:version": "current",
      "docusaurus_locale": "en",
      "ogLocaleAlternate": [],
      "docsearch:language": "en",
      "docusaurus_version": "current",
      "docsearch:docusaurus_tag": "docs-default-current"
    }
  },
  {
    "markdown": "[Skip to main content](#__docusaurus_skipToContent_fallback)\n\nOn this page\n\nSo far, we've only seen how to fetch data (aka perform a _GET_ HTTP request).\n\nBut what about side-effects, such as a _POST_ request?\n\nApplications often implement a CRUD (Create, Read, Update, Delete) API.\n\nWhen doing so, it is common that an update request (typically a _POST_) should\nalso update the local cache to have the UI reflect the new state.\n\nThe problem is, how do we update the state of a provider from within a consumer?\n\nNaturally, providers do not expose a way to modify their state.\nThis is by design, to ensure that the state is only modified in a controlled way\nand promote separation of concerns.\n\nInstead, providers have to explicitly expose a way to modify their state.\n\nTo do that, we will use a new concept: Notifiers.\n\nTo showcase this new concept, let's use a more advanced example: A to-do list.\n\n## Defining a Notifier [​](\\#defining-a-notifier \"Direct link to Defining a Notifier\")\n\nLet's start with what we already know by this point: A plain simple _GET_ request.\nAs we saw previously in [Make your first provider/network request](/docs/essentials/first_request), we could\nfetch a list of todos by writing:\n\n```codeBlockLines_e6Vv\n@riverpod\nFuture<List<Todo>> todoList(Ref ref) async {\n  // Simulate a network request. This would normally come from a real API\n  return [\\\n    Todo(description: 'Learn Flutter', completed: true),\\\n    Todo(description: 'Learn Riverpod'),\\\n  ];\n}\n\n```\n\nNow that we've fetched a list of todos, let's see how we can add a new todos.\n\nFor this, we will need to modify our provider such that they expose a public API\nfor modifying their state. This is done by converting our provider into what\nwe call a \"notifier\".\n\nNotifiers are the \"stateful widget\" of providers. They require a slight tweak to\nthe syntax for defining a provider.\n\nThis new syntax is as follows:\n\n```\n@riverpod\nclass MyNotifier extends _$MyNotifier {\n  @override\n  Result build() {\n    <your logic here>\n  }\n  <your methods here>\n}\n```\n\n|     |     |\n| --- | --- |\n| The annotation | All providers must be annotated with `@riverpod` or `@Riverpod()`.<br>This annotation can be placed on global functions or classes.<br>Through this annotation, it is possible to configure the provider.<br>For example, we can disable \"auto-dispose\" (which we will see later) by writing `@Riverpod(keepAlive: true)`. |\n| The Notifier | When a `@riverpod` annotation is placed on a class, that class is called<br>a \"Notifier\".<br>The class must extend `_$NotifierName`, where `NotifierName` is the class name.<br>Notifiers are responsible for exposing ways to modify the state of the provider.<br>Public methods on this class are accessible to consumers using `ref.read(yourProvider.notifier).yourMethod()`.<br>note<br>Notifiers should not have public properties besides the built-in `state`, as the UI<br>would have no mean to know that state has changed. |\n| The build method | All notifiers must override the `build` method.<br>This method is equivalent to the place where you would normally put your<br>logic in a non-notifier provider.<br>This method should not be called directly. |\n\nFor reference, you might want to check [Make your first provider/network request](/docs/essentials/first_request)\nto compare this new syntax with the previously seen syntax.\n\ninfo\n\nA Notifier with no method outside of `build` is identical to using the\npreviously seen syntax.\n\nThe syntax shown in [Make your first provider/network request](/docs/essentials/first_request) can be considered\nas a shorthand for notifiers with no way to be modified from the UI.\n\nNow that we've seen the syntax, let's see how to convert our previously\ndefined provider to a notifier:\n\n```codeBlockLines_e6Vv\n@riverpod\nclass TodoList extends _$TodoList {\n  @override\n  Future<List<Todo>> build() async {\n    // The logic we previously had in our FutureProvider is now in the build method.\n    return [\\\n      Todo(description: 'Learn Flutter', completed: true),\\\n      Todo(description: 'Learn Riverpod'),\\\n    ];\n  }\n}\n\n```\n\nNote that the way of reading the provider inside widgets is unchanged.\n\nYou can still use `ref.watch(todoListProvider)` as with the previous syntax.\n\ncaution\n\nDo not put logic in the constructor of your notifier.\n\nNotifiers should not have a constructor, as `ref` and other properties aren't\nyet available at that point. Instead, put your logic in the `build` method.\n\n```codeBlockLines_e6Vv\nclass MyNotifier extends ... {\n  MyNotifier() {\n    // ❌ Don't do this\n    // This will throw an exception\n    state = AsyncValue.data(42);\n  }\n\n  @override\n  Result build() {\n    // ✅ Do this instead\n    state = AsyncValue.data(42);\n  }\n}\n\n```\n\n## Exposing a method to perform a _POST_ request [​](\\#exposing-a-method-to-perform-a-post-request \"Direct link to exposing-a-method-to-perform-a-post-request\")\n\nNow that we have a Notifier, we can start adding methods to enable\nperforming side-effects.\nOne such side-effect would be to have the client _POST_ a new todo.\nWe could do so by adding an `addTodo` method on our notifier:\n\n```codeBlockLines_e6Vv\n@riverpod\nclass TodoList extends _$TodoList {\n  @override\n  Future<List<Todo>> build() async => [/* ... */];\n\n  Future<void> addTodo(Todo todo) async {\n    await http.post(\n      Uri.https('your_api.com', '/todos'),\n      // We serialize our Todo object and POST it to the server.\n      headers: {'Content-Type': 'application/json'},\n      body: jsonEncode(todo.toJson()),\n    );\n  }\n}\n\n```\n\nThen, we can invoke this method in our UI using the same `Consumer`/ `ConsumerWidget`\nwe saw in [Make your first provider/network request](/docs/essentials/first_request):\n\n```codeBlockLines_e6Vv\nclass Example extends ConsumerWidget {\n  const Example({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    return ElevatedButton(\n      onPressed: () {\n        // Using \"ref.read\" combined with \"myProvider.notifier\", we can\n        // obtain the class instance of our notifier. This enables us\n        // to call the \"addTodo\" method.\n        ref\n            .read(todoListProvider.notifier)\n            .addTodo(Todo(description: 'This is a new todo'));\n      },\n      child: const Text('Add todo'),\n    );\n  }\n}\n\n```\n\ninfo\n\nNotice how we are using `ref.read` instead of `ref.watch` to invoke our method.\n\nAlthough `ref.watch` could technically work, it is recommended to use `ref.read`\nwhen logic is performed in event handlers such as \"onPressed\".\n\nWe now have a button which makes a _POST_ request when pressed.\n\nHowever, at the moment, our UI does not update to reflect the new todo list.\nWe will want our local cache to match the server's state.\n\nThere are a few ways to do so with their pros and cons.\n\n### Updating our local cache to match the API response [​](\\#updating-our-local-cache-to-match-the-api-response \"Direct link to Updating our local cache to match the API response\")\n\nA common backend practice is to have the _POST_ request return the new\nstate of the resource.\n\nIn particular, our API would return the new list of todos after adding\na new todo. One way of doing this is by writing `state = AsyncData(response)`:\n\n```codeBlockLines_e6Vv\n  Future<void> addTodo(Todo todo) async {\n    // The POST request will return a List<Todo> matching the new application state\n    final response = await http.post(\n      Uri.https('your_api.com', '/todos'),\n      headers: {'Content-Type': 'application/json'},\n      body: jsonEncode(todo.toJson()),\n    );\n\n    // We decode the API response and convert it to a List<Todo>\n    List<Todo> newTodos = (jsonDecode(response.body) as List)\n        .cast<Map<String, Object?>>()\n        .map(Todo.fromJson)\n        .toList();\n\n    // We update the local cache to match the new state.\n    // This will notify all listeners.\n    state = AsyncData(newTodos);\n  }\n\n```\n\npros\n\n- The UI will have the most up-to-date state possible.\nIf another user added a todo, we will see it too.\n- The server is the source of truth.\nWith this approach, the client doesn't need to know where the new todo\nneeds to be inserted in the list of todos.\n- Only a single network-request is needed.\n\ncons\n\n- This approach will only work if the server is implemented in a specific way.\nIf the server does not return the new state, this approach will not work.\n- May still not be doable if the associated _GET_ request is more complex,\nsuch as if it has filters/sorting.\n\n### Using `ref.invalidateSelf()` to refresh the provider. [​](\\#using-refinvalidateself-to-refresh-the-provider \"Direct link to using-refinvalidateself-to-refresh-the-provider\")\n\nOne option is to have our provider re-execute the _GET_ request.\n\nThis can be done by calling `ref.invalidateSelf()` after the _POST_ request:\n\n```codeBlockLines_e6Vv\n  Future<void> addTodo(Todo todo) async {\n    // We don't care about the API response\n    await http.post(\n      Uri.https('your_api.com', '/todos'),\n      headers: {'Content-Type': 'application/json'},\n      body: jsonEncode(todo.toJson()),\n    );\n\n    // Once the post request is done, we can mark the local cache as dirty.\n    // This will cause \"build\" on our notifier to asynchronously be called again,\n    // and will notify listeners when doing so.\n    ref.invalidateSelf();\n\n    // (Optional) We can then wait for the new state to be computed.\n    // This ensures \"addTodo\" does not complete until the new state is available.\n    await future;\n  }\n\n```\n\npros\n\n- The UI will have the most up-to-date state possible.\nIf another user added a todo, we will see it too.\n- The server is the source of truth.\nWith this approach, the client doesn't need to know where the new todo\nneeds to be inserted in the list of todos.\n- This approach should work regardless of the server implementation.\nIt can be especially useful if your _GET_ request is more complex,\nsuch as if it has filters/sorting.\n\ncons\n\n- This approach will perform an extra _GET_ request, which may be\ninefficient.\n\n### Updating the local cache manually [​](\\#updating-the-local-cache-manually \"Direct link to Updating the local cache manually\")\n\nAnother option is to update the local cache manually.\n\nThis would involve trying to mimick the backend's behavior.\nFor instance, we would need to know whether the backend inserts new items\nat the start or at the end.\n\n```codeBlockLines_e6Vv\n  Future<void> addTodo(Todo todo) async {\n    // We don't care about the API response\n    await http.post(\n      Uri.https('your_api.com', '/todos'),\n      headers: {'Content-Type': 'application/json'},\n      body: jsonEncode(todo.toJson()),\n    );\n\n    // We can then manually update the local cache. For this, we'll need to\n    // obtain the previous state.\n    // Caution: The previous state may still be loading or in error state.\n    // A graceful way of handling this would be to read `this.future` instead\n    // of `this.state`, which would enable awaiting the loading state, and\n    // throw an error if the state is in error state.\n    final previousState = await future;\n\n    // We can then update the state, by creating a new state object.\n    // This will notify all listeners.\n    state = AsyncData([...previousState, todo]);\n  }\n\n```\n\ninfo\n\nThis example uses immutable state. This is not required, but recommended.\nSee [Why Immutability](/docs/concepts/why_immutability) for more details.\n\nIf you want to use mutable state instead, you can alternatively do:\n\n```codeBlockLines_e6Vv\n    final previousState = await future;\n    // Mutable the previous list of todos.\n    previousState.add(todo);\n    // Manually notify listeners.\n    ref.notifyListeners();\n\n```\n\npros\n\n- This approach should work regardless of the server implementation.\n- Only a single network-request is needed.\n\ncons\n\n- The local cache may not match the server's state.\nIf another user added a todo, we will not see it.\n- This approach may be more complex to implement and effectively\nduplicate the backend's logic.\n\n## Going further: Showing a spinner & error handling [​](\\#going-further-showing-a-spinner--error-handling \"Direct link to Going further: Showing a spinner & error handling\")\n\nWith all we've seen so far, we have a button which makes a _POST_ request\nwhen pressed; and when the request is done, the UI updates to reflect\nchanges.\n\nBut at the moment, there is no indication that the request is being\nperformed, nor any information if failed.\n\nOne way to do so is to store the Future returned by `addTodo`\nin the local widget state, and then listen to that future to show\na spinner or error message.\n\nThis is one scenario where [flutter\\_hooks](https://pub.dev/packages/flutter_hooks)\ncomes in handy. But of course, you can also use a `StatefulWidget` instead.\n\nThe following snippet shows a progress indicator while\nand operation is pending. And if it failed, renders the button as red:\n\n![A button which turns red when the operation failed](/assets/images/spinner-6014ac9b22357d59449e6842088656f3.gif)\n\n```codeBlockLines_e6Vv\nclass Example extends ConsumerStatefulWidget {\n  const Example({super.key});\n\n  @override\n  ConsumerState<ConsumerStatefulWidget> createState() => _ExampleState();\n}\n\nclass _ExampleState extends ConsumerState<Example> {\n  // The pending addTodo operation. Or null if none is pending.\n  Future<void>? _pendingAddTodo;\n\n  @override\n  Widget build(BuildContext context) {\n    return FutureBuilder(\n      // We listen to the pending operation, to update the UI accordingly.\n      future: _pendingAddTodo,\n      builder: (context, snapshot) {\n        // Compute whether there is an error state or not.\n        // The connectionState check is here to handle when the operation is retried.\n        final isErrored = snapshot.hasError && snapshot.connectionState != ConnectionState.waiting;\n\n        return Row(\n          children: [\\\n            ElevatedButton(\\\n              style: ButtonStyle(\\\n                // If there is an error, we show the button in red\\\n                backgroundColor: WidgetStatePropertyAll(\\\n                  isErrored ? Colors.red : null,\\\n                ),\\\n              ),\\\n              onPressed: () {\\\n                // We keep the future returned by addTodo in a variable\\\n                final future = ref\\\n                    .read(todoListProvider.notifier)\\\n                    .addTodo(Todo(description: 'This is a new todo'));\\\n\\\n                // We store that future in the local state\\\n                setState(() {\\\n                  _pendingAddTodo = future;\\\n                });\\\n              },\\\n              child: const Text('Add todo'),\\\n            ),\\\n            // The operation is pending, let's show a progress indicator\\\n            if (snapshot.connectionState == ConnectionState.waiting) ...[\\\n              const SizedBox(width: 8),\\\n              const CircularProgressIndicator(),\\\n            ]\\\n          ],\n        );\n      },\n    );\n  }\n}\n\n```\n\n- [Defining a Notifier](#defining-a-notifier)\n- [Exposing a method to perform a _POST_ request](#exposing-a-method-to-perform-a-post-request)\n  - [Updating our local cache to match the API response](#updating-our-local-cache-to-match-the-api-response)\n  - [Using `ref.invalidateSelf()` to refresh the provider.](#using-refinvalidateself-to-refresh-the-provider)\n  - [Updating the local cache manually](#updating-the-local-cache-manually)\n- [Going further: Showing a spinner & error handling](#going-further-showing-a-spinner--error-handling)",
    "metadata": {
      "url": "https://riverpod.dev/docs/essentials/side_effects",
      "ogUrl": "https://riverpod.dev/docs/essentials/side_effects",
      "title": "Performing side effects | Riverpod",
      "og:url": "https://riverpod.dev/docs/essentials/side_effects",
      "ogImage": "https://riverpod.dev/img/cover.png",
      "ogTitle": "Performing side effects | Riverpod",
      "language": "en",
      "og:image": "https://riverpod.dev/img/cover.png",
      "og:title": "Performing side effects | Riverpod",
      "viewport": "width=device-width, initial-scale=1.0",
      "generator": "Docusaurus v2.4.3",
      "sourceURL": "https://riverpod.dev/docs/essentials/side_effects",
      "statusCode": 200,
      "description": "So far, we've only seen how to fetch data (aka perform a GET HTTP request).",
      "twitter:card": "summary_large_image",
      "ogDescription": "So far, we've only seen how to fetch data (aka perform a GET HTTP request).",
      "twitter:image": "https://riverpod.dev/img/cover.png",
      "docusaurus_tag": "docs-default-current",
      "og:description": "So far, we've only seen how to fetch data (aka perform a GET HTTP request).",
      "docsearch:version": "current",
      "docusaurus_locale": "en",
      "ogLocaleAlternate": [],
      "docsearch:language": "en",
      "docusaurus_version": "current",
      "docsearch:docusaurus_tag": "docs-default-current"
    }
  },
  {
    "markdown": "[Skip to main content](#__docusaurus_skipToContent_fallback)\n\nOn this page\n\n## What is Riverpod? [​](\\#what-is-riverpod \"Direct link to What is Riverpod?\")\n\nRiverpod (anagram of [Provider](https://pub.dev/packages/provider)) is a reactive\ncaching framework for Flutter/Dart.\n\nUsing declarative and reactive programming, Riverpod takes care of\na large part of your application's logic for you. It can perform network-requests\nwith built-in error handling and caching, while automatically re-fetching\ndata when necessary.\n\n## Motivation [​](\\#motivation \"Direct link to Motivation\")\n\nModern applications rarely come with all the information necessary to render\ntheir User Interface. Instead, the data is often fetched asynchronously\nfrom a server.\n\nThe problem is, working with asynchronous code is hard. Although Flutter comes\nwith some way to create state variables and refresh the UI on change, it is still\nfairly limited. A number of challenges remain unsolved:\n\n- Asynchronous requests need to be cached locally, as it would be unreasonable\nto re-execute them whenever the UI updates.\n- Since we have a cache, our cache could get out of date if we're not careful.\n- We also need to handle errors and loading states\n\nNailing those problems at scale can be difficult, and they are impacted by a large\namount of features, such as:\n\n- Pull to refresh\n- Infinite lists / fetch as we scroll\n- Search as we type\n- Debouncing asynchronous requests\n- Cancelling asynchronous requests when no-longer used\n- Optimistic UIs\n- Offline mode\n- etc.\n\nThese features can be tricky to implement, but are crucial for a good user experience.\n\nYet few packages try to tackle those problems directly, and a lot of the work\nhas to be done manually.\n\nThat's where Riverpod comes in.\n\nRiverpod tries to solve those problems, by offering a new unique\nway of writing business logic, inspired by Flutter widgets. In\nmany ways Riverpod is comparable to widgets, but for state.\n\nUsing this new approach, these complex features are mostly done by default. All\nthat's left is to focus on your UI.\n\nSkeptical? Here's an example. The following snippet is a simplification of the [Pub.dev](https://github.com/rrousselGit/riverpod/tree/master/examples/pub)\nclient application implemented using Riverpod.\n\n```codeBlockLines_e6Vv\n\n// Fetches the list of packages from pub.dev\n@riverpod\nFuture<List<Package>> fetchPackages(\n  Ref ref, {\n  required int page,\n  String search = '',\n}) async {\n  final dio = Dio();\n  // Fetch an API. Here we're using package:dio, but we could use anything else.\n  final response = await dio.get<List<Object?>>(\n    'https://pub.dartlang.org/api/search?page=$page&q=${Uri.encodeQueryComponent(search)}',\n  );\n\n  // Decode the JSON response into a Dart class.\n  return response.data?.map(Package.fromJson).toList() ?? const [];\n}\n\n```\n\nThis snippet is all the business logic you need for a \"search as we type\" +\n\"pull to refresh\" + \"infinite list\", while handling error/loading states.\n\n- [What is Riverpod?](#what-is-riverpod)\n- [Motivation](#motivation)",
    "metadata": {
      "url": "https://riverpod.dev/docs/introduction/why_riverpod",
      "ogUrl": "https://riverpod.dev/docs/introduction/why_riverpod",
      "title": "Why Riverpod? | Riverpod",
      "og:url": "https://riverpod.dev/docs/introduction/why_riverpod",
      "ogImage": "https://riverpod.dev/img/cover.png",
      "ogTitle": "Why Riverpod? | Riverpod",
      "language": "en",
      "og:image": "https://riverpod.dev/img/cover.png",
      "og:title": "Why Riverpod? | Riverpod",
      "viewport": "width=device-width, initial-scale=1.0",
      "generator": "Docusaurus v2.4.3",
      "sourceURL": "https://riverpod.dev/docs/introduction/why_riverpod",
      "statusCode": 200,
      "description": "What is Riverpod?",
      "twitter:card": "summary_large_image",
      "ogDescription": "What is Riverpod?",
      "twitter:image": "https://riverpod.dev/img/cover.png",
      "docusaurus_tag": "docs-default-current",
      "og:description": "What is Riverpod?",
      "docsearch:version": "current",
      "docusaurus_locale": "en",
      "ogLocaleAlternate": [],
      "docsearch:language": "en",
      "docusaurus_version": "current",
      "docsearch:docusaurus_tag": "docs-default-current"
    }
  },
  {
    "markdown": "[Skip to main content](#__docusaurus_skipToContent_fallback)\n\nOn this page\n\ncaution\n\nThe content of this page may be outdated.\n\nIt will be updated in the future, but for now you may want to refer to the content\nin the top of the sidebar instead (introduction/essentials/case-studies/...)\n\n## When does my Provider get created and disposed? [​](\\#when-does-my-provider-get-created-and-disposed \"Direct link to When does my Provider get created and disposed?\")\n\nThe states that all different types of providers can go through are the same:\n\n- Uninitialized\n- Alive\n- Paused\n- Disposed\n\n### Disposed / Uninitialized [​](\\#disposed--uninitialized \"Direct link to Disposed / Uninitialized\")\n\nAn **Uninitialized** or **Disposed** provider does not take up any memory since its state is not initialized.\nEssentially it is just a definition of how to create the provider's state when you need it.\nIt will stay that way until an **Alive** provider or a [WidgetRef](https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/WidgetRef-class.html) from the UI reads, watches, or listens to it.\n\n### Creating -> Alive [​](\\#creating---alive \"Direct link to Creating -> Alive\")\n\nWhen an **Uninitialized** provider is read, listened to or watched its state will be created.\n\nDuring creation your provider's build function will be run.\nAny providers that you read or watch using the `ref` exposed by the callback will be created as needed and their state will be retrieved.\n\nIf there are any circular dependencies during this creation process Riverpod will throw an error.\nThe best way to fix this error is to redesign your dependencies to have a uni-directional dataflow.\n\nThe provider's state is stored in a [ProviderContainer](https://pub.dev/documentation/riverpod/latest/riverpod/ProviderContainer-class.html). In a Flutter app this container is in a [ProviderScope](https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/ProviderScope-class.html) widget.\n\nAs such, even though the definition of how to create the state (the provider) is global, the state is actually local,\nand can be different in different portions of your UI using nested [ProviderScope](https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/ProviderScope-class.html) widgets and overrides.\n\nThis is very similar to how flutter widgets work. You only pay for the definition once, but can reuse the state in different parts of the tree as needed.\n\n### Alive [​](\\#alive \"Direct link to Alive\")\n\nWhen your provider is **Alive**, changes to its state will cause dependent providers and/or the dependent UI to rebuild.\n\nFrom the other perspective, as a reactive framework, you can watch other providers to have the provider recreate itself whenever one of its dependencies changes.\n\nIf you need to have some long-lived state that depends on other state you can use Ref's [listen](https://pub.dev/documentation/riverpod/latest/riverpod/Ref/listen.html) method to subscribe for changes on another provider without causing a rebuild of the provider.\n\nIf you need to use the state from another provider in a side-effect, you can use Ref's \\[read\\] method to obtain the current state from another provider.\n\nTypically when constructing a [StateNotifier](https://pub.dev/documentation/state_notifier/latest/state_notifier/StateNotifier-class.html) or [ChangeNotifier](https://api.flutter.dev/flutter/foundation/ChangeNotifier-class.html) class you should pass in the `ref` to allow the Notifier to obtain the current value of dependencies as needed. By using the new [Notifier](https://pub.dev/documentation/riverpod/latest/riverpod/Notifier-class.html) and [AsyncNotifier](https://pub.dev/documentation/riverpod/latest/riverpod/AsyncNotifier-class.html) classes from Riverpod 2.0, the ref is already available as an instance member of the class.\n\n### Alive -> Paused [​](\\#alive---paused \"Direct link to Alive -> Paused\")\n\nWhen an **Alive** provider is no longer listened to by other providers or the UI, it goes into a **Paused** state.\nThis means that it no longer will react to changes on providers it is listening to.\nThis is an optimization, as if you are not listening to the provider, there is no need to keep it alive.\nEvery provider not being used will be returned to a **Paused** state, reducing the computational burden of your app.\n\nIf you need to keep a provider alive for side-effects, make sure to listen to it in an appropriate place in the UI where it should be kept alive.\n\nIf you need to perform some action when a provider is paused use the ref's [onCancel](https://pub.dev/documentation/riverpod/latest/riverpod/Ref/onCancel.html) method to register callbacks.\n\nIf you need to perform some action when a provider resumes to an Alive state from a paused state, use the ref's [onResume](https://pub.dev/documentation/riverpod/latest/riverpod/Ref/onResume.html) method to register callbacks.\n\nIf you want the state to be disposed, so that in addition to taking no computational resources, it also disposes of the memory of the state, use the `.autoDispose` modifier on your provider definition.\nThis will cause it to transition to a **Disposed** state instead of **Paused** when it is no longer being used.\n\n### Alive -> Disposing [​](\\#alive---disposing \"Direct link to Alive -> Disposing\")\n\nThere are a few reasons for a provider to be disposed.\n\n- When defined using the `.autoDispose` modifier and no longer being watched by the UI or another provider\n- When the provider is being manually refreshed or invalidated\n- When the provider is being recreated due to one of its watched dependencies changing\n\nRefreshing causes the provider to immediately go through the creation process again, whereas invalidating causes the next read / watch of the provider to cause the provider to be rebuilt.\n\n## Performing actions before the state destruction [​](\\#performing-actions-before-the-state-destruction \"Direct link to Performing actions before the state destruction\")\n\nIf you need to perform some action when a provider is disposed, use the ref's [onDispose](https://pub.dev/documentation/riverpod/latest/riverpod/Ref/onDispose.html) method to register callbacks.\n\nThe following example uses onDispose to close a StreamController:\n\n```codeBlockLines_e6Vv\n@riverpod\nStream<int> example(Ref ref) {\n  final streamController = StreamController<int>();\n\n  ref.onDispose(() {\n    // Closes the StreamController when the state of this provider is destroyed.\n    streamController.close();\n  });\n\n  return streamController.stream;\n}\n\n```\n\nnote\n\nDepending on the provider used, it may already take care of the clean-up process.\nFor example, [StateNotifierProvider](https://pub.dev/documentation/riverpod/latest/riverpod/StateNotifierProvider-class.html) will call the `dispose` method of the returned [StateNotifier](https://pub.dev/documentation/state_notifier/latest/state_notifier/StateNotifier-class.html).\n\n- [When does my Provider get created and disposed?](#when-does-my-provider-get-created-and-disposed)\n  - [Disposed / Uninitialized](#disposed--uninitialized)\n  - [Creating -> Alive](#creating---alive)\n  - [Alive](#alive)\n  - [Alive -> Paused](#alive---paused)\n  - [Alive -> Disposing](#alive---disposing)\n- [Performing actions before the state destruction](#performing-actions-before-the-state-destruction)",
    "metadata": {
      "url": "https://riverpod.dev/docs/concepts/provider_lifecycles",
      "ogUrl": "https://riverpod.dev/docs/concepts/provider_lifecycles",
      "title": "Provider Lifecycles | Riverpod",
      "og:url": "https://riverpod.dev/docs/concepts/provider_lifecycles",
      "ogImage": "https://riverpod.dev/img/cover.png",
      "ogTitle": "Provider Lifecycles | Riverpod",
      "language": "en",
      "og:image": "https://riverpod.dev/img/cover.png",
      "og:title": "Provider Lifecycles | Riverpod",
      "viewport": "width=device-width, initial-scale=1.0",
      "generator": "Docusaurus v2.4.3",
      "sourceURL": "https://riverpod.dev/docs/concepts/provider_lifecycles",
      "statusCode": 200,
      "description": "The content of this page may be outdated.",
      "twitter:card": "summary_large_image",
      "ogDescription": "The content of this page may be outdated.",
      "twitter:image": "https://riverpod.dev/img/cover.png",
      "docusaurus_tag": "docs-default-current",
      "og:description": "The content of this page may be outdated.",
      "docsearch:version": "current",
      "docusaurus_locale": "en",
      "ogLocaleAlternate": [],
      "docsearch:language": "en",
      "docusaurus_version": "current",
      "docsearch:docusaurus_tag": "docs-default-current"
    }
  },
  {
    "markdown": "[Skip to main content](#__docusaurus_skipToContent_fallback)\n\nOn this page\n\nSo far, we've seen how to create/update some state.\nBut we have yet to talk about when state destruction occurs.\n\nRiverpod offers various ways to interact with state disposal.\nThis ranges from delaying the disposal of state to reacting to destruction.\n\n## When is state destroyed and how to change this? [​](\\#when-is-state-destroyed-and-how-to-change-this \"Direct link to When is state destroyed and how to change this?\")\n\nWhen using code-generation, by default, the state is destroyed when\nthe provider stops being listened to.\n\nThis happens when a listener has no active listener for a full frame.\nWhen that happens, the state is destroyed.\n\nThis behavior can be opted out by using `keepAlive: true`.\n\nDoing so will prevent the state from getting destroyed when all listeners\nare removed.\n\n```codeBlockLines_e6Vv\n// We can specify \"keepAlive\" in the annotation to disable\n// the automatic state destruction\n@Riverpod(keepAlive: true)\nint example(Ref ref) {\n  return 0;\n}\n\n```\n\nnote\n\nEnabling/disabling automatic disposal has no impact on whether or not\nthe state is destroyed when the provider is recomputed.\n\nThe state will always be destroyed when the provider is recomputed.\n\ncaution\n\nWhen providers receive parameters, it is recommended to enable automatic disposal.\nThat is because otherwise, one state per parameter combination will be created,\nwhich can lead to memory leaks.\n\n## Reacting to state disposal [​](\\#reacting-to-state-disposal \"Direct link to Reacting to state disposal\")\n\nIn Riverpod, there are a few built-in ways for state to be destroyed:\n\n- The provider is no longer used and is in \"auto dispose\" mode (more on that later).\nIn this case, all associated state with the provider is destroyed.\n- The provider is recomputed, such as with `ref.watch`.\nIn that case, the previous state is disposed, and a new state is created.\n\nIn both cases. you may want to execute some logic when that happens.\n\nThis can be achieved with `ref.onDispose`. This methods enables\nregistering a listener to whenever the state is destroyed.\n\nFor example, you may want use it to close any active `StreamController`:\n\n```codeBlockLines_e6Vv\n@riverpod\nStream<int> example(Ref ref) {\n  final controller = StreamController<int>();\n\n  // When the state is destroyed, we close the StreamController.\n  ref.onDispose(controller.close);\n\n  // TO-DO: Push some values in the StreamController\n  return controller.stream;\n}\n\n```\n\ncaution\n\nThe callback of `ref.onDispose` must not trigger side-effects.\nModifying providers inside `onDispose` could lead to unexpected behavior.\n\ninfo\n\nThere are other useful life-cycles such as:\n\n- `ref.onCancel` which is called when the last listener of a provider is removed.\n- `ref.onResume` which is called when a new listener is added after `onCancel` was invoked.\n\ninfo\n\nYou can call `ref.onDispose` as many times as you wish.\nFeel free to call it once per disposable object in your provider. This practice\nmakes it easier to spot when we forget to dispose of something.\n\n## Manually forcing the destruction of a provider, using `ref.invalidate` [​](\\#manually-forcing-the-destruction-of-a-provider-using-refinvalidate \"Direct link to manually-forcing-the-destruction-of-a-provider-using-refinvalidate\")\n\nSometimes, you may want to force the destruction of a provider.\nThis can be done by using `ref.invalidate`, which can be called from another\nprovider or a widget.\n\nUsing `ref.invalidate` will destroy the current provider state.\nThere are then two possible outcomes:\n\n- If the provider is listened to, a new state will be created.\n- If the provider is not listened to, the provider will be fully destroyed.\n\n```codeBlockLines_e6Vv\nclass MyWidget extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    return ElevatedButton(\n      onPressed: () {\n        // On click, destroy the provider.\n        ref.invalidate(someProvider);\n      },\n      child: const Text('dispose a provider'),\n    );\n  }\n}\n\n```\n\ninfo\n\nIt is possible for providers to invalidate themselves by using `ref.invalidateSelf`.\nAlthough in this case, this will always result in a new state being created.\n\ntip\n\nWhen trying to invalidate a provider which receives parameters,\nit is posible to either invalidate one specific parameter combination,\nor all parameter combinations at once:\n\n```codeBlockLines_e6Vv\n@riverpod\nString label(Ref ref, String userName) {\n  return 'Hello $userName';\n}\n\n// ...\n\nvoid onTap() {\n  // Invalidate all possible parameter combinations of this provider.\n  ref.invalidate(labelProvider);\n  // Invalidate a specific combination only\n  ref.invalidate(labelProvider('John'));\n}\n\n```\n\n## Fine-tuned disposal with `ref.keepAlive` [​](\\#fine-tuned-disposal-with-refkeepalive \"Direct link to fine-tuned-disposal-with-refkeepalive\")\n\nAs mentioned above, when automatic disposal is enabled, the state is destroyed\nwhen the provider has no listeners for a full frame.\n\nBut you may want to have more control over this behavior. For instance,\nyou may want to keep the state of successful network requests,\nbut not cache failed requests.\n\nThis can be achieved with `ref.keepAlive`, after enabling automatic disposal.\nUsing it, you can decide _when_ the state stops being automatically disposed.\n\n```codeBlockLines_e6Vv\n@riverpod\nFuture<String> example(Ref ref) async {\n  final response = await http.get(Uri.parse('https://example.com'));\n  // We keep the provider alive only after the request has successfully completed.\n  // If the request failed (and threw an exception), then when the provider stops being\n  // listened to, the state will be destroyed.\n  ref.keepAlive();\n\n  // We can use the `link` to restore the auto-dispose behavior with:\n  // link.close();\n\n  return response.body;\n}\n\n```\n\nnote\n\nIf the provider is recomputed, automatic disposal will be re-enabled.\n\nIt is also possible to use the return value of `ref.keepAlive` to\nrevert to automatic disposal.\n\n## Example: keeping state alive for a specific amount of time [​](\\#example-keeping-state-alive-for-a-specific-amount-of-time \"Direct link to Example: keeping state alive for a specific amount of time\")\n\nCurrently, Riverpod does not offer a built-in way to keep state alive\nfor a specific amount of time.\n\nBut implementing such a feature is easy and reusable with the tools we've seen so far.\n\nBy using a `Timer` \\+ `ref.keepAlive`, we can keep the state alive for a specific amount of time.\nTo make this logic reusable, we could implement it in an extension method:\n\n```codeBlockLines_e6Vv\nextension CacheForExtension on Ref {\n  /// Keeps the provider alive for [duration].\n  void cacheFor(Duration duration) {\n    // Immediately prevent the state from getting destroyed.\n    final link = keepAlive();\n    // After duration has elapsed, we re-enable automatic disposal.\n    final timer = Timer(duration, link.close);\n\n    // Optional: when the provider is recomputed (such as with ref.watch),\n    // we cancel the pending timer.\n    onDispose(timer.cancel);\n  }\n}\n\n```\n\nThen, we can use it like so:\n\n```codeBlockLines_e6Vv\n@riverpod\nFuture<Object> example(Ref ref) async {\n  /// Keeps the state alive for 5 minutes\n  ref.cacheFor(const Duration(minutes: 5));\n\n  return http.get(Uri.https('example.com'));\n}\n\n```\n\nThis logic can be tweaked to fit your needs.\nFor example, you could use `ref.onCancel`/ `ref.onResume` to destroy the state\nonly if a provider hasn't been listened to for a specific amount of time.\n\n- [When is state destroyed and how to change this?](#when-is-state-destroyed-and-how-to-change-this)\n- [Reacting to state disposal](#reacting-to-state-disposal)\n- [Manually forcing the destruction of a provider, using `ref.invalidate`](#manually-forcing-the-destruction-of-a-provider-using-refinvalidate)\n- [Fine-tuned disposal with `ref.keepAlive`](#fine-tuned-disposal-with-refkeepalive)\n- [Example: keeping state alive for a specific amount of time](#example-keeping-state-alive-for-a-specific-amount-of-time)",
    "metadata": {
      "url": "https://riverpod.dev/docs/essentials/auto_dispose",
      "ogUrl": "https://riverpod.dev/docs/essentials/auto_dispose",
      "title": "Clearing cache and reacting to state disposal | Riverpod",
      "og:url": "https://riverpod.dev/docs/essentials/auto_dispose",
      "ogImage": "https://riverpod.dev/img/cover.png",
      "ogTitle": "Clearing cache and reacting to state disposal | Riverpod",
      "language": "en",
      "og:image": "https://riverpod.dev/img/cover.png",
      "og:title": "Clearing cache and reacting to state disposal | Riverpod",
      "viewport": "width=device-width, initial-scale=1.0",
      "generator": "Docusaurus v2.4.3",
      "sourceURL": "https://riverpod.dev/docs/essentials/auto_dispose",
      "statusCode": 200,
      "description": "So far, we've seen how to create/update some state.",
      "twitter:card": "summary_large_image",
      "ogDescription": "So far, we've seen how to create/update some state.",
      "twitter:image": "https://riverpod.dev/img/cover.png",
      "docusaurus_tag": "docs-default-current",
      "og:description": "So far, we've seen how to create/update some state.",
      "docsearch:version": "current",
      "docusaurus_locale": "en",
      "ogLocaleAlternate": [],
      "docsearch:language": "en",
      "docusaurus_version": "current",
      "docsearch:docusaurus_tag": "docs-default-current"
    }
  },
  {
    "markdown": "[Skip to main content](#__docusaurus_skipToContent_fallback)\n\nOn this page\n\ncaution\n\nThe content of this page may be outdated.\n\nIt will be updated in the future, but for now you may want to refer to the content\nin the top of the sidebar instead (introduction/essentials/case-studies/...)\n\nA real world example could be to use `FutureProvider` to implement a searchbar.\n\n## Usage example: \"Search as we type\" searchbar [​](\\#usage-example-search-as-we-type-searchbar \"Direct link to Usage example: \\\"Search as we type\\\" searchbar\")\n\nImplementing a \"search as we type\" can seem daunting at first when using\nconventional means.\n\nThere are lots of moving parts, such as:\n\n- handling errors.\n- debouncing the user input to avoid making network requests on every keystroke.\n- cancelling previously pending network requests when the search field changes.\n\nBut the combination of `FutureProvider` and the power of \\[ref.watch\\] can\nsignificantly simplify this task.\n\nA common pattern wanting to perform an asynchronous requests\nis to split it into multiple providers:\n\n- a \\[StateNotifierProvider\\] or `StateProvider` for the parameters of your request\n(or alternatively use \\[family\\])\n- a `FutureProvider`, which will do the request by reading the parameters from\nthe other providers/\\[family\\].\n\nThe first step would be to store the user input somewhere. For this example,\nwe will use `StateProvider` (as the search state is only a single `String`):\n\n```codeBlockLines_e6Vv\nfinal searchInputProvider = StateProvider<String>((ref) => '');\n\n```\n\nWe can then connect this provider to a \\[TextField\\] by doing:\n\n```codeBlockLines_e6Vv\nConsumer(\n  builder: (context, ref, child) {\n    return TextField(\n      onChanged: (value) => ref.read(searchInputProvider.notifier).state = value,\n    );\n  },\n)\n\n```\n\nThen, we can create our `FutureProvider` which will take care of the request:\n\n```codeBlockLines_e6Vv\nfinal searchProvider = FutureProvider<\n\n<!--\n// Copyright (c) 2019, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:http/http.dart' as http;\nimport 'dart:convert';\n\nfinal searchFieldProvider = StateProvider<String>((ref) => '');\nfinal questionsProvider = FutureProvider<List>((ref) async {\n  final client = http.Client();\n  ref.onDispose(client.close);\n\n  final search = ref.watch(searchFieldProvider);\n\n  Uri uri;\n\n  if (search.isEmpty) {\n    uri = Uri.parse(\n      'https://api.stackexchange.com/2.3/questions?order=desc&sort=activity&site=stackoverflow',\n    );\n  } else {\n    final encodedQuery = Uri.encodeComponent(search);\n    uri = Uri.parse(\n      'https://api.stackexchange.com/2.3/search?order=desc&sort=activity&intitle=$encodedQuery&site=stackoverflow',\n    );\n  }\n\n  final response = await client.get(uri);\n  final questions = jsonDecode(response.body);\n\n  return questions['items'].map((question) => question['title']).toList();\n});\n\nvoid main() => runApp(const ProviderScope(child: MyApp()));\n\nclass MyApp extends StatelessWidget {\n  const MyApp({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(home: MyHomePage());\n  }\n}\n\nclass MyHomePage extends ConsumerWidget {\n  const MyHomePage({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final questions = ref.watch(questionsProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Questions')),\n      body: Column(\n        children: [\\\n          TextField(\\\n            onChanged: (value) =>\\\n                ref.read(searchFieldProvider.notifier).state = value,\\\n          ),\\\n          Expanded(\\\n            child: switch (questions) {\\\n              AsyncData(:final value) => ListView.builder(\\\n                  itemCount: value.length,\\\n                  itemBuilder: (context, index) {\\\n                    final question = value[index];\\\n\\\n                    return ListTile(\\\n                      title: Text(\\\n                        question.toString(),\\\n                      ),\\\n                    );\\\n                  },\\\n                );,\\\n              AsyncError(:final error) => Center(child: Text('Error $error')),\\\n              _ => const Center(child: CircularProgressIndicator()),\\\n            },\\\n          ),\\\n        ],\n      ),\n    );\n  }\n}\n\n```\n\n- [Usage example: \"Search as we type\" searchbar](#usage-example-search-as-we-type-searchbar)",
    "metadata": {
      "url": "https://riverpod.dev/docs/cookbooks/search_as_we_type",
      "ogUrl": "https://riverpod.dev/docs/cookbooks/search_as_we_type",
      "title": "Search as we type | Riverpod",
      "og:url": "https://riverpod.dev/docs/cookbooks/search_as_we_type",
      "ogImage": "https://riverpod.dev/img/cover.png",
      "ogTitle": "Search as we type | Riverpod",
      "language": "en",
      "og:image": "https://riverpod.dev/img/cover.png",
      "og:title": "Search as we type | Riverpod",
      "viewport": "width=device-width, initial-scale=1.0",
      "generator": "Docusaurus v2.4.3",
      "sourceURL": "https://riverpod.dev/docs/cookbooks/search_as_we_type",
      "statusCode": 200,
      "description": "The content of this page may be outdated.",
      "twitter:card": "summary_large_image",
      "ogDescription": "The content of this page may be outdated.",
      "twitter:image": "https://riverpod.dev/img/cover.png",
      "docusaurus_tag": "docs-default-current",
      "og:description": "The content of this page may be outdated.",
      "docsearch:version": "current",
      "docusaurus_locale": "en",
      "ogLocaleAlternate": [],
      "docsearch:language": "en",
      "docusaurus_version": "current",
      "docsearch:docusaurus_tag": "docs-default-current"
    }
  },
  {
    "markdown": "[Skip to main content](#__docusaurus_skipToContent_fallback)\n\nOn this page\n\ncaution\n\nThe content of this page may be outdated.\n\nIt will be updated in the future, but for now you may want to refer to the content\nin the top of the sidebar instead (introduction/essentials/case-studies/...)\n\nMake sure to read [Providers](/docs/concepts/providers) first.\n\nIn this guide, we will learn about combining provider states.\n\n## Combining provider states [​](\\#combining-provider-states \"Direct link to Combining provider states\")\n\nWe've previously seen how to create a simple provider. But the reality is,\nin many situations a provider will want to read the state of another provider.\n\nTo do that, we can use the [ref](https://pub.dev/documentation/riverpod/latest/riverpod/Ref-class.html) object passed to the callback of our provider,\nand use its [watch](https://pub.dev/documentation/riverpod/latest/riverpod/Ref/watch.html) method.\n\nAs an example, consider the following provider:\n\n```codeBlockLines_e6Vv\n@riverpod\nString city(Ref ref) => 'London';\n\n```\n\nWe can now create another provider that will consume our `cityProvider`:\n\n```codeBlockLines_e6Vv\n@riverpod\nFuture<Weather> weather(Ref ref) {\n  // We use `ref.watch` to listen to another provider, and we pass it the provider\n  // that we want to consume. Here: cityProvider\n  final city = ref.watch(cityProvider);\n\n  // We can then use the result to do something based on the value of `cityProvider`.\n  return fetchWeather(city: city);\n}\n\n```\n\nThat's it. We've created a provider that depends on another provider.\n\n## FAQ [​](\\#faq \"Direct link to FAQ\")\n\n### What if the value being listened to changes over time? [​](\\#what-if-the-value-being-listened-to-changes-over-time \"Direct link to What if the value being listened to changes over time?\")\n\nDepending on the provider that you are listening to, the value obtained may\nchange over time.\nFor example, you may be listening to a [NotifierProvider](/docs/providers/notifier_provider), or the provider\nbeing listened to may have been forced to refresh through the use of\n[ProviderContainer.refresh](https://pub.dev/documentation/riverpod/latest/riverpod/ProviderContainer/refresh.html)/ [ref.refresh](https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/WidgetRef/refresh.html).\n\nWhen using [watch](https://pub.dev/documentation/riverpod/latest/riverpod/Ref/watch.html), Riverpod is able to detect that the value being listened to changed\nand will _automatically_ re-execute the provider's creation callback when needed.\n\nThis can be useful for computed states.\nFor example, consider a [(Async)NotifierProvider](/docs/providers/notifier_provider) that exposes a todo-list:\n\n```codeBlockLines_e6Vv\n\n@riverpod\nclass TodoList extends _$TodoList {\n  @override\n  List<Todo> build() {\n    return [];\n  }\n}\n\n```\n\nA common use-case would be to have the UI filter the list of todos to show\nonly the completed/uncompleted todos.\n\nAn easy way to implement such a scenario would be to:\n\n- create a [StateProvider](/docs/providers/state_provider), which exposes the currently selected filter method:\n\n\n\n\n\n```codeBlockLines_e6Vv\nenum Filter {\n    none,\n    completed,\n    uncompleted,\n}\n\nfinal filterProvider = StateProvider((ref) => Filter.none);\n\n```\n\n- make a separate provider which combines the filter method and the todo-list\nto expose the filtered todo-list:\n\n\n\n\n\n```codeBlockLines_e6Vv\n\n@riverpod\nList<Todo> filteredTodoList(Ref ref) {\n    final filter = ref.watch(filterProvider);\n    final todos = ref.watch(todoListProvider);\n\n    switch (filter) {\n      case Filter.none:\n        return todos;\n      case Filter.completed:\n        return todos.where((todo) => todo.completed).toList();\n      case Filter.uncompleted:\n        return todos.where((todo) => !todo.completed).toList();\n    }\n}\n\n```\n\n\nThen, our UI can listen to `filteredTodoListProvider` to listen to the filtered todo-list.\n\nUsing such an approach, the UI will automatically update when either the filter\nor the todo-list changes.\n\nTo see this approach in action, you can look at the source code of the [Todo List\\\\\nexample](https://github.com/rrousselGit/riverpod/tree/master/examples/todos).\n\ninfo\n\nThis behavior is not specific to [Provider](/docs/providers/provider), and works with all providers.\n\nFor example, you could combine [watch](https://pub.dev/documentation/riverpod/latest/riverpod/Ref/watch.html) with [FutureProvider](/docs/providers/future_provider) to implement a search\nfeature that supports live-configuration changes:\n\n```codeBlockLines_e6Vv\n\n// The current search filter\nfinal searchProvider = StateProvider((ref) => '');\n\n@riverpod\nStream<Configuration> configs(Ref ref) {\n  return Stream.value(Configuration());\n}\n\n@riverpod\nFuture<List<Character>> characters(Ref ref) async {\n  final search = ref.watch(searchProvider);\n  final configs = await ref.watch(configsProvider.future);\n  final response = await dio.get<List<Map<String, dynamic>>>(\n      '${configs.host}/characters?search=$search');\n\n  return response.data!.map(Character.fromJson).toList();\n}\n\n```\n\nThis code will fetch a list of characters from the service, and automatically\nre-fetch the list whenever the configurations change or when the search query changes.\n\n### Can I read a provider without listening to it? [​](\\#can-i-read-a-provider-without-listening-to-it \"Direct link to Can I read a provider without listening to it?\")\n\nSometimes, we want to read the content of a provider, but without re-creating\nthe value exposed when the value obtained changes.\n\nAn example would be a `Repository`, which reads from another provider the user token\nfor authentication.\n\nWe could use [watch](https://pub.dev/documentation/riverpod/latest/riverpod/Ref/watch.html) and create a new `Repository` whenever the user token changes,\nbut there is little to no use in doing that.\n\nIn this situation, we can use [read](https://pub.dev/documentation/riverpod/latest/riverpod/Ref/read.html), which is similar to [watch](https://pub.dev/documentation/riverpod/latest/riverpod/Ref/watch.html), but will not\ncause the provider to recreate the value it exposes when the value obtained changes.\n\nIn that case, a common practice is to pass the provider's `Ref` to the object created.\nThe object created will then be able to read providers whenever it wants.\n\n```codeBlockLines_e6Vv\nfinal userTokenProvider = StateProvider<String>((ref) => null);\n\nfinal repositoryProvider = Provider(Repository.new);\n\nclass Repository {\n  Repository(this.ref);\n\n  final Ref ref;\n\n  Future<Catalog> fetchCatalog() async {\n    String token = ref.read(userTokenProvider);\n\n    final response = await dio.get('/path', queryParameters: {\n      'token': token,\n    });\n\n    return Catalog.fromJson(response.data);\n  }\n}\n\n```\n\n**DON'T** call [read](https://pub.dev/documentation/riverpod/latest/riverpod/Ref/read.html) inside the body of a provider\n\n```codeBlockLines_e6Vv\n\n@riverpod\nMyValue my(Ref ref) {\n  // Bad practice to call `read` here\n  final value = ref.read(anotherProvider);\n  return value;\n}\n\n```\n\nIf you used [read](https://pub.dev/documentation/riverpod/latest/riverpod/Ref/read.html) as an attempt to avoid unwanted rebuilds of your object,\nrefer to [My provider updates too often, what can I do?](#my-provider-updates-too-often-what-can-i-do)\n\n### How to test an object that receives [ref](https://pub.dev/documentation/riverpod/latest/riverpod/Ref-class.html) as a parameter of its constructor? [​](\\#how-to-test-an-object-that-receives-ref-as-a-parameter-of-its-constructor \"Direct link to how-to-test-an-object-that-receives-ref-as-a-parameter-of-its-constructor\")\n\nIf you are using the pattern described in [Can I read a provider without listening to it?](#can-i-read-a-provider-without-listening-to-it),\nyou may be wondering how to write tests for your object.\n\nIn this scenario, consider testing the provider directly instead of the raw object.\nYou can do so by using the [ProviderContainer](https://pub.dev/documentation/riverpod/latest/riverpod/ProviderContainer-class.html) class:\n\n```codeBlockLines_e6Vv\nfinal repositoryProvider = Provider((ref) => Repository(ref));\n\ntest('fetches catalog', () async {\n  final container = ProviderContainer();\n  addTearDown(container.dispose);\n\n  Repository repository = container.read(repositoryProvider);\n\n  await expectLater(\n    repository.fetchCatalog(),\n    completion(Catalog()),\n  );\n});\n\n```\n\n### My provider updates too often, what can I do? [​](\\#my-provider-updates-too-often-what-can-i-do \"Direct link to My provider updates too often, what can I do?\")\n\nIf your object is re-created too often your provider is likely listening\nto objects that it doesn't care about.\n\nFor example, you may be listening to a `Configuration` object, but only use the `host`\nproperty.\n\nBy listening to the entire `Configuration` object, if a property other than `host`\nchanges, this still causes your provider to be re-evaluated – which may be\nundesired.\n\nThe solution to this problem is to create a separate provider that exposes _only_\nwhat you need in `Configuration` (so `host`):\n\n**AVOID** listening to the entire object:\n\n```codeBlockLines_e6Vv\n\n@riverpod\nStream<Configuration> config(Ref ref) => Stream.value(Configuration());\n\n@riverpod\nFuture<List<Product>> products(Ref ref) async {\n  // Will cause productsProvider to re-fetch the products if anything in the\n  // configurations changes\n  final configs = await ref.watch(configProvider.future);\n\n  final result =\n      await dio.get<List<Map<String, dynamic>>>('${configs.host}/products');\n  return result.data!.map(Product.fromJson).toList();\n}\n\n```\n\n**PREFER** using select when you only need a single property of an object:\n\n```codeBlockLines_e6Vv\n\n@riverpod\nStream<Configuration> config(Ref ref) => Stream.value(Configuration());\n\n@riverpod\nFuture<List<Product>> products(Ref ref) async {\n  // Listens only to the host. If something else in the configurations\n  // changes, this will not pointlessly re-evaluate our provider.\n  final host =\n      await ref.watch(configProvider.selectAsync((config) => config.host));\n\n  final result = await dio.get<List<Map<String, dynamic>>>('$host/products');\n\n  return result.data!.map(Product.fromJson).toList();\n}\n\n```\n\nThis will only rebuild the `productsProvider` when the `host` changes.\n\n- [Combining provider states](#combining-provider-states)\n- [FAQ](#faq)\n  - [What if the value being listened to changes over time?](#what-if-the-value-being-listened-to-changes-over-time)\n  - [Can I read a provider without listening to it?](#can-i-read-a-provider-without-listening-to-it)\n  - [How to test an object that receives ref as a parameter of its constructor?](#how-to-test-an-object-that-receives-ref-as-a-parameter-of-its-constructor)\n  - [My provider updates too often, what can I do?](#my-provider-updates-too-often-what-can-i-do)",
    "metadata": {
      "url": "https://riverpod.dev/docs/concepts/combining_providers",
      "ogUrl": "https://riverpod.dev/docs/concepts/combining_providers",
      "title": "Combining Provider States | Riverpod",
      "og:url": "https://riverpod.dev/docs/concepts/combining_providers",
      "ogImage": "https://riverpod.dev/img/cover.png",
      "ogTitle": "Combining Provider States | Riverpod",
      "language": "en",
      "og:image": "https://riverpod.dev/img/cover.png",
      "og:title": "Combining Provider States | Riverpod",
      "viewport": "width=device-width, initial-scale=1.0",
      "generator": "Docusaurus v2.4.3",
      "sourceURL": "https://riverpod.dev/docs/concepts/combining_providers",
      "statusCode": 200,
      "description": "The content of this page may be outdated.",
      "twitter:card": "summary_large_image",
      "ogDescription": "The content of this page may be outdated.",
      "twitter:image": "https://riverpod.dev/img/cover.png",
      "docusaurus_tag": "docs-default-current",
      "og:description": "The content of this page may be outdated.",
      "docsearch:version": "current",
      "docusaurus_locale": "en",
      "ogLocaleAlternate": [],
      "docsearch:language": "en",
      "docusaurus_version": "current",
      "docsearch:docusaurus_tag": "docs-default-current"
    }
  },
  {
    "markdown": "[Skip to main content](#__docusaurus_skipToContent_fallback)\n\nOn this page\n\nAs applications grow in complexity, it's common to have multiple network requests\nin flight at the same time. For example, a user might be typing in a search box\nand triggering a new request for each keystroke. If the user types quickly, the\napplication might have many requests in flight at the same time.\n\nAlternatively, a user might trigger a request, then navigate to a different page\nbefore the request completes. In this case, the application might have a request\nin flight that is no longer needed.\n\nTo optimize performance in those situations, there are a few techniques you can\nuse:\n\n- \"Debouncing\" requests. This means that you wait until the user has stopped\ntyping for a certain amount of time before sending the request. This ensures\nthat you only send one request for a given input, even if the user types\nquickly.\n- \"Cancelling\" requests. This means that you cancel a request if the user\nnavigates away from the page before the request completes. This ensures that\nyou don't waste time processing a response that the user will never see.\n\nIn Riverpod, both of these techniques can be implemented in a similar way.\nThe key is to use `ref.onDispose` combined with \"automatic disposal\" or `ref.watch`\nto achieve the desired behavior.\n\nTo showcase this, we will make a simple application with two pages:\n\n- A home screen, with a button which opens a new page\n- A detail page, which displays a random activity from the [Bored API](https://www.boredapi.com/),\nwith the ability to refresh the activity.\n\nSee [Pull to refresh](/docs/case_studies/pull_to_refresh) for information\non how to implement pull-to-refresh.\n\nWe will then implement the following behaviors:\n\n- If the user opens the detail page and then navigates back immediately,\nwe will cancel the request for the activity.\n- If the user refreshes the activity multiple times in a row, we will debounce\nthe requests so that we only send one request after the user stops refreshing.\n\n## The application [​](\\#the-application \"Direct link to The application\")\n\n![Gif showcasing the application, opening the detail page and refreshing the activity.](/img/case_studies/cancel/app.gif)\n\nFirst, let's create the application, without any debouncing or cancelling.\n\nWe won't use anything fancy here, and stick to a plain `FloatingActionButton` with\na `Navigator.push` to open the detail page.\n\nFirst, let's start with defining our home screen. As usual,\nlet's not forget to specify a `ProviderScope` at the root of our application.\n\nlib/src/main.dart\n\n```codeBlockLines_e6Vv\nvoid main() => runApp(const ProviderScope(child: MyApp()));\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      routes: {\n        '/detail-page': (_) => const DetailPageView(),\n      },\n      home: const ActivityView(),\n    );\n  }\n}\n\nclass ActivityView extends ConsumerWidget {\n  const ActivityView({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Home screen')),\n      body: const Center(\n        child: Text('Click the button to open the detail page'),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => Navigator.of(context).pushNamed('/detail-page'),\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}\n\n```\n\nThen, let's define our detail page.\nTo fetch the activity and implement pull-to-refresh, refer\nto the [Pull to refresh](/docs/case_studies/pull_to_refresh) case study.\n\nlib/src/detail\\_screen.dart\n\n```codeBlockLines_e6Vv\n@freezed\nclass Activity with _$Activity {\n  factory Activity({\n    required String activity,\n    required String type,\n    required int participants,\n    required double price,\n  }) = _Activity;\n\n  factory Activity.fromJson(Map<String, dynamic> json) =>\n      _$ActivityFromJson(json);\n}\n\n@riverpod\nFuture<Activity> activity(Ref ref) async {\n  final response = await http.get(\n    Uri.https('www.boredapi.com', '/api/activity'),\n  );\n\n  final json = jsonDecode(response.body) as Map;\n  return Activity.fromJson(Map.from(json));\n}\n\nclass DetailPageView extends ConsumerWidget {\n  const DetailPageView({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final activity = ref.watch(activityProvider);\n\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Detail page'),\n      ),\n      body: RefreshIndicator(\n        onRefresh: () => ref.refresh(activityProvider.future),\n        child: ListView(\n          children: [\\\n            switch (activity) {\\\n              AsyncValue(:final valueOrNull?) => Text(valueOrNull.activity),\\\n              AsyncValue(:final error?) => Text('Error: $error'),\\\n              _ => const Center(child: CircularProgressIndicator()),\\\n            },\\\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n```\n\n## Cancelling requests [​](\\#cancelling-requests \"Direct link to Cancelling requests\")\n\nNow that we have a working application, let's implement the cancellation logic.\n\nTo do so, we will use `ref.onDispose` to cancel the request when the user\nnavigates away from the page. For this to work, it is important that the\nautomatic disposal of providers is enabled.\n\nThe exact code needed to cancel the request will depend on the HTTP client.\nIn this example, we will use `package:http`, but the same principle applies\nto other clients.\n\nThe key here that `ref.onDispose` will be called when the user navigates away.\nThat is because our provider is no-longer used, and therefore disposed\nthanks to automatic disposal.\n\nWe can therefore use this callback to cancel the request. When using `package:http`,\nthis can be done by closing our HTTP client.\n\n```codeBlockLines_e6Vv\n@riverpod\nFuture<Activity> activity(Ref ref) async {\n  // We create an HTTP client using package:http\n  final client = http.Client();\n  // On dispose, we close the client.\n  // This will cancel any pending request that the client might have.\n  ref.onDispose(client.close);\n\n  // We now use the client to make the request instead of the \"get\" function.\n  final response = await client.get(\n    Uri.https('www.boredapi.com', '/api/activity'),\n  );\n\n  // The rest of the code is the same as before\n  final json = jsonDecode(response.body) as Map;\n  return Activity.fromJson(Map.from(json));\n}\n\n```\n\n## Debouncing requests [​](\\#debouncing-requests \"Direct link to Debouncing requests\")\n\nNow that we have implemented cancellation, let's implement debouncing.\n\nAt the moment, if the user refreshes the activity multiple times in a row,\nwe will send a request for each refresh.\n\nTechnically speaking, now that we have implemented cancellation, this is not\na problem. If the user refreshes the activity multiple times in a row,\nthe previous request will be cancelled, when a new request is made.\n\nHowever, this is not ideal. We are still sending multiple requests, and\nwasting bandwidth and server resources.\n\nWhat we could instead do is delay our requests until the user stops refreshing\nthe activity for a fixed amount of time.\n\nThe logic here is very similar to the cancellation logic. We will again\nuse `ref.onDispose`. However, the idea here is that instead of\nclosing an HTTP client, we will rely on `onDispose` to abort the request\nbefore it starts.\n\nWe will then arbitrarily wait for 500ms before sending the request.\nThen, if the user refreshes the activity again before the 500ms have elapsed,\n`onDispose` will be invoked, aborting the request.\n\ninfo\n\nTo abort requests, a common practice is to voluntarily throw.\n\nIt is safe to throw inside providers after the provider has been disposed.\nThe exception will naturally be caught by Riverpod and be ignored.\n\n```codeBlockLines_e6Vv\n@riverpod\nFuture<Activity> activity(Ref ref) async {\n  // We capture whether the provider is currently disposed or not.\n  var didDispose = false;\n  ref.onDispose(() => didDispose = true);\n\n  // We delay the request by 500ms, to wait for the user to stop refreshing.\n  await Future<void>.delayed(const Duration(milliseconds: 500));\n\n  // If the provider was disposed during the delay, it means that the user\n  // refreshed again. We throw an exception to cancel the request.\n  // It is safe to use an exception here, as it will be caught by Riverpod.\n  if (didDispose) {\n    throw Exception('Cancelled');\n  }\n\n  // The following code is unchanged from the previous snippet\n  final client = http.Client();\n  ref.onDispose(client.close);\n\n  final response = await client.get(\n    Uri.https('www.boredapi.com', '/api/activity'),\n  );\n\n  final json = jsonDecode(response.body) as Map;\n  return Activity.fromJson(Map.from(json));\n}\n\n```\n\n## Going further: Doing both at once [​](\\#going-further-doing-both-at-once \"Direct link to Going further: Doing both at once\")\n\nWe now know how to debounce and cancel requests.\n\nBut currently, if we want to do another request, we need to copy-paste\nthe same logic in multiple places. This is not ideal.\n\nHowever, we can go further and implement a reusable utility to do both at once.\n\nThe idea here is to implement an extension method on `Ref` that will\nhandle both cancellation and debouncing in a single method.\n\n```codeBlockLines_e6Vv\nextension DebounceAndCancelExtension on Ref {\n  /// Wait for [duration] (defaults to 500ms), and then return a [http.Client]\n  /// which can be used to make a request.\n  ///\n  /// That client will automatically be closed when the provider is disposed.\n  Future<http.Client> getDebouncedHttpClient([Duration? duration]) async {\n    // First, we handle debouncing.\n    var didDispose = false;\n    onDispose(() => didDispose = true);\n\n    // We delay the request by 500ms, to wait for the user to stop refreshing.\n    await Future<void>.delayed(duration ?? const Duration(milliseconds: 500));\n\n    // If the provider was disposed during the delay, it means that the user\n    // refreshed again. We throw an exception to cancel the request.\n    // It is safe to use an exception here, as it will be caught by Riverpod.\n    if (didDispose) {\n      throw Exception('Cancelled');\n    }\n\n    // We now create the client and close it when the provider is disposed.\n    final client = http.Client();\n    onDispose(client.close);\n\n    // Finally, we return the client to allow our provider to make the request.\n    return client;\n  }\n}\n\n```\n\nWe can then use this extension method in our providers as followed:\n\n```codeBlockLines_e6Vv\n@riverpod\nFuture<Activity> activity(Ref ref) async {\n  // We obtain an HTTP client using the extension we created earlier.\n  final client = await ref.getDebouncedHttpClient();\n\n  // We now use the client to make the request instead of the \"get\" function.\n  // Our request will naturally be debounced and be cancelled if the user\n  // leaves the page.\n  final response = await client.get(\n    Uri.https('www.boredapi.com', '/api/activity'),\n  );\n\n  final json = jsonDecode(response.body) as Map;\n  return Activity.fromJson(Map.from(json));\n}\n\n```\n\n- [The application](#the-application)\n- [Cancelling requests](#cancelling-requests)\n- [Debouncing requests](#debouncing-requests)\n- [Going further: Doing both at once](#going-further-doing-both-at-once)",
    "metadata": {
      "url": "https://riverpod.dev/docs/case_studies/cancel",
      "ogUrl": "https://riverpod.dev/docs/case_studies/cancel",
      "title": "Debouncing/Cancelling network requests | Riverpod",
      "og:url": "https://riverpod.dev/docs/case_studies/cancel",
      "ogImage": "https://riverpod.dev/img/cover.png",
      "ogTitle": "Debouncing/Cancelling network requests | Riverpod",
      "language": "en",
      "og:image": "https://riverpod.dev/img/cover.png",
      "og:title": "Debouncing/Cancelling network requests | Riverpod",
      "viewport": "width=device-width, initial-scale=1.0",
      "generator": "Docusaurus v2.4.3",
      "sourceURL": "https://riverpod.dev/docs/case_studies/cancel",
      "statusCode": 200,
      "description": "As applications grow in complexity, it's common to have multiple network requests",
      "twitter:card": "summary_large_image",
      "ogDescription": "As applications grow in complexity, it's common to have multiple network requests",
      "twitter:image": "https://riverpod.dev/img/cover.png",
      "docusaurus_tag": "docs-default-current",
      "og:description": "As applications grow in complexity, it's common to have multiple network requests",
      "docsearch:version": "current",
      "docusaurus_locale": "en",
      "ogLocaleAlternate": [],
      "docsearch:language": "en",
      "docusaurus_version": "current",
      "docsearch:docusaurus_tag": "docs-default-current"
    }
  },
  {
    "markdown": "[Skip to main content](#__docusaurus_skipToContent_fallback)\n\ncaution\n\nThe content of this page may be outdated.\n\nIt will be updated in the future, but for now you may want to refer to the content\nin the top of the sidebar instead (introduction/essentials/case-studies/...)\n\n[NotifierProvider](https://pub.dev/documentation/riverpod/latest/riverpod/NotifierProvider.html) is a provider that is used to listen to and expose a [Notifier](https://pub.dev/documentation/riverpod/latest/riverpod/Notifier-class.html).\n\n[AsyncNotifierProvider](https://pub.dev/documentation/riverpod/latest/riverpod/AsyncNotifierProvider.html) is a provider that is used to listen to and expose an [AsyncNotifier](https://pub.dev/documentation/riverpod/latest/riverpod/AsyncNotifier-class.html).\n[AsyncNotifier](https://pub.dev/documentation/riverpod/latest/riverpod/AsyncNotifier-class.html) is a [Notifier](https://pub.dev/documentation/riverpod/latest/riverpod/Notifier-class.html) that can be asynchronously initialized.\n\n`(Async)NotifierProvider` along with `(Async)Notifier` is Riverpod's recommended solution\nfor managing state which may change in reaction to a user interaction.\n\nIt is typically used for:\n\n- exposing a state which can change over time after reacting to custom events.\n- centralizing the logic for modifying some state (aka \"business logic\") in a\nsingle place, improving maintainability over time.\n\nAs a usage example, we could use [NotifierProvider](https://pub.dev/documentation/riverpod/latest/riverpod/NotifierProvider.html) to implement a todo-list.\nDoing so would allow us to expose methods such as `addTodo` to let the UI\nmodify the list of todos on user interactions:\n\n```codeBlockLines_e6Vv\n\n@freezed\nclass Todo with _$Todo {\n  factory Todo({\n    required String id,\n    required String description,\n    required bool completed,\n  }) = _Todo;\n}\n\n// This will generates a Notifier and NotifierProvider.\n// The Notifier class that will be passed to our NotifierProvider.\n// This class should not expose state outside of its \"state\" property, which means\n// no public getters/properties!\n// The public methods on this class will be what allow the UI to modify the state.\n// Finally, we are using todosProvider(NotifierProvider) to allow the UI to\n// interact with our Todos class.\n@riverpod\nclass Todos extends _$Todos {\n  @override\n  List<Todo> build() {\n    return [];\n  }\n\n  // Let's allow the UI to add todos.\n  void addTodo(Todo todo) {\n    // Since our state is immutable, we are not allowed to do `state.add(todo)`.\n    // Instead, we should create a new list of todos which contains the previous\n    // items and the new one.\n    // Using Dart's spread operator here is helpful!\n    state = [...state, todo];\n    // No need to call \"notifyListeners\" or anything similar. Calling \"state =\"\n    // will automatically rebuild the UI when necessary.\n  }\n\n  // Let's allow removing todos\n  void removeTodo(String todoId) {\n    // Again, our state is immutable. So we're making a new list instead of\n    // changing the existing list.\n    state = [\\\n      for (final todo in state)\\\n        if (todo.id != todoId) todo,\\\n    ];\n  }\n\n  // Let's mark a todo as completed\n  void toggle(String todoId) {\n    state = [\\\n      for (final todo in state)\\\n        // we're marking only the matching todo as completed\\\n        if (todo.id == todoId)\\\n          // Once more, since our state is immutable, we need to make a copy\\\n          // of the todo. We're using our `copyWith` method implemented before\\\n          // to help with that.\\\n          todo.copyWith(completed: !todo.completed)\\\n        else\\\n          // other todos are not modified\\\n          todo,\\\n    ];\n  }\n}\n\n```\n\nNow that we have defined a [NotifierProvider](https://pub.dev/documentation/riverpod/latest/riverpod/NotifierProvider.html), we can use it to interact\nwith the list of todos in our UI:\n\n```codeBlockLines_e6Vv\n\nclass TodoListView extends ConsumerWidget {\n  const TodoListView({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // rebuild the widget when the todo list changes\n    List<Todo> todos = ref.watch(todosProvider);\n\n    // Let's render the todos in a scrollable list view\n    return ListView(\n      children: [\\\n        for (final todo in todos)\\\n          CheckboxListTile(\\\n            value: todo.completed,\\\n            // When tapping on the todo, change its completed status\\\n            onChanged: (value) =>\\\n                ref.read(todosProvider.notifier).toggle(todo.id),\\\n            title: Text(todo.description),\\\n          ),\\\n      ],\n    );\n  }\n}\n\n```\n\nAs a usage example, we could use [AsyncNotifierProvider](https://pub.dev/documentation/riverpod/latest/riverpod/AsyncNotifierProvider.html) to implement a remote todo-list.\nDoing so would allow us to expose methods such as `addTodo` to let the UI\nmodify the list of todos on user interactions:\n\n```codeBlockLines_e6Vv\n\n@freezed\nclass Todo with _$Todo {\n  factory Todo({\n    required String id,\n    required String description,\n    required bool completed,\n  }) = _Todo;\n\n  factory Todo.fromJson(Map<String, dynamic> json) => _$TodoFromJson(json);\n}\n\n// This will generates a AsyncNotifier and AsyncNotifierProvider.\n// The AsyncNotifier class that will be passed to our AsyncNotifierProvider.\n// This class should not expose state outside of its \"state\" property, which means\n// no public getters/properties!\n// The public methods on this class will be what allow the UI to modify the state.\n// Finally, we are using asyncTodosProvider(AsyncNotifierProvider) to allow the UI to\n// interact with our Todos class.\n@riverpod\nclass AsyncTodos extends _$AsyncTodos {\n  Future<List<Todo>> _fetchTodo() async {\n    final json = await http.get('api/todos');\n    final todos = jsonDecode(json) as List<Map<String, dynamic>>;\n    return todos.map(Todo.fromJson).toList();\n  }\n\n  @override\n  FutureOr<List<Todo>> build() async {\n    // Load initial todo list from the remote repository\n    return _fetchTodo();\n  }\n\n  Future<void> addTodo(Todo todo) async {\n    // Set the state to loading\n    state = const AsyncValue.loading();\n    // Add the new todo and reload the todo list from the remote repository\n    state = await AsyncValue.guard(() async {\n      await http.post('api/todos', todo.toJson());\n      return _fetchTodo();\n    });\n  }\n\n  // Let's allow removing todos\n  Future<void> removeTodo(String todoId) async {\n    state = const AsyncValue.loading();\n    state = await AsyncValue.guard(() async {\n      await http.delete('api/todos/$todoId');\n      return _fetchTodo();\n    });\n  }\n\n  // Let's mark a todo as completed\n  Future<void> toggle(String todoId) async {\n    state = const AsyncValue.loading();\n    state = await AsyncValue.guard(() async {\n      await http.patch(\n        'api/todos/$todoId',\n        <String, dynamic>{'completed': true},\n      );\n      return _fetchTodo();\n    });\n  }\n}\n\n```\n\nNow that we have defined a [AsyncNotifierProvider](https://pub.dev/documentation/riverpod/latest/riverpod/AsyncNotifierProvider.html), we can use it to interact\nwith the list of todos in our UI:\n\n```codeBlockLines_e6Vv\n\nclass TodoListView extends ConsumerWidget {\n  const TodoListView({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // rebuild the widget when the todo list changes\n    final asyncTodos = ref.watch(asyncTodosProvider);\n\n    // Let's render the todos in a scrollable list view\n    return switch (asyncTodos) {\n      AsyncData(:final value) => ListView(\n          children: [\\\n            for (final todo in value)\\\n              CheckboxListTile(\\\n                value: todo.completed,\\\n                // When tapping on the todo, change its completed status\\\n                onChanged: (value) {\\\n                  ref.read(asyncTodosProvider.notifier).toggle(todo.id);\\\n                },\\\n                title: Text(todo.description),\\\n              ),\\\n          ],\n        ),\n      AsyncError(:final error) => Text('Error: $error'),\n      _ => const Center(child: CircularProgressIndicator()),\n    };\n  }\n}\n\n```",
    "metadata": {
      "url": "https://riverpod.dev/docs/providers/notifier_provider",
      "ogUrl": "https://riverpod.dev/docs/providers/notifier_provider",
      "title": "(Async)NotifierProvider | Riverpod",
      "og:url": "https://riverpod.dev/docs/providers/notifier_provider",
      "ogImage": "https://riverpod.dev/img/cover.png",
      "ogTitle": "(Async)NotifierProvider | Riverpod",
      "language": "en",
      "og:image": "https://riverpod.dev/img/cover.png",
      "og:title": "(Async)NotifierProvider | Riverpod",
      "viewport": "width=device-width, initial-scale=1.0",
      "generator": "Docusaurus v2.4.3",
      "sourceURL": "https://riverpod.dev/docs/providers/notifier_provider",
      "statusCode": 200,
      "description": "The content of this page may be outdated.",
      "twitter:card": "summary_large_image",
      "ogDescription": "The content of this page may be outdated.",
      "twitter:image": "https://riverpod.dev/img/cover.png",
      "docusaurus_tag": "docs-default-current",
      "og:description": "The content of this page may be outdated.",
      "docsearch:version": "current",
      "docusaurus_locale": "en",
      "ogLocaleAlternate": [],
      "docsearch:language": "en",
      "docusaurus_version": "current",
      "docsearch:docusaurus_tag": "docs-default-current"
    }
  },
  {
    "markdown": "[Skip to main content](#__docusaurus_skipToContent_fallback)\n\nOn this page\n\nNetwork requests are the core of any application. But there are a lot of things to consider when\nmaking a network request:\n\n- The UI should render a loading state while the request is being made\n- Errors should be gracefully handled\n- The request should be cached if possible\n\nIn this section, we will see how Riverpod can help us deal with all of this naturally.\n\n## Setting up `ProviderScope` [​](\\#setting-up-providerscope \"Direct link to setting-up-providerscope\")\n\nBefore we start making network requests, make sure that `ProviderScope` is added at the\nroot of the application.\n\n```codeBlockLines_e6Vv\nvoid main() {\n  runApp(\n    // To install Riverpod, we need to add this widget above everything else.\n    // This should not be inside \"MyApp\" but as direct parameter to \"runApp\".\n    ProviderScope(\n      child: MyApp(),\n    ),\n  );\n}\n\n```\n\nDoing so will enable Riverpod for the entire application.\n\nnote\n\nFor complete installation steps (such as installing [riverpod\\_lint](https://pub.dev/packages/riverpod_lint)\nand running the code-generator), check out [Getting started](/docs/introduction/getting_started).\n\n## Performing your network request in a \"provider\" [​](\\#performing-your-network-request-in-a-provider \"Direct link to Performing your network request in a \\\"provider\\\"\")\n\nPerforming a network request is usually what we call \"business logic\".\nIn Riverpod, business logic is placed inside \"providers\".\n\nA provider is a super-powered function.\nThey behave like normal functions, with the added benefits of:\n\n- Being cached\n- Offering default error/loading handling\n- Being listenable\n- Automatically re-executing when some data changes\n\nThis make providers a perfect fit for _GET_ network requests (as for _POST/etc_ requests, see [Performing side effects](/docs/essentials/side_effects)).\n\nAs an example, let's make a simple application which suggests a random activity to do when bored.\n\nTo do so, we will use the [Bored API](https://boredapi.com/). In particular,\nwe will perform a _GET_ request on the `/api/activity` endpoint. This returns a JSON object,\nwhich we will parse into a Dart class instance.\n\nThe next step would then be to display this activity in the UI. We would also make sure\nto render a loading state while the request is being made, and to gracefully handle errors.\n\nSounds great? Let's do it!\n\n### Defining the model [​](\\#defining-the-model \"Direct link to Defining the model\")\n\nBefore we start, we need to define the model of the data we will receive from the API.\nThis model will also need a way to parse the JSON object into a Dart class instance.\n\nGenerally, it is recommended to use a code-generator such as [Freezed](https://pub.dev/packages/freezed)\nor [json\\_serializable](https://pub.dev/packages/json_serializable) to handle\nJSON decoding. But of course, it's also possible to do it by hand.\n\nAnyway, here's our model:\n\nactivity.dart\n\n```codeBlockLines_e6Vv\n\nimport 'package:freezed_annotation/freezed_annotation.dart';\n\npart 'activity.freezed.dart';\npart 'activity.g.dart';\n\n/// The response of the `GET /api/activity` endpoint.\n///\n/// It is defined using `freezed` and `json_serializable`.\n@freezed\nclass Activity with _$Activity {\n  factory Activity({\n    required String key,\n    required String activity,\n    required String type,\n    required int participants,\n    required double price,\n  }) = _Activity;\n\n  /// Convert a JSON object into an [Activity] instance.\n  /// This enables type-safe reading of the API response.\n  factory Activity.fromJson(Map<String, dynamic> json) => _$ActivityFromJson(json);\n}\n\n```\n\n### Creating the provider [​](\\#creating-the-provider \"Direct link to Creating the provider\")\n\nNow that we have our model, we can start querying the API.\n\nTo do so, we will need to create our first provider.\n\nThe syntax for defining a provider is as followed:\n\n```\n@riverpod\nResult myFunction(Ref ref) {\n  <your logic here>\n}\n\n```\n\n|     |     |\n| --- | --- |\n| The annotation | All providers must be annotated with `@riverpod` or `@Riverpod()`.<br>This annotation can be placed on global functions or classes.<br>Through this annotation, it is possible to configure the provider.<br>For example, we can disable \"auto-dispose\" (which we will see later) by writing `@Riverpod(keepAlive: true)`. |\n| The annotated function | The name of the annotated function determines how the provider<br>will be interacted with.<br>For a given function `myFunction`, a generated `myFunctionProvider` variable will be generated.<br>Annotated functions **must** specify a \"ref\" as first parameter.<br>Besides that, the function can have any number of parameters, including generics.<br>The function is also free to return a `Future`/ `Stream` if it wishes to.<br>This function will be called when the provider is first read.<br>Subsequent reads will not call the function again, but instead return the cached value. |\n| Ref | An object used to interact with other providers.<br>All providers have one; either as parameter of the provider function,<br>or as a property of a Notifier.<br>The type of this object is determined by the name of the function/class. |\n\nIn our case, we want to _GET_ an activity from the API.\n\nSince a _GET_ is an asynchronous operation, that means we will want\nto create a `Future<Activity>`.\n\nUsing the syntax defined previously, we can therefore define our provider as followed:\n\nprovider.dart\n\n```codeBlockLines_e6Vv\n\nimport 'dart:convert';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:http/http.dart' as http;\nimport 'package:riverpod_annotation/riverpod_annotation.dart';\nimport 'activity.dart';\n\n// Necessary for code-generation to work\npart 'provider.g.dart';\n\n/// This will create a provider named `activityProvider`\n/// which will cache the result of this function.\n@riverpod\nFuture<Activity> activity(Ref ref) async {\n  // Using package:http, we fetch a random activity from the Bored API.\n  final response = await http.get(Uri.https('boredapi.com', '/api/activity'));\n  // Using dart:convert, we then decode the JSON payload into a Map data structure.\n  final json = jsonDecode(response.body) as Map<String, dynamic>;\n  // Finally, we convert the Map into an Activity instance.\n  return Activity.fromJson(json);\n}\n\n```\n\nIn this snippet, we've defined a provider named `activityProvider` which\nour UI will be able to use to obtain a random activity. It is worth noting\nthat:\n\n- The network request will not be executed until the UI reads the provider\nat least once.\n- Subsequent reads will not re-execute the network request,\nbut instead return the previously fetched activity.\n- If the UI stops using this provider, the cache will be destroyed.\nThen, if the UI ever uses the provider again, that a new network request will be made.\n- We did not catch errors. This is voluntary, as providers\nnatively handle errors.\n\nIf the network request or if the JSON parsing throws, the error\nwill be caught by Riverpod. Then, the UI will automatically have the necessary\ninformation to render an error page.\n\ninfo\n\nProviders are \"lazy\". Defining a provider will not execute the network request.\nInstead, the network request will be executed when the provider is first read.\n\n### Rendering the network request's response in the UI [​](\\#rendering-the-network-requests-response-in-the-ui \"Direct link to Rendering the network request's response in the UI\")\n\nNow that we have defined a provider, we can start using it inside our UI\nto display the activity.\n\nTo interact with a provider, we need an object called \"ref\". You may have seen\nit previously in the provider definition, as providers naturally have access\nto a \"ref\" object.\n\nBut in our case, we aren't in a provider, but a widget. So how do we get a \"ref\"?\n\nThe solution is to use a custom widget called `Consumer`. A `Consumer` is a widget\nsimilar to `Builder`, but with the added benefit of offering us a \"ref\". This enables our UI to read providers.\nThe following example showcases how to use a `Consumer`:\n\nconsumer.dart\n\n```codeBlockLines_e6Vv\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nimport 'activity.dart';\nimport 'provider.dart';\n\n/// The homepage of our application\nclass Home extends StatelessWidget {\n  const Home({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Consumer(\n      builder: (context, ref, child) {\n        // Read the activityProvider. This will start the network request\n        // if it wasn't already started.\n        // By using ref.watch, this widget will rebuild whenever the\n        // the activityProvider updates. This can happen when:\n        // - The response goes from \"loading\" to \"data/error\"\n        // - The request was refreshed\n        // - The result was modified locally (such as when performing side-effects)\n        // ...\n        final AsyncValue<Activity> activity = ref.watch(activityProvider);\n\n        return Center(\n          /// Since network-requests are asynchronous and can fail, we need to\n          /// handle both error and loading states. We can use pattern matching for this.\n          /// We could alternatively use `if (activity.isLoading) { ... } else if (...)`\n          child: switch (activity) {\n            AsyncData(:final value) => Text('Activity: ${value.activity}'),\n            AsyncError() => const Text('Oops, something unexpected happened'),\n            _ => const CircularProgressIndicator(),\n          },\n        );\n      },\n    );\n  }\n}\n\n```\n\nIn that snippet, we've used a `Consumer` to read our `activityProvider` and display the activity.\nWe also gracefully handled the loading/error states.\n\nNotice how the UI was able to handle loading/error states without having to do anything special\nin the provider.\n\nAt the same time, if the widget were to rebuild, the network request would correctly\nnot be re-executed. Other widgets could also access the same provider without\nre-executing the network request.\n\ninfo\n\nWidgets can listen to as many providers as they want. To do so, simply add more `ref.watch` calls.\n\ntip\n\nMake sure to install the linter. That will enable your IDE to offer refactoring\noptions to automatically add a `Consumer` or convert a `StatelessWidget` into a `ConsumerWidget`.\n\nSee [Getting started](/docs/introduction/getting_started#enabling-riverpod_lintcustom_lint) for installation steps.\n\n## Going further: Removing code indentation by using `ConsumerWidget` instead of `Consumer`. [​](\\#going-further-removing-code-indentation-by-using-consumerwidget-instead-of-consumer \"Direct link to going-further-removing-code-indentation-by-using-consumerwidget-instead-of-consumer\")\n\nIn the previous example, we used a `Consumer` to read our provider.\n\nAlthough there is nothing wrong with this approach, the added indentation\ncan make the code harder to read.\n\nRiverpod offers an alternative way of achieving the same result:\nInstead of writing a `StatelessWidget`/ `StatefulWidget` returns a `Consumer`, we can\ndefine a `ConsumerWidget`/ `ConsumerStatefulWidget`.\n\n`ConsumerWidget` and `ConsumerStatefulWidget` are effectively the fusion\nof a `StatelessWidget`/ `StatefulWidget` and a `Consumer`. They behave the same\nas their original couterpart, but with the added benefit of offering a \"ref\".\n\nWe can rewrite the previous examples to use `ConsumerWidget` as followed:\n\n```codeBlockLines_e6Vv\n\n/// We subclassed \"ConsumerWidget\" instead of \"StatelessWidget\".\n/// This is equivalent to making a \"StatelessWidget\" and retuning \"Consumer\".\nclass Home extends ConsumerWidget {\n  const Home({super.key});\n\n  @override\n  // Notice how \"build\" now receives an extra parameter: \"ref\"\n  Widget build(BuildContext context, WidgetRef ref) {\n    // We can use \"ref.watch\" inside our widget like we did using \"Consumer\"\n    final AsyncValue<Activity> activity = ref.watch(activityProvider);\n\n    // The rendering logic stays the same\n    return Center(/* ... */);\n  }\n}\n\n```\n\nAs for `ConsumerStatefulWidget`, we would instead write:\n\n```codeBlockLines_e6Vv\n\n// We extend ConsumerStatefulWidget.\n// This is the equivalent of \"Consumer\" + \"StatefulWidget\".\nclass Home extends ConsumerStatefulWidget {\n  const Home({super.key});\n\n  @override\n  ConsumerState<ConsumerStatefulWidget> createState() => _HomeState();\n}\n\n// Notice how instead of \"State\", we are extending \"ConsumerState\".\n// This uses the same principle as \"ConsumerWidget\" vs \"StatelessWidget\".\nclass _HomeState extends ConsumerState<Home> {\n  @override\n  void initState() {\n    super.initState();\n\n    // State life-cycles have access to \"ref\" too.\n    // This enables things such as adding a listener on a specific provider\n    // to show dialogs/snackbars.\n    ref.listenManual(activityProvider, (previous, next) {\n      // TODO show a snackbar/dialog\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // \"ref\" is not passed as parameter anymore, but is instead a property of \"ConsumerState\".\n    // We can therefore keep using \"ref.watch\" inside \"build\".\n    final AsyncValue<Activity> activity = ref.watch(activityProvider);\n\n    return Center(/* ... */);\n  }\n}\n\n```\n\n### Flutter\\_hooks considerations: Combining `HookWidget` and `ConsumerWidget` [​](\\#flutter_hooks-considerations-combining-hookwidget-and-consumerwidget \"Direct link to flutter_hooks-considerations-combining-hookwidget-and-consumerwidget\")\n\ncaution\n\nIf you have never heard about \"hooks\" before, feel free to skip this section.\n\n[Flutter\\_hooks](https://pub.dev/packages/flutter_hooks) is a package\nindependent from Riverpod but often used alongside it. If you are new to Riverpod,\nusing \"hooks\" is discouraged. See more in [About hooks](/docs/concepts/about_hooks).\n\nIf you are using `flutter_hooks`, you may be wondering how to combine `HookWidget`\nand `ConsumerWidget`. After all, both involve changing the extended widget class.\n\nRiverpod offers a solution to this problem: `HookConsumerWidget` and `StatefulHookConsumerWidget`.\n\nSimilarly to how `ConsumerWidget` and `ConsumerStatefulWidget` are the fusion of `Consumer` and `StatelessWidget`/ `StatefulWidget`,\n`HookConsumerWidget` and `StatefulHookConsumerWidget` are the fusion of `Consumer` and `HookWidget`/ `HookStatefulWidget`.\nAs such, they enable using both hooks and providers in the same widget.\n\nTo showcase this, we could one more time rewrite the previous example:\n\n```codeBlockLines_e6Vv\n\n/// We subclassed \"HookConsumerWidget\".\n/// This combines \"StatelessWidget\" + \"Consumer\" + \"HookWidget\" together.\nclass Home extends HookConsumerWidget {\n  const Home({super.key});\n\n  @override\n  // Notice how \"build\" now receives an extra parameter: \"ref\"\n  Widget build(BuildContext context, WidgetRef ref) {\n    // It is possible to use hooks such as \"useState\" inside our widget\n    final counter = useState(0);\n\n    // We can also use read providers\n    final AsyncValue<Activity> activity = ref.watch(activityProvider);\n\n    return Center(/* ... */);\n  }\n}\n\n```\n\n- [Setting up `ProviderScope`](#setting-up-providerscope)\n- [Performing your network request in a \"provider\"](#performing-your-network-request-in-a-provider)\n  - [Defining the model](#defining-the-model)\n  - [Creating the provider](#creating-the-provider)\n  - [Rendering the network request's response in the UI](#rendering-the-network-requests-response-in-the-ui)\n- [Going further: Removing code indentation by using `ConsumerWidget` instead of `Consumer`.](#going-further-removing-code-indentation-by-using-consumerwidget-instead-of-consumer)\n  - [Flutter\\_hooks considerations: Combining `HookWidget` and `ConsumerWidget`](#flutter_hooks-considerations-combining-hookwidget-and-consumerwidget)",
    "metadata": {
      "url": "https://riverpod.dev/docs/essentials/first_request",
      "ogUrl": "https://riverpod.dev/docs/essentials/first_request",
      "title": "Make your first provider/network request | Riverpod",
      "og:url": "https://riverpod.dev/docs/essentials/first_request",
      "ogImage": "https://riverpod.dev/img/cover.png",
      "ogTitle": "Make your first provider/network request | Riverpod",
      "language": "en",
      "og:image": "https://riverpod.dev/img/cover.png",
      "og:title": "Make your first provider/network request | Riverpod",
      "viewport": "width=device-width, initial-scale=1.0",
      "generator": "Docusaurus v2.4.3",
      "sourceURL": "https://riverpod.dev/docs/essentials/first_request",
      "statusCode": 200,
      "description": "Network requests are the core of any application. But there are a lot of things to consider when",
      "twitter:card": "summary_large_image",
      "ogDescription": "Network requests are the core of any application. But there are a lot of things to consider when",
      "twitter:image": "https://riverpod.dev/img/cover.png",
      "docusaurus_tag": "docs-default-current",
      "og:description": "Network requests are the core of any application. But there are a lot of things to consider when",
      "docsearch:version": "current",
      "docusaurus_locale": "en",
      "ogLocaleAlternate": [],
      "docsearch:language": "en",
      "docusaurus_version": "current",
      "docsearch:docusaurus_tag": "docs-default-current"
    }
  },
  {
    "markdown": "[Skip to main content](#__docusaurus_skipToContent_fallback)\n\nOn this page\n\nSo far, we've only covered on how to create a `Future`.\n\nThis is on purpose, as `Future` s are the core of how Riverpod applications\nshould be built. _But_, Riverpod also supports other formats if necessary.\n\nIn particular, instead of a `Future`, providers are free to:\n\n- Synchronously return an object, such as to create a \"Repository\".\n- Return a `Stream`, such as to listen to websockets.\n\nReturning a `Future` and returning a `Stream` or an object\nis quite similar overall. Think of this page as\nan explanation of subtle differences and various tips for those use-cases.\n\n## Synchronously returning an object [​](\\#synchronously-returning-an-object \"Direct link to Synchronously returning an object\")\n\nTo synchronously create an object, make sure that your\nprovider does not return a Future:\n\n```codeBlockLines_e6Vv\n@riverpod\nint synchronousExample(Ref ref) {\n  return 0;\n}\n\n```\n\nWhen a provider synchronously creates an object,\nthis impacts how the object is consumed.\nIn particular, synchronous values are not wrapped\nin an \"AsyncValue\":\n\n```codeBlockLines_e6Vv\n  Consumer(\n    builder: (context, ref, child) {\n      // The value is not wrapped in an \"AsyncValue\"\n      int value = ref.watch(synchronousExampleProvider);\n\n      return Text('$value');\n    },\n  );\n\n```\n\nThe consequence of this difference is that if your provider\nthrows, trying to read the value will rethrow the error.\nAlternatively, when using `ref.listen`, the \"onError\" callback\nwill be invoked.\n\n### Listenable objects considerations [​](\\#listenable-objects-considerations \"Direct link to Listenable objects considerations\")\n\nListenable objects such as `ChangeNotifier` or `StateNotifier` are not supported.\n\nIf, for compatibility reasons, you need to interact with one of such objects,\none workaround is to pipe their notification mechanism to Riverpod.\n\n```codeBlockLines_e6Vv\n/// A provider which creates a ValueNotifier and update its listeners\n/// whenever the value changes.\n@riverpod\nValueNotifier<int> myListenable(Ref ref) {\n  final notifier = ValueNotifier(0);\n\n  // Dispose of the notifier when the provider is destroyed\n  ref.onDispose(notifier.dispose);\n\n  // Notify listeners of this provider whenever the ValueNotifier updates.\n  notifier.addListener(ref.notifyListeners);\n\n  return notifier;\n}\n\n```\n\ninfo\n\nIn case you need such logic many times, it is worth noting that\nthe logic shared! The \"ref\" object is designed to be composable.\nThis enables extracting the dispose/listening logic out of the provider:\n\n```codeBlockLines_e6Vv\nextension on Ref {\n  // We can move the previous logic to a Ref extension.\n  // This enables reusing the logic between providers\n  T disposeAndListenChangeNotifier<T extends ChangeNotifier>(T notifier) {\n    onDispose(notifier.dispose);\n    notifier.addListener(notifyListeners);\n    // We return the notifier to ease the usage a bit\n    return notifier;\n  }\n}\n\n@riverpod\nValueNotifier<int> myListenable(Ref ref) {\n  return ref.disposeAndListenChangeNotifier(ValueNotifier(0));\n}\n\n@riverpod\nValueNotifier<int> anotherListenable(Ref ref) {\n  return ref.disposeAndListenChangeNotifier(ValueNotifier(42));\n}\n\n```\n\n## Listening to a Stream [​](\\#listening-to-a-stream \"Direct link to Listening to a Stream\")\n\nA common use-case of modern applications is to interact with websockets,\nsuch as with Firebase or GraphQL subscriptions.\n\nInteracting with those APIs is often done by listening to a `Stream`.\n\nTo help with that, Riverpod naturally supports `Stream` objects.\nLike with `Future` s, the object will be converted to an `AsyncValue`:\n\n```codeBlockLines_e6Vv\n@riverpod\nStream<int> streamExample(Ref ref) async* {\n  // Every 1 second, yield a number from 0 to 41.\n  // This could be replaced with a Stream from Firestore or GraphQL or anything else.\n  for (var i = 0; i < 42; i++) {\n    yield i;\n    await Future<void>.delayed(const Duration(seconds: 1));\n  }\n}\n\nclass Consumer extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // The stream is listened to and converted to an AsyncValue.\n    AsyncValue<int> value = ref.watch(streamExampleProvider);\n\n    // We can use the AsyncValue to handle loading/error states and show the data.\n    return switch (value) {\n      AsyncValue(:final error?) => Text('Error: $error'),\n      AsyncValue(:final valueOrNull?) => Text('$valueOrNull'),\n      _ => const CircularProgressIndicator(),\n    };\n  }\n}\n\n```\n\ninfo\n\nRiverpod is not aware of custom `Stream` implementations, such as\nRX's `BehaviorSubject`.\nAs such, returning a `BehaviorSubject` will not expose the `value`\nsynchronously to widgets, even if already available on creation.\n\n## Disabling conversion of `Stream` s/ `Future` s to `AsyncValue` [​](\\#disabling-conversion-of-streamsfutures-to-asyncvalue \"Direct link to disabling-conversion-of-streamsfutures-to-asyncvalue\")\n\nBy default, Riverpod will convert `Stream` s and `Future` s to `AsyncValue`.\nAlthough rarely needed, it is possible to disable this behavior by wrapping\nthe return type in a `Raw` typedef.\n\ncaution\n\nIt is generally discouraged to disable the `AsyncValue` conversion.\nDo so only if you know what you are doing.\n\n```codeBlockLines_e6Vv\n@riverpod\nRaw<Stream<int>> rawStream(Ref ref) {\n  // \"Raw\" is a typedef. No need to wrap the return\n  // value in a \"Raw\" constructor.\n  return const Stream<int>.empty();\n}\n\nclass Consumer extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // The value is no-longer converted to AsyncValue,\n    // and the created stream is returned as is.\n    Stream<int> stream = ref.watch(rawStreamProvider);\n    return StreamBuilder<int>(\n      stream: stream,\n      builder: (context, snapshot) {\n        return Text('${snapshot.data}');\n      },\n    );\n  }\n}\n\n```\n\n- [Synchronously returning an object](#synchronously-returning-an-object)\n  - [Listenable objects considerations](#listenable-objects-considerations)\n- [Listening to a Stream](#listening-to-a-stream)\n- [Disabling conversion of `Stream` s/ `Future` s to `AsyncValue`](#disabling-conversion-of-streamsfutures-to-asyncvalue)",
    "metadata": {
      "url": "https://riverpod.dev/docs/essentials/websockets_sync",
      "ogUrl": "https://riverpod.dev/docs/essentials/websockets_sync",
      "title": "Websockets and synchronous execution | Riverpod",
      "og:url": "https://riverpod.dev/docs/essentials/websockets_sync",
      "ogImage": "https://riverpod.dev/img/cover.png",
      "ogTitle": "Websockets and synchronous execution | Riverpod",
      "language": "en",
      "og:image": "https://riverpod.dev/img/cover.png",
      "og:title": "Websockets and synchronous execution | Riverpod",
      "viewport": "width=device-width, initial-scale=1.0",
      "generator": "Docusaurus v2.4.3",
      "sourceURL": "https://riverpod.dev/docs/essentials/websockets_sync",
      "statusCode": 200,
      "description": "So far, we've only covered on how to create a Future.",
      "twitter:card": "summary_large_image",
      "ogDescription": "So far, we've only covered on how to create a Future.",
      "twitter:image": "https://riverpod.dev/img/cover.png",
      "docusaurus_tag": "docs-default-current",
      "og:description": "So far, we've only covered on how to create a Future.",
      "docsearch:version": "current",
      "docusaurus_locale": "en",
      "ogLocaleAlternate": [],
      "docsearch:language": "en",
      "docusaurus_version": "current",
      "docsearch:docusaurus_tag": "docs-default-current"
    }
  },
  {
    "markdown": "[Skip to main content](#__docusaurus_skipToContent_fallback)\n\nOn this page\n\nAll providers are initialized lazily by default. This means that the provider is only\ninitialized when it is first used. This is useful for providers that are only\nused in certain parts of the application.\n\nUnfortunately, there is no way to flag a provider as needing to be eagerly initialized due\nto how Dart works (for tree shaking purposes). One solution, however, is to forcibly\nread the providers you want to eagerly initialize at the root of your application.\n\nThe recommended approach is to simply \"watch\" a provider in a Consumer placed right under your `ProviderScope`:\n\n```codeBlockLines_e6Vv\nvoid main() {\n  runApp(ProviderScope(child: MyApp()));\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return const _EagerInitialization(\n      // TODO: Render your app here\n      child: MaterialApp(),\n    );\n  }\n}\n\nclass _EagerInitialization extends ConsumerWidget {\n  const _EagerInitialization({required this.child});\n  final Widget child;\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // Eagerly initialize providers by watching them.\n    // By using \"watch\", the provider will stay alive and not be disposed.\n    ref.watch(myProvider);\n    return child;\n  }\n}\n\n```\n\nnote\n\nConsider putting the initialization consumer in your \"MyApp\" or in a public widget.\nThis enables your tests to use the same behavior, by removing logic from your main.\n\n### FAQ [​](\\#faq \"Direct link to FAQ\")\n\n#### Won't this rebuild our entire application when the provider changes? [​](\\#wont-this-rebuild-our-entire-application-when-the-provider-changes \"Direct link to Won't this rebuild our entire application when the provider changes?\")\n\nNo, this is not the case.\nIn the sample given above, the consumer responsible for eagerly initializing\nis a separate widget, which does nothing but return a `child`.\n\nThe key part is that it returns a `child`, rather than instantiating `MaterialApp` itself.\nThis means that if `_EagerInitialization` ever rebuilds, the `child` variable\nwill not have changed. And when a widget doesn't change, Flutter doesn't rebuild it.\n\nAs such, only `_EagerInitialization` will rebuild, unless another widget is also listening to that provider.\n\n#### Using this approach, how can I handle loading and error states? [​](\\#using-this-approach-how-can-i-handle-loading-and-error-states \"Direct link to Using this approach, how can I handle loading and error states?\")\n\nYou can handle loading/error states as you normally would in a `Consumer`.\nYour `_EagerInitialization` could check if a provider is in a \"loading\" state,\nand if so, return a `CircularProgressIndicator` instead of the `child`:\n\n```codeBlockLines_e6Vv\nclass _EagerInitialization extends ConsumerWidget {\n  const _EagerInitialization({required this.child});\n  final Widget child;\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final result = ref.watch(myProvider);\n\n    // Handle error states and loading states\n    if (result.isLoading) {\n      return const CircularProgressIndicator();\n    } else if (result.hasError) {\n      return const Text('Oopsy!');\n    }\n\n    return child;\n  }\n}\n\n```\n\n#### I've handled loading/error states, but other Consumers still receive an AsyncValue! Is there a way to not have to handle loading/error states in every widget? [​](\\#ive-handled-loadingerror-states-but-other-consumers-still-receive-an-asyncvalue-is-there-a-way-to-not-have-to-handle-loadingerror-states-in-every-widget \"Direct link to I've handled loading/error states, but other Consumers still receive an AsyncValue! Is there a way to not have to handle loading/error states in every widget?\")\n\nRather than trying to have your provider _not_ expose an `AsyncValue`, you can\ninstead have your widgets use `AsyncValue.requireValue`.\n\nThis will read the data without having to do pattern matching. And in case a bug slips through,\nit will throw an exception with a clear message.\n\n```codeBlockLines_e6Vv\n// An eagerly initialized provider.\n@riverpod\nFuture<String> example(Ref ref) async => 'Hello world';\n\nclass MyConsumer extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final result = ref.watch(exampleProvider);\n\n    /// If the provider was correctly eagerly initialized, then we can\n    /// directly read the data with \"requireValue\".\n    return Text(result.requireValue);\n  }\n}\n\n```\n\nnote\n\nAlthough there are ways to not expose the loading/error states in those cases (relying on scoping),\nit is generally discouraged to do so.\n\nThe added complexity of making two providers and using overrides is not worth the trouble.\n\n- [FAQ](#faq)",
    "metadata": {
      "url": "https://riverpod.dev/docs/essentials/eager_initialization",
      "ogUrl": "https://riverpod.dev/docs/essentials/eager_initialization",
      "title": "Eager initialization of providers | Riverpod",
      "og:url": "https://riverpod.dev/docs/essentials/eager_initialization",
      "ogImage": "https://riverpod.dev/img/cover.png",
      "ogTitle": "Eager initialization of providers | Riverpod",
      "language": "en",
      "og:image": "https://riverpod.dev/img/cover.png",
      "og:title": "Eager initialization of providers | Riverpod",
      "viewport": "width=device-width, initial-scale=1.0",
      "generator": "Docusaurus v2.4.3",
      "sourceURL": "https://riverpod.dev/docs/essentials/eager_initialization",
      "statusCode": 200,
      "description": "All providers are initialized lazily by default. This means that the provider is only",
      "twitter:card": "summary_large_image",
      "ogDescription": "All providers are initialized lazily by default. This means that the provider is only",
      "twitter:image": "https://riverpod.dev/img/cover.png",
      "docusaurus_tag": "docs-default-current",
      "og:description": "All providers are initialized lazily by default. This means that the provider is only",
      "docsearch:version": "current",
      "docusaurus_locale": "en",
      "ogLocaleAlternate": [],
      "docsearch:language": "en",
      "docusaurus_version": "current",
      "docsearch:docusaurus_tag": "docs-default-current"
    }
  },
  {
    "markdown": "[Skip to main content](#__docusaurus_skipToContent_fallback)\n\nOn this page\n\ncaution\n\nThe content of this page may be outdated.\n\nIt will be updated in the future, but for now you may want to refer to the content\nin the top of the sidebar instead (introduction/essentials/case-studies/...)\n\n`Provider` is the most basic of all providers. It creates a value... And that's about it.\n\n`Provider` is typically used for:\n\n- caching computations\n- exposing a value to other providers (such as a `Repository`/ `HttpClient`).\n- offering a way for tests or widgets to override a value.\n- reducing rebuilds of providers/widgets without having to use `select`.\n\n## Using `Provider` to cache computations [​](\\#using-provider-to-cache-computations \"Direct link to using-provider-to-cache-computations\")\n\n`Provider` is a powerful tool for caching synchronous operations when combined\nwith [ref.watch](/docs/concepts/reading#using-refwatch-to-observe-a-provider).\n\nAn example would be filtering a list of todos.\nSince filtering a list could be slightly expensive, we ideally do not want to\nfilter our list of todos whenever our application re-renders.\nIn this situation, we could use `Provider` to do the filtering for us.\n\nFor that, assume that our application has an existing [NotifierProvider](/docs/providers/notifier_provider)\nwhich manipulates a list of todos:\n\n```codeBlockLines_e6Vv\n\nclass Todo {\n  Todo(this.description, this.isCompleted);\n  final bool isCompleted;\n  final String description;\n}\n\n@riverpod\nclass Todos extends _$Todos {\n  @override\n  List<Todo> build() {\n    return [];\n  }\n\n  void addTodo(Todo todo) {\n    state = [...state, todo];\n  }\n  // TODO add other methods, such as \"removeTodo\", ...\n}\n\n```\n\nFrom there, we can use `Provider` to expose the filtered list of todos, showing\nonly the completed todos:\n\n```codeBlockLines_e6Vv\n\n@riverpod\nList<Todo> completedTodos(Ref ref) {\n  final todos = ref.watch(todosProvider);\n\n  // we return only the completed todos\n  return todos.where((todo) => todo.isCompleted).toList();\n}\n\n```\n\nWith this code, our UI is now able to show the list of the completed todos\nby listening to `completedTodosProvider`:\n\n```codeBlockLines_e6Vv\nConsumer(builder: (context, ref, child) {\n  final completedTodos = ref.watch(completedTodosProvider);\n  // TODO show the todos using a ListView/GridView/.../* SKIP */\n  return Container();\n  /* SKIP END */\n});\n\n```\n\nThe interesting part is, the list filtering is now cached.\n\nMeaning that the list of completed todos will not be recomputed until\ntodos are added/removed/updated, even if we are reading the list of completed\ntodos multiple times.\n\nNote how we do not need to manually invalidate the cache when the list of todos\nchanges. `Provider` is automatically able to know when the result must be recomputed\nthanks to [ref.watch](/docs/concepts/reading#using-refwatch-to-observe-a-provider).\n\n## Reducing provider/widget rebuilds by using `Provider` [​](\\#reducing-providerwidget-rebuilds-by-using-provider \"Direct link to reducing-providerwidget-rebuilds-by-using-provider\")\n\nA unique aspect of `Provider` is that even when `Provider` is recomputed\n(typically when using [ref.watch](/docs/concepts/reading#using-refwatch-to-observe-a-provider)), it will not update the widgets/providers\nthat listen to it unless the value changed.\n\nA real world example would be for enabling/disabling previous/next buttons\nof a paginated view:\n\n![stepper example](https://user-images.githubusercontent.com/134939/47580830-31263a00-d950-11e8-9b61-0eaddab2709e.png)\n\nIn our case, we will focus specifically on the \"previous\" button.\nA naive implementation of such button would be a widget which obtains the\ncurrent page index, and if that index is equal to 0, we would disable the button.\n\nThis code could be:\n\n```codeBlockLines_e6Vv\n\n@riverpod\nclass PageIndex extends _$PageIndex {\n  @override\n  int build() {\n    return 0;\n  }\n\n  void goToPreviousPage() {\n    state = state - 1;\n  }\n}\n\nclass PreviousButton extends ConsumerWidget {\n  const PreviousButton({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // if not on first page, the previous button is active\n    final canGoToPreviousPage = ref.watch(pageIndexProvider) != 0;\n\n    void goToPreviousPage() {\n      ref.read(pageIndexProvider.notifier).goToPreviousPage();\n    }\n\n    return ElevatedButton(\n      onPressed: canGoToPreviousPage ? goToPreviousPage : null,\n      child: const Text('previous'),\n    );\n  }\n}\n\n```\n\nThe issue with this code is that whenever we change the current page, the \"previous\"\nbutton will rebuild.\n\nIn the ideal world, we would want the button to rebuild only when changing between\nactivated and deactivated.\n\nThe root of the issue here is that we are computing whether the user is\nallowed to go to the previous page directly within the \"previous\" button.\n\nA way to solve this is to extract this logic outside of the widget and into a `Provider`:\n\n```codeBlockLines_e6Vv\n\n@riverpod\nclass PageIndex extends _$PageIndex {\n  @override\n  int build() {\n    return 0;\n  }\n\n  void goToPreviousPage() {\n    state = state - 1;\n  }\n}\n\n// A provider which computes whether the user is allowed to go to the previous page\n@riverpod\nbool canGoToPreviousPage(Ref ref) {\n  return ref.watch(pageIndexProvider) != 0;\n}\n\nclass PreviousButton extends ConsumerWidget {\n  const PreviousButton({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // We are now watching our new Provider\n    // Our widget is no longer calculating whether we can go to the previous page.\n    final canGoToPreviousPage = ref.watch(canGoToPreviousPageProvider);\n\n    void goToPreviousPage() {\n      ref.read(pageIndexProvider.notifier).goToPreviousPage();\n    }\n\n    return ElevatedButton(\n      onPressed: canGoToPreviousPage ? goToPreviousPage : null,\n      child: const Text('previous'),\n    );\n  }\n}\n\n```\n\nBy doing this small refactoring, our `PreviousButton` widget will no longer\nrebuild when the page index changes thanks to `Provider`.\n\nFrom now on when the page index changes, our `canGoToPreviousPageProvider` provider\nwill be recomputed. But if the value exposed by the provider does not change,\nthen `PreviousButton` will not rebuild.\n\nThis change both improved the performance of our button and had the interesting\nbenefit of extracting the logic outside of our widget.\n\n- [Using `Provider` to cache computations](#using-provider-to-cache-computations)\n- [Reducing provider/widget rebuilds by using `Provider`](#reducing-providerwidget-rebuilds-by-using-provider)",
    "metadata": {
      "url": "https://riverpod.dev/docs/providers/provider",
      "ogUrl": "https://riverpod.dev/docs/providers/provider",
      "title": "Provider | Riverpod",
      "og:url": "https://riverpod.dev/docs/providers/provider",
      "ogImage": "https://riverpod.dev/img/cover.png",
      "ogTitle": "Provider | Riverpod",
      "language": "en",
      "og:image": "https://riverpod.dev/img/cover.png",
      "og:title": "Provider | Riverpod",
      "viewport": "width=device-width, initial-scale=1.0",
      "generator": "Docusaurus v2.4.3",
      "sourceURL": "https://riverpod.dev/docs/providers/provider",
      "statusCode": 200,
      "description": "The content of this page may be outdated.",
      "twitter:card": "summary_large_image",
      "ogDescription": "The content of this page may be outdated.",
      "twitter:image": "https://riverpod.dev/img/cover.png",
      "docusaurus_tag": "docs-default-current",
      "og:description": "The content of this page may be outdated.",
      "docsearch:version": "current",
      "docusaurus_locale": "en",
      "ogLocaleAlternate": [],
      "docsearch:language": "en",
      "docusaurus_version": "current",
      "docsearch:docusaurus_tag": "docs-default-current"
    }
  },
  {
    "markdown": "[Skip to main content](#__docusaurus_skipToContent_fallback)\n\nOn this page\n\ncaution\n\nThe content of this page may be outdated.\n\nIt will be updated in the future, but for now you may want to refer to the content\nin the top of the sidebar instead (introduction/essentials/case-studies/...)\n\nBefore reading this, consider reading about [Providers](/docs/concepts/providers) and [Reading a Provider](/docs/concepts/reading).\nIn this part, we will talk in detail about the `.family` provider modifier.\n\nThe `.family` modifier has one purpose: Getting a unique provider based on external parameters.\n\nSome common use-cases for `family` would be:\n\n- Combining [FutureProvider](/docs/providers/future_provider) with `.family` to fetch a `Message` from its ID\n- Passing the current `Locale` to a provider, so that we can handle translations\n\n## Usage [​](\\#usage \"Direct link to Usage\")\n\nThe way families works is by adding an extra parameter to the provider.\nThis parameter can then be freely used in our provider to create some state.\n\nFor example, we can combine `family` with [FutureProvider](/docs/providers/future_provider) to fetch\na `Message` from its ID:\n\n```codeBlockLines_e6Vv\nfinal messagesFamily = FutureProvider.family<Message, String>((ref, id) async {\n  return dio.get('http://my_api.dev/messages/$id');\n});\n\n```\n\nWhen using our `messagesFamily` provider, the syntax is slightly different.\n\nThe usual syntax will not work anymore:\n\n```codeBlockLines_e6Vv\nWidget build(BuildContext context, WidgetRef ref) {\n  // Error – messagesFamily is not a provider\n  final response = ref.watch(messagesFamily);\n}\n\n```\n\nInstead, we need to pass a parameter to `messagesFamily`:\n\n```codeBlockLines_e6Vv\nWidget build(BuildContext context, WidgetRef ref) {\n  final response = ref.watch(messagesFamily('id'));\n}\n\n```\n\ninfo\n\nIt is possible to use a family with different parameters simultaneously.\n\nFor example, we could use a `titleFamily` to read both the French and English\ntranslations at the same time:\n\n```codeBlockLines_e6Vv\n@override\nWidget build(BuildContext context, WidgetRef ref) {\n  final frenchTitle = ref.watch(titleFamily(const Locale('fr')));\n  final englishTitle = ref.watch(titleFamily(const Locale('en')));\n\n  return Text('fr: $frenchTitle en: $englishTitle');\n}\n\n```\n\n## Parameter restrictions [​](\\#parameter-restrictions \"Direct link to Parameter restrictions\")\n\nFor families to work correctly, it is critical for the parameter passed to\na provider to have a consistent `hashCode` and `==`.\n\nIdeally, the parameter should either be a primitive (bool/int/double/String),\na constant (providers), or an immutable object that overrides `==` and `hashCode`.\n\n### _PREFER_ using `autoDispose` when the parameter is not constant: [​](\\#prefer-using-autodispose-when-the-parameter-is-not-constant \"Direct link to prefer-using-autodispose-when-the-parameter-is-not-constant\")\n\nYou may want to use families to pass the input of a search field to your provider.\nBut that value can change often and never be reused.\n\nThis could cause memory leaks as, by default, a provider is never destroyed even\nif no longer used.\n\nUsing both `.family` and `.autoDispose` fixes that memory leak:\n\n```codeBlockLines_e6Vv\nfinal characters = FutureProvider.autoDispose.family<List<Character>, String>((ref, filter) async {\n  return fetchCharacters(filter: filter);\n});\n\n```\n\n## Passing multiple parameters to a family [​](\\#passing-multiple-parameters-to-a-family \"Direct link to Passing multiple parameters to a family\")\n\nFamilies have no built-in support for passing multiple values to a provider.\n\nOn the other hand, that value could be _anything_ (as long as it matches with\nthe restrictions mentioned previously).\n\nThis includes:\n\n- A tuple from [tuple](http://pub.dev/packages/tuple)\n- Objects generated with [Freezed](https://pub.dev/packages/freezed) or [built\\_value](https://pub.dev/packages/built_value)\n- Objects using [equatable](https://pub.dev/packages/equatable)\n\nHere's an example of using [Freezed](https://pub.dev/packages/freezed) or [equatable](https://pub.dev/packages/equatable) for multiple parameters:\n\n- Freezed\n- Equatable\n\n```codeBlockLines_e6Vv\n@freezed\nabstract class MyParameter with _$MyParameter {\n  factory MyParameter({\n    required int userId,\n    required Locale locale,\n  }) = _MyParameter;\n}\n\nfinal exampleProvider = Provider.autoDispose.family<Something, MyParameter>((ref, myParameter) {\n  print(myParameter.userId);\n  print(myParameter.locale);\n  // Do something with userId/locale\n});\n\n@override\nWidget build(BuildContext context, WidgetRef ref) {\n  int userId; // Read the user ID from somewhere\n  final locale = Localizations.localeOf(context);\n\n  final something = ref.watch(\n    exampleProvider(MyParameter(userId: userId, locale: locale)),\n  );\n\n  ...\n}\n\n```\n\n```codeBlockLines_e6Vv\nclass MyParameter extends Equatable  {\n  MyParameter({\n    required this.userId,\n    required this.locale,\n  });\n\n  final int userId;\n  final Locale locale;\n\n  @override\n  List<Object> get props => [userId, locale];\n}\n\nfinal exampleProvider = Provider.family<Something, MyParameter>((ref, myParameter) {\n  print(myParameter.userId);\n  print(myParameter.locale);\n  // Do something with userId/locale\n});\n\n@override\nWidget build(BuildContext context, WidgetRef ref) {\n  int userId; // Read the user ID from somewhere\n  final locale = Localizations.localeOf(context);\n\n  final something = ref.watch(\n    exampleProvider(MyParameter(userId: userId, locale: locale)),\n  );\n\n  ...\n}\n\n```\n\n- [Usage](#usage)\n- [Parameter restrictions](#parameter-restrictions)\n  - [_PREFER_ using `autoDispose` when the parameter is not constant:](#prefer-using-autodispose-when-the-parameter-is-not-constant)\n- [Passing multiple parameters to a family](#passing-multiple-parameters-to-a-family)",
    "metadata": {
      "url": "https://riverpod.dev/docs/concepts/modifiers/family",
      "ogUrl": "https://riverpod.dev/docs/concepts/modifiers/family",
      "title": ".family | Riverpod",
      "og:url": "https://riverpod.dev/docs/concepts/modifiers/family",
      "ogImage": "https://riverpod.dev/img/cover.png",
      "ogTitle": ".family | Riverpod",
      "language": "en",
      "og:image": "https://riverpod.dev/img/cover.png",
      "og:title": ".family | Riverpod",
      "viewport": "width=device-width, initial-scale=1.0",
      "generator": "Docusaurus v2.4.3",
      "sourceURL": "https://riverpod.dev/docs/concepts/modifiers/family",
      "statusCode": 200,
      "description": "The content of this page may be outdated.",
      "twitter:card": "summary_large_image",
      "ogDescription": "The content of this page may be outdated.",
      "twitter:image": "https://riverpod.dev/img/cover.png",
      "docusaurus_tag": "docs-default-current",
      "og:description": "The content of this page may be outdated.",
      "docsearch:version": "current",
      "docusaurus_locale": "en",
      "ogLocaleAlternate": [],
      "docsearch:language": "en",
      "docusaurus_version": "current",
      "docsearch:docusaurus_tag": "docs-default-current"
    }
  },
  {
    "markdown": "[Skip to main content](#__docusaurus_skipToContent_fallback)\n\nOn this page\n\ncaution\n\nThe content of this page may be outdated.\n\nIt will be updated in the future, but for now you may want to refer to the content\nin the top of the sidebar instead (introduction/essentials/case-studies/...)\n\n`FutureProvider` is the equivalent of [Provider](/docs/providers/provider) but for asynchronous code.\n\n`FutureProvider` is typically used for:\n\n- performing and caching asynchronous operations (such as network requests)\n- nicely handling error/loading states of asynchronous operations\n- combining multiple asynchronous values into another value\n\n`FutureProvider` gains a lot when combined with [ref.watch](/docs/concepts/reading#using-refwatch-to-observe-a-provider). This combination\nallows automatic re-fetching of some data when some variables change,\nensuring that we always have the most up-to-date value.\n\ninfo\n\n`FutureProvider` does not offer a way of directly modifying the computation after\na user interaction. It is designed to solve simple use-cases.\n\nFor more advanced scenarios, consider using [AsyncNotifierProvider](/docs/providers/notifier_provider).\n\n## Usage example: reading a configuration file [​](\\#usage-example-reading-a-configuration-file \"Direct link to Usage example: reading a configuration file\")\n\n`FutureProvider` can be a convenient way to expose a `Configuration` object\ncreated by reading a JSON file.\n\nCreating the configuration would be done with your typical async/await\nsyntax, but inside the provider.\nUsing Flutter's asset system, this would be:\n\n```codeBlockLines_e6Vv\n\n@riverpod\nFuture<Configuration> fetchConfiguration(Ref ref) async {\n  final content = json.decode(\n    await rootBundle.loadString('assets/configurations.json'),\n  ) as Map<String, Object?>;\n\n  return Configuration.fromJson(content);\n}\n\n```\n\nThen, the UI can listen to configurations like so:\n\n```codeBlockLines_e6Vv\n\nWidget build(BuildContext context, WidgetRef ref) {\n  final config = ref.watch(fetchConfigurationProvider);\n\n  return switch (config) {\n    AsyncError(:final error) => Text('Error: $error'),\n    AsyncData(:final value) => Text(value.host),\n    _ => const CircularProgressIndicator(),\n  };\n}\n\n```\n\nThis will automatically rebuild the UI when the [Future](https://api.dart.dev/dart-async/Future-class.html) completes.\nAt the same time, if multiple widgets want the configurations,\nthe asset will be decoded only once.\n\nAs you can see, listening to a `FutureProvider` inside a widget returns\nan [AsyncValue](https://pub.dev/documentation/riverpod/latest/riverpod/AsyncValue-class.html) – which allows handling the error/loading states.\n\n- [Usage example: reading a configuration file](#usage-example-reading-a-configuration-file)",
    "metadata": {
      "url": "https://riverpod.dev/docs/providers/future_provider",
      "ogUrl": "https://riverpod.dev/docs/providers/future_provider",
      "title": "FutureProvider | Riverpod",
      "og:url": "https://riverpod.dev/docs/providers/future_provider",
      "ogImage": "https://riverpod.dev/img/cover.png",
      "ogTitle": "FutureProvider | Riverpod",
      "language": "en",
      "og:image": "https://riverpod.dev/img/cover.png",
      "og:title": "FutureProvider | Riverpod",
      "viewport": "width=device-width, initial-scale=1.0",
      "generator": "Docusaurus v2.4.3",
      "sourceURL": "https://riverpod.dev/docs/providers/future_provider",
      "statusCode": 200,
      "description": "The content of this page may be outdated.",
      "twitter:card": "summary_large_image",
      "ogDescription": "The content of this page may be outdated.",
      "twitter:image": "https://riverpod.dev/img/cover.png",
      "docusaurus_tag": "docs-default-current",
      "og:description": "The content of this page may be outdated.",
      "docsearch:version": "current",
      "docusaurus_locale": "en",
      "ogLocaleAlternate": [],
      "docsearch:language": "en",
      "docusaurus_version": "current",
      "docsearch:docusaurus_tag": "docs-default-current"
    }
  },
  {
    "markdown": "[Skip to main content](#__docusaurus_skipToContent_fallback)\n\nOn this page\n\nTo ensure good maintainability of your code, here is a list of good practices\nyou should follow when using Riverpod.\n\nThis list is not exhaustive, and is subject to change.\n\nIf you have any suggestions, feel free to [open an issue](https://github.com/rrousselGit/riverpod/issues/new?assignees=rrousselGit&labels=documentation%2C+needs+triage&projects=&template=example_request.md&title=).\n\nItems in this list are not in any particular order.\n\nA good portion of these recommendations can be enforced with [riverpod\\_lint](https://pub.dev/packages/riverpod_lint).\nSee [Getting started](/docs/introduction/getting_started#enabling-riverpod_lintcustom_lint)\nfor installation instructions.\n\n## AVOID initializing providers in a widget [​](\\#avoid-initializing-providers-in-a-widget \"Direct link to AVOID initializing providers in a widget\")\n\nProviders should initialize themselves.\n\nThey should not be initialized by an external element such as a widget.\n\nFailing to do so could cause possible race conditions and unexpected behaviors.\n\n**DON'T**\n\n```codeBlockLines_e6Vv\nclass WidgetState extends State<MyWidget> {\n  @override\n  void initState() {\n    super.initState();\n    // Bad: the provider should initialize itself\n    ref.read(provider).init();\n  }\n}\n\n```\n\n**CONSIDER**\n\nThere is no \"one-size fits all\" solution to this problem.\n\nIf your initialization logic depends on factors external to the provider,\noften the correct place to put such logic is in the `onPressed` method of a button\ntriggering navigation:\n\n```codeBlockLines_e6Vv\nElevatedButton(\n  onPressed: () {\n    ref.read(provider).init();\n    Navigator.of(context).push(...);\n  },\n  child: Text('Navigate'),\n)\n\n```\n\n## AVOID using providers for Ephemeral state. [​](\\#avoid-using-providers-for-ephemeral-state \"Direct link to AVOID using providers for Ephemeral state.\")\n\nProviders are designed to be for shared business state.\nThey are not meant to be used for [Ephemeral state](https://docs.flutter.dev/data-and-backend/state-mgmt/ephemeral-vs-app#ephemeral-state), such as for:\n\n- storing form state\n- currently selected item\n- animations\n- generally everything that Flutter deals with a \"controller\" (e.g. `TextEditingController`)\n\nIf you are looking for a way to handle local widget state, consider using\n[flutter\\_hooks](https://pub.dev/packages/flutter_hooks) instead.\n\nOne reason why this is discouraged is that such state is often scoped to a route.\n\nFailing to do so could break your app's back button, due to a new page overriding\nthe state of a previous page.\n\n## DON'T perform side effects during the initialization of a provider [​](\\#dont-perform-side-effects-during-the-initialization-of-a-provider \"Direct link to DON'T perform side effects during the initialization of a provider\")\n\nProviders should generally be used to represent a \"read\" operation.\nYou should not use them for \"write\" operations, such as submitting a form.\n\nUsing providers for such operations could have unexpected behaviors, such as\nskipping a side-effect if a previous one was performed.\n\nIf you are looking at a way to handle loading/error states of a side-effect,\nsee [Performing side effects](/docs/essentials/side_effects).\n\n**DON'T**:\n\n```codeBlockLines_e6Vv\nfinal submitProvider = FutureProvider((ref) async {\n  final formState = ref.watch(formState);\n\n  // Bad: Providers should not be used for \"write\" operations.\n  return http.post('https://my-api.com', body: formState.toJson());\n});\n\n```\n\n## PREFER ref.watch/read/listen (and similar APIs) with statically known providers [​](\\#prefer-refwatchreadlisten-and-similar-apis-with-statically-known-providers \"Direct link to PREFER ref.watch/read/listen (and similar APIs) with statically known providers\")\n\nRiverpod strongly recommends enabling lint rules (via `riverpod_lint`).\n\nBut for lints to be effective, your code should be written in a way that is\nstatically analysable.\n\nFailing to do so could make it harder to spot bugs or cause\nfalse positives with lints.\n\n**Do**:\n\n```codeBlockLines_e6Vv\nfinal provider = Provider((ref) => 42);\n\n...\n\n// OK because the provider is known statically\nref.watch(provider);\n\n```\n\n**Don't**:\n\n```codeBlockLines_e6Vv\nclass Example extends ConsumerWidget {\n  Example({required this.provider});\n  final Provider<int> provider;\n\n  @override\n  Widget build(context, ref) {\n    // Bad because static analysis cannot know what `provider` is\n    ref.watch(provider);\n  }\n}\n\n```\n\n## AVOID dynamically creating providers [​](\\#avoid-dynamically-creating-providers \"Direct link to AVOID dynamically creating providers\")\n\nProviders should exclusively be top-level final variables.\n\n**Do**:\n\n```codeBlockLines_e6Vv\nfinal provider = Provider<String>((ref) => 'Hello world');\n\n```\n\n**Don't**:\n\n```codeBlockLines_e6Vv\nclass Example {\n  // Unsupported operation. Could cause memory leaks and unexpected behaviors.\n  final provider = Provider<String>((ref) => 'Hello world');\n}\n\n```\n\ninfo\n\nCreating providers as static final variables is allowed,\nbut not supported by the code-generator.\n\n- [AVOID initializing providers in a widget](#avoid-initializing-providers-in-a-widget)\n- [AVOID using providers for Ephemeral state.](#avoid-using-providers-for-ephemeral-state)\n- [DON'T perform side effects during the initialization of a provider](#dont-perform-side-effects-during-the-initialization-of-a-provider)\n- [PREFER ref.watch/read/listen (and similar APIs) with statically known providers](#prefer-refwatchreadlisten-and-similar-apis-with-statically-known-providers)\n- [AVOID dynamically creating providers](#avoid-dynamically-creating-providers)",
    "metadata": {
      "url": "https://riverpod.dev/docs/essentials/do_dont",
      "ogUrl": "https://riverpod.dev/docs/essentials/do_dont",
      "title": "DO/DON'T | Riverpod",
      "og:url": "https://riverpod.dev/docs/essentials/do_dont",
      "ogImage": "https://riverpod.dev/img/cover.png",
      "ogTitle": "DO/DON'T | Riverpod",
      "language": "en",
      "og:image": "https://riverpod.dev/img/cover.png",
      "og:title": "DO/DON'T | Riverpod",
      "viewport": "width=device-width, initial-scale=1.0",
      "generator": "Docusaurus v2.4.3",
      "sourceURL": "https://riverpod.dev/docs/essentials/do_dont",
      "statusCode": 200,
      "description": "To ensure good maintainability of your code, here is a list of good practices",
      "twitter:card": "summary_large_image",
      "ogDescription": "To ensure good maintainability of your code, here is a list of good practices",
      "twitter:image": "https://riverpod.dev/img/cover.png",
      "docusaurus_tag": "docs-default-current",
      "og:description": "To ensure good maintainability of your code, here is a list of good practices",
      "docsearch:version": "current",
      "docusaurus_locale": "en",
      "ogLocaleAlternate": [],
      "docsearch:language": "en",
      "docusaurus_version": "current",
      "docsearch:docusaurus_tag": "docs-default-current"
    }
  },
  {
    "markdown": "[Skip to main content](#__docusaurus_skipToContent_fallback)\n\nOn this page\n\nHere are some commonly asked questions from the community:\n\n## What is the difference between `ref.refresh` and `ref.invalidate`? [​](\\#what-is-the-difference-between-refrefresh-and-refinvalidate \"Direct link to what-is-the-difference-between-refrefresh-and-refinvalidate\")\n\nYou may have noticed that `ref` has two methods to force a provider to recompute,\nand wonder how they differ.\n\nIt's simpler than you think: `ref.refresh` is nothing but syntax sugar for\n`invalidate` \\+ `read`:\n\n```codeBlockLines_e6Vv\nT refresh<T>(provider) {\n  invalidate(provider);\n  return read(provider);\n}\n\n```\n\nIf you do not care about the new value of a provider after recomputing it,\nthen `invalidate` is the way to go.\n\nIf you do, use `refresh` instead.\n\ninfo\n\nThis logic is automatically enforced through lint rules.\n\nIf you tried to use `ref.refresh` without using the returned value,\nyou would get a warning.\n\nThe main difference in behavior is by reading the provider right\nafter invalidating it, the provider **immediately** recomputes.\n\nWhereas if we call `invalidate` but don't read it right after,\nthen the update will trigger _later_.\n\nThat \"later\" update is generally at the start of the next frame.\nYet, if a provider that is currently not being listened to is invalidated,\nit will not be updated until it is listened to again.\n\n## Why is there no shared interface between Ref and WidgetRef? [​](\\#why-is-there-no-shared-interface-between-ref-and-widgetref \"Direct link to Why is there no shared interface between Ref and WidgetRef?\")\n\nRiverpod voluntarily dissociates `Ref` and `WidgetRef`.\n\nThis is done on purpose to avoid writing code which conditionally\ndepends on one or the other.\n\nOne issue is that `Ref` and `WidgetRef`, although similar looking,\nhave subtle differences.\n\nCode relying on both would be unreliable in ways that are difficult to spot.\n\nAt the same time, relying on `WidgetRef` is equivalent to relying on `BuildContext`.\nIt is effectively putting your logic in the UI layer, which is not recommended.\n\n* * *\n\nSuch code should be refactored to **always** use `Ref`.\n\nThe solution to this problem is typically to move your logic\ninto a `Notifier` (see [Performing side effects](/docs/essentials/side_effects)),\nand then have your logic be a method of that `Notifier`.\n\nThis way, when your widgets want to invoke this logic, they can\nwrite something along the lines of:\n\n```codeBlockLines_e6Vv\nref.read(yourNotifierProvider.notifier).yourMethod();\n\n```\n\n`yourMethod` would use the `Notifier`'s `Ref` to interact with other providers.\n\n## Why do we need to extend ConsumerWidget instead of using the raw StatelessWidget? [​](\\#why-do-we-need-to-extend-consumerwidget-instead-of-using-the-raw-statelesswidget \"Direct link to Why do we need to extend ConsumerWidget instead of using the raw StatelessWidget?\")\n\nThis is due to an unfortunate limitation in the API of `InheritedWidget`.\n\nThere are a few problems:\n\n- It is not possible to implement an \"on change\" listener with `InheritedWidget`.\nThat means that something such as `ref.listen` cannot be used with `BuildContext`.\n\n`State.didChangeDependencies` is the closest thing to it, but it is not reliable.\nOne issue is that the life-cycle can be triggered even if no dependency changed,\nespecially if your widget tree uses GlobalKeys (and some Flutter widgets already do so internally).\n\n- Widgets listening to an `InheritedWidget` never stop listening to it.\nThis is usually fine for pure metadata, such as \"theme\" or \"media query\".\n\nFor business logic, this is a problem.\nSay you use a provider to represent a paginated API.\nWhen the page offset changes, you wouldn't want your widget to keep listening\nto the previously visible pages.\n\n- `InheritedWidget` has no way to track when widgets stop listening to them.\nRiverpod sometimes relies on tracking whether or not a provider is being listened to.\n\n\nThis functionality is crucial for both the auto dispose mechanism and the ability to\npass arguments to providers.\n\nThose features are what make Riverpod so powerful.\n\nMaybe in a distant future, those issues will be fixed. In that case,\nRiverpod would migrate to using `BuildContext` instead of `Ref`.\nThis would enable using `StatelessWidget` instead of `ConsumerWidget`.\n\nBut that's for another time!\n\n## Why doesn't hooks\\_riverpod exports flutter\\_hooks? [​](\\#why-doesnt-hooks_riverpod-exports-flutter_hooks \"Direct link to Why doesn't hooks_riverpod exports flutter_hooks?\")\n\nThis is to respect good versioning practices.\n\nWhile you cannot use `hooks_riverpod` without `flutter_hooks`,\nboth packages are versioned independently. A breaking change could happen\nin one but not the other.\n\n## Why does Riverpod use `identical` instead of `==` to filter updates in some cases? [​](\\#why-does-riverpod-use-identical-instead-of--to-filter-updates-in-some-cases \"Direct link to why-does-riverpod-use-identical-instead-of--to-filter-updates-in-some-cases\")\n\nNotifiers use `identical` instead of `==` to filter updates.\n\nThis is because it is quite common for Riverpod users to also use a code-generator\nsuch as Freezed/built\\_value for the sake of a copyWith implementation. Those packages\noverride `==` to deeply compare objects. A deep object comparison is quite costly.\n\"Business logic\" models tend to have lots of properties. Worse, they also have collections\nsuch as lists, maps, and so on.\n\nAt the same time, when using complex \"business\" objects, most `state = newState` invocations\nalways result in a notification (otherwise there is no point in calling the setter). Generally, the main\ncase where we call `state = newState` when the current state and new states are equal is\nfor primitive objects (ints, enums, strings, but not lists/classes/...).\nThese objects are \"canonicalized by default\". If such objects are equal,\nthey generally are also \"identical\".\n\nRiverpod using `identical` to filter updates is therefore an attempt at having\na good default for both worlds. For complex objects where we don't really care\nabout filtering objects and where `==` may be expensive due to code-generators\ngenerating an `==` override by default, using `identical` provides an efficient way of notifying listeners.\nAt the same time, for simple objects, `identical` does correctly filter redundant notifications.\n\nLast but not least, you can change this behavior by overriding the method\n`updateShouldNotify` on Notifiers.\n\n## Is there a way to reset all providers at once? [​](\\#is-there-a-way-to-reset-all-providers-at-once \"Direct link to Is there a way to reset all providers at once?\")\n\nNo, there is no way to reset all providers at once.\n\nThis is on purpose, as it is considered an anti-pattern. Resetting all providers\nat once will often reset providers that you did not intend to reset.\n\nThis is commonly asked by users who want to reset the state of their application\nwhen the user logs out.\n\nIf this is what you are after, you should instead have everything dependent on the\nuser's state to `ref.watch` the \"user\" provider.\n\nThen, when the user logs out, all providers depending on it would automatically\nbe reset but everything else would remain untouched.\n\n## I have the error \"Cannot use \"ref\" after the widget was disposed\", what's wrong? [​](\\#i-have-the-error-cannot-use-ref-after-the-widget-was-disposed-whats-wrong \"Direct link to I have the error \\\"Cannot use \\\"ref\\\" after the widget was disposed\\\", what's wrong?\")\n\nYou might also see \"Bad state: No ProviderScope found\", which is an older\nerror message of the same issue.\n\nThis error happens when you try to use `ref` in a widget that is no longer\nmounted. This generally happens after an `await`:\n\n```codeBlockLines_e6Vv\nElevatedButton(\n  onPressed: () async {\n    await future;\n    ref.read(...); // May throw \"Cannot use \"ref\" after the widget was disposed\"\n  }\n)\n\n```\n\nThe solution is to, like with `BuildContext`, check `mounted` before using `ref`:\n\n```codeBlockLines_e6Vv\nElevatedButton(\n  onPressed: () async {\n    await future;\n    if (!context.mounted) return;\n    ref.read(...); // No longer throws\n  }\n)\n\n```\n\n- [What is the difference between `ref.refresh` and `ref.invalidate`?](#what-is-the-difference-between-refrefresh-and-refinvalidate)\n- [Why is there no shared interface between Ref and WidgetRef?](#why-is-there-no-shared-interface-between-ref-and-widgetref)\n- [Why do we need to extend ConsumerWidget instead of using the raw StatelessWidget?](#why-do-we-need-to-extend-consumerwidget-instead-of-using-the-raw-statelesswidget)\n- [Why doesn't hooks\\_riverpod exports flutter\\_hooks?](#why-doesnt-hooks_riverpod-exports-flutter_hooks)\n- [Why does Riverpod use `identical` instead of `==` to filter updates in some cases?](#why-does-riverpod-use-identical-instead-of--to-filter-updates-in-some-cases)\n- [Is there a way to reset all providers at once?](#is-there-a-way-to-reset-all-providers-at-once)\n- [I have the error \"Cannot use \"ref\" after the widget was disposed\", what's wrong?](#i-have-the-error-cannot-use-ref-after-the-widget-was-disposed-whats-wrong)",
    "metadata": {
      "url": "https://riverpod.dev/docs/essentials/faq",
      "ogUrl": "https://riverpod.dev/docs/essentials/faq",
      "title": "FAQ | Riverpod",
      "og:url": "https://riverpod.dev/docs/essentials/faq",
      "ogImage": "https://riverpod.dev/img/cover.png",
      "ogTitle": "FAQ | Riverpod",
      "language": "en",
      "og:image": "https://riverpod.dev/img/cover.png",
      "og:title": "FAQ | Riverpod",
      "viewport": "width=device-width, initial-scale=1.0",
      "generator": "Docusaurus v2.4.3",
      "sourceURL": "https://riverpod.dev/docs/essentials/faq",
      "statusCode": 200,
      "description": "Here are some commonly asked questions from the community:",
      "twitter:card": "summary_large_image",
      "ogDescription": "Here are some commonly asked questions from the community:",
      "twitter:image": "https://riverpod.dev/img/cover.png",
      "docusaurus_tag": "docs-default-current",
      "og:description": "Here are some commonly asked questions from the community:",
      "docsearch:version": "current",
      "docusaurus_locale": "en",
      "ogLocaleAlternate": [],
      "docsearch:language": "en",
      "docusaurus_version": "current",
      "docsearch:docusaurus_tag": "docs-default-current"
    }
  },
  {
    "markdown": "[Skip to main content](#__docusaurus_skipToContent_fallback)\n\nOn this page\n\nThis section is designed for people familiar with the [Provider](https://pub.dev/packages/provider) package who\nwants to learn about Riverpod.\n\nBefore anything, read the short [getting started](/docs/introduction/getting_started) article and try out the small\n[sandbox](https://dartpad.dev/?null_safety=true&id=ef06ab3ce0b822e6cc5db0575248e6e2) example to test Riverpod's features out. If you like what you see there, you should then\ndefinitively consider a migration.\n\nIndeed, migrating from Provider to Riverpod can be very straightforward.\n\nMigrating basically consists in a few steps that can be done in an _incremental_ way.\n\n## Start with `ChangeNotifierProvider` [​](\\#start-with-changenotifierprovider \"Direct link to start-with-changenotifierprovider\")\n\nIt's fine to keep using `ChangeNotifier` while transitioning towards Riverpod,\nand not use its latest fancy features ASAP.\n\nIndeed, the following is perfectly fine to start with:\n\n```codeBlockLines_e6Vv\n// If you have this...\nclass MyNotifier extends ChangeNotifier {\n  int state = 0;\n\n  void increment() {\n    state++;\n    notifyListeners();\n  }\n}\n\n// ... just add this!\nfinal myNotifierProvider = ChangeNotifierProvider<MyNotifier>((ref) {\n  return MyNotifier();\n});\n\n```\n\nAs you can see Riverpod exposes a [ChangeNotifierProvider](/docs/providers/change_notifier_provider) class,\nwhich is there precisely to support migrations from pkg:Provider.\n\nKeep in mind that this provider is not recommended when writing new code,\nand it is not the best way to use Riverpod, but it's a gentle and very easy way to start your migration.\n\ntip\n\nThere is no rush to _immediately_ try to change your `ChangeNotifier` s into the more modern [Riverpod's providers](/docs/providers/notifier_provider).\nSome require a bit of a paradigm shift, so it may be difficult to do initially.\n\nTake your time, as it is important to get yourself familiar with Riverpod first;\nyou'll quickly find out that _almost_ all Providers from pkg:provider have a strict equivalent in pkg:riverpod.\n\n## Starts with _leaves_ [​](\\#starts-with-leaves \"Direct link to starts-with-leaves\")\n\nStart with Providers that do not depend on anything else, i.e. start with the _leaves_ in your dependency tree.\n\nOnce you have migrated all of the leaves, you can then move on to the providers that depend on leaves.\n\nIn other words, avoid migrating `ProxyProvider` s at first; tackle them once all of their dependencies have been migrated.\n\nThis should boost and simplify the migration process, while also minimizing / tracking down any errors.\n\n## Riverpod and Provider can coexist [​](\\#riverpod-and-provider-can-coexist \"Direct link to Riverpod and Provider can coexist\")\n\n_Keep in mind that it is entirely possible to use both Provider and Riverpod at the same time._\n\nIndeed, using import aliases, it is possible to use the two APIs altogether.\n\nThis is also great for readability and it removes any ambiguous API usage.\n\nIf you plan on doing this, consider using import aliases for each Provider import in your codebase.\n\ninfo\n\nA full guide onto how to effectively implement import aliases is incoming soon.\n\n## You don't _have to_ use `Consumer` right away [​](\\#you-dont-have-to-use-consumer-right-away \"Direct link to you-dont-have-to-use-consumer-right-away\")\n\nIt's important to keep in mind that there is no need to _immediately_ use [Riverpod's `Consumer` APIs](/docs/concepts/reading).\n\nIf you've just started the migration, [as mentioned above](/docs/from_provider/quickstart#start-with-changenotifierprovider), you should probably start with `ChangeNotifierProvider`.\n\nConsider `myNotifierProvider`, defined above.\n\nSince your inner code is probably depending on pkg:Provider's APIs, use the following to start consuming `ChangeNotifier` s with pkg:Riverpod.\n\n```codeBlockLines_e6Vv\nMultiProvider(\n  providers: [\\\n    ChangeNotifierProvider.value(value: ref.watch(myNotifierProvider.notifier)),\\\n  ]\n)\n\n```\n\nThis way, only the root Widget has to be initially converted into a `ConsumerWidget`.\n\nThis should ease the migration towards pkg:Riverpod even more.\n\n## Migrate one Provider at a time [​](\\#migrate-one-provider-at-a-time \"Direct link to Migrate one Provider at a time\")\n\nIf you have an existing app, don't try to migrate all your providers at once!\n\nWhile you should strive toward moving all your application to Riverpod in the long-run,\n**don't burn yourself out**.\n\nDo it one provider at a time.\n\nTake the above example. **Fully** migrating that `myNotifierProvider` to Riverpod means writing the following:\n\n```codeBlockLines_e6Vv\nclass MyNotifier extends Notifier<int> {\n  @override\n  int build() => 0;\n\n  void increment() => state++;\n}\n\nfinal myNotifierProvider = NotifierProvider<MyNotifier, int>(MyNotifier.new);\n\n```\n\n.. and it's _also_ needed to change how that provider is consumed, i.e. writing `ref.watch` in the place of each `context.watch` for this provider.\n\nThis operation might take some time and might lead to some errors, so don't rush doing this all at once.\n\n## Migrating `ProxyProvider` s [​](\\#migrating-proxyproviders \"Direct link to migrating-proxyproviders\")\n\nWithin pkg:Provider, `ProxyProvider` is used to combine values from other Providers;\nits build depends on the value of other providers, reactively.\n\nWith Riverpod, instead, Providers [are composable by default](/docs/from_provider/motivation#combining-providers-is-hard-and-error-prone); therefore, when migrating a `ProxyProvider`\nyou'll simply need to write `ref.watch` if you want to declare a direct dependency from a Provider to another.\n\nIf anything, combining values with Riverpod should feel simpler and straightforward; thus, the migration should greatly\nsimplify your code.\n\nFurthermore, there are no shenanigans about combining more than two providers together:\njust add another `ref.watch` and you'll be good to go.\n\n## Eager initialization [​](\\#eager-initialization \"Direct link to Eager initialization\")\n\nSince Riverpod's providers are final global variables, they are [lazy by default](/docs/concepts/provider_lifecycles).\n\nIf you need to initialize some warm-up data or a useful service on startup,\nthe best way to do it is to first read your provider in the place where you used to put `MultiProvider`.\n\nIn other words, since Riverpod can't be forced to be eager initialized, they can be read and cached\nin your startup phase, so that they're warm and ready when needed inside the rest of your application.\n\nA full guide about eager initialization of pkg:Riverpod's providers [is available here](/docs/essentials/eager_initialization).\n\n## Code Generation [​](\\#code-generation \"Direct link to Code Generation\")\n\n[Code generation](/docs/concepts/about_code_generation) is recommended to use Riverpod the _future-proof_ way.\n\nAs a side note, chances are that when metaprogramming will be a thing, codegen will be default for Riverpod.\n\nUnluckily, `@riverpod` can't generate code for `ChangeNotifierProvider`.\n\nTo overcome this, you can use the following utility extesion method:\n\n```codeBlockLines_e6Vv\nextension ChangeNotifierWithCodeGenExtension on Ref {\n  T listenAndDisposeChangeNotifier<T extends ChangeNotifier>(T notifier) {\n    notifier.addListener(notifyListeners);\n    onDispose(() => notifier.removeListener(notifyListeners));\n    onDispose(notifier.dispose);\n    return notifier;\n  }\n}\n\n```\n\nAnd then, you can expose your `ChangeNotifier` with the following codegen syntax:\n\n```codeBlockLines_e6Vv\n// ignore_for_file: unsupported_provider_value\n@riverpod\nMyNotifier example(Ref ref) {\n  return ref.listenAndDisposeChangeNotifier(MyNotifier());\n}\n\n```\n\nOnce the \"base\" migration is done, you can change your `ChangeNotifier` to `Notifier`,\nthus eliminating the need for temporary extensions.\n\nTaking up the previous examples, a \"fully migrated\" `Notifier` becomes:\n\n```codeBlockLines_e6Vv\n@riverpod\nclass MyNotifier extends _$MyNotifier {\n  @override\n  int build() => 0;\n\n  void increment() => state++;\n}\n\n```\n\nOnce this is done, and you're positive that there are no more `ChangeNotifierProvider` s\nin your codebase, you can get rid of the temporary extension definitively.\n\nKeep in mind that, while being recommended, codegen is not _mandatory_.\n\nIt's good to reason about migrations incrementally:\nif you feel like that implementing this migration _while_ transitioning to\nthe code generation syntax in one single take might be too much, _that's fine_.\n\nFollowing this guide, you _can_ migrate towards codegen as a further step forward, later on.\n\n- [Start with `ChangeNotifierProvider`](#start-with-changenotifierprovider)\n- [Starts with _leaves_](#starts-with-leaves)\n- [Riverpod and Provider can coexist](#riverpod-and-provider-can-coexist)\n- [You don't _have to_ use `Consumer` right away](#you-dont-have-to-use-consumer-right-away)\n- [Migrate one Provider at a time](#migrate-one-provider-at-a-time)\n- [Migrating `ProxyProvider` s](#migrating-proxyproviders)\n- [Eager initialization](#eager-initialization)\n- [Code Generation](#code-generation)",
    "metadata": {
      "url": "https://riverpod.dev/docs/from_provider/quickstart",
      "ogUrl": "https://riverpod.dev/docs/from_provider/quickstart",
      "title": "Quickstart | Riverpod",
      "og:url": "https://riverpod.dev/docs/from_provider/quickstart",
      "ogImage": "https://riverpod.dev/img/cover.png",
      "ogTitle": "Quickstart | Riverpod",
      "language": "en",
      "og:image": "https://riverpod.dev/img/cover.png",
      "og:title": "Quickstart | Riverpod",
      "viewport": "width=device-width, initial-scale=1.0",
      "generator": "Docusaurus v2.4.3",
      "sourceURL": "https://riverpod.dev/docs/from_provider/quickstart",
      "statusCode": 200,
      "description": "This section is designed for people familiar with the [Provider] package who",
      "twitter:card": "summary_large_image",
      "ogDescription": "This section is designed for people familiar with the [Provider] package who",
      "twitter:image": "https://riverpod.dev/img/cover.png",
      "docusaurus_tag": "docs-default-current",
      "og:description": "This section is designed for people familiar with the [Provider] package who",
      "docsearch:version": "current",
      "docusaurus_locale": "en",
      "ogLocaleAlternate": [],
      "docsearch:language": "en",
      "docusaurus_version": "current",
      "docsearch:docusaurus_tag": "docs-default-current"
    }
  },
  {
    "markdown": "[Skip to main content](#__docusaurus_skipToContent_fallback)\n\nOn this page\n\ncaution\n\nThe content of this page may be outdated.\n\nIt will be updated in the future, but for now you may want to refer to the content\nin the top of the sidebar instead (introduction/essentials/case-studies/...)\n\nA common use case is to destroy the state of a provider\nwhen it is no-longer used.\n\nThere are multiple reasons for doing so, such as:\n\n- When using Firebase, to close the connection and avoid unnecessary cost.\n- To reset the state when the user leaves a screen and re-enters it.\n\nProviders come with built-in support for this use case, through the `.autoDispose`\nmodifier.\n\n## Usage [​](\\#usage \"Direct link to Usage\")\n\nTo tell Riverpod to destroy the state of a provider when it is no longer used,\nsimply append `.autoDispose` to your provider:\n\n```codeBlockLines_e6Vv\nfinal userProvider = StreamProvider.autoDispose<User>((ref) {\n\n});\n\n```\n\nThat's it. Now, the state of `userProvider` will automatically be destroyed\nwhen it is no longer used.\n\nNote how the generic parameters are passed after `autoDispose` instead of before –\n`autoDispose` is not a named constructor.\n\nnote\n\nYou can combine `.autoDispose` with other modifiers if you need to:\n\n```codeBlockLines_e6Vv\nfinal userProvider = StreamProvider.autoDispose.family<User, String>((ref, id) {\n\n});\n\n```\n\n### ref.keepAlive [​](\\#refkeepalive \"Direct link to ref.keepAlive\")\n\nMarking a provider with `autoDispose` also adds an extra method on `ref`: `keepAlive`.\n\nThe `keepAlive` function is used to tell Riverpod that the state of the provider\nshould be preserved even if no longer listened to.\n\nA use-case would be to set this flag to `true` after an HTTP request has\ncompleted:\n\n```codeBlockLines_e6Vv\nfinal myProvider = FutureProvider.autoDispose((ref) async {\n  final response = await httpClient.get(...);\n  ref.keepAlive();\n  return response;\n});\n\n```\n\nThis way, if the request fails and the user leaves the screen then re-enters\nit, then the request will be performed again.\nBut if the request completed successfully, the state will be preserved\nand re-entering the screen will not trigger a new request.\n\ninfo\n\nIn version 1.0.x, the equivalent of `keepAlive` is the property called `maintainState`.\n\n## Example: Canceling HTTP requests when no longer used [​](\\#example-canceling-http-requests-when-no-longer-used \"Direct link to Example: Canceling HTTP requests when no longer used\")\n\nThe `autoDispose` modifier could be combined with [FutureProvider](/docs/providers/future_provider) and `ref.onDispose`\nto easily cancel HTTP requests when they are no longer needed.\n\nThe goal is:\n\n- Start an HTTP request when the user enters a screen\n- if the user leaves the screen before the request completed, cancel the HTTP request\n- if the request succeeded, leaving and re-entering the screen does not start a new request\n\nIn code, this would be:\n\n```codeBlockLines_e6Vv\nfinal myProvider = FutureProvider.autoDispose((ref) async {\n  // An object from package:dio that allows cancelling http requests\n  final cancelToken = CancelToken();\n  // When the provider is destroyed, cancel the http request\n  ref.onDispose(() => cancelToken.cancel());\n\n  // Fetch our data and pass our `cancelToken` for cancellation to work\n  final response = await dio.get('path', cancelToken: cancelToken);\n  // If the request completed successfully, keep the state\n  ref.keepAlive();\n  return response;\n});\n\n```\n\n## The argument type 'AutoDisposeProvider' can't be assigned to the parameter type 'AlwaysAliveProviderBase' [​](\\#the-argument-type-autodisposeprovider-cant-be-assigned-to-the-parameter-type-alwaysaliveproviderbase \"Direct link to The argument type 'AutoDisposeProvider' can't be assigned to the parameter type 'AlwaysAliveProviderBase'\")\n\nWhen using `.autoDispose`, you may find yourself in a situation where your\napplication does not compile with an error similar to:\n\n> The argument type 'AutoDisposeProvider' can't be assigned to the parameter\n> type 'AlwaysAliveProviderBase'\n\nDon't worry! This error is voluntary. It happens because you most likely\nhave a bug:\n\nYou tried to listen to a provider marked with `.autoDispose` in a provider that\nis **not** marked with `.autoDispose`, such as:\n\n```codeBlockLines_e6Vv\nfinal firstProvider = Provider.autoDispose((ref) => 0);\n\nfinal secondProvider = Provider((ref) {\n  // The argument type 'AutoDisposeProvider<int>' can't be assigned to the\n  // parameter type 'AlwaysAliveProviderBase<Object, Null>'\n  ref.watch(firstProvider);\n});\n\n```\n\nThis is undesired, as it would cause `firstProvider` to never be disposed.\n\nTo fix this, consider marking `secondProvider` with `.autoDispose` too:\n\n```codeBlockLines_e6Vv\nfinal firstProvider = Provider.autoDispose((ref) => 0);\n\nfinal secondProvider = Provider.autoDispose((ref) {\n  ref.watch(firstProvider);\n});\n\n```\n\n- [Usage](#usage)\n  - [ref.keepAlive](#refkeepalive)\n- [Example: Canceling HTTP requests when no longer used](#example-canceling-http-requests-when-no-longer-used)\n- [The argument type 'AutoDisposeProvider' can't be assigned to the parameter type 'AlwaysAliveProviderBase'](#the-argument-type-autodisposeprovider-cant-be-assigned-to-the-parameter-type-alwaysaliveproviderbase)",
    "metadata": {
      "url": "https://riverpod.dev/docs/concepts/modifiers/auto_dispose",
      "ogUrl": "https://riverpod.dev/docs/concepts/modifiers/auto_dispose",
      "title": ".autoDispose | Riverpod",
      "og:url": "https://riverpod.dev/docs/concepts/modifiers/auto_dispose",
      "ogImage": "https://riverpod.dev/img/cover.png",
      "ogTitle": ".autoDispose | Riverpod",
      "language": "en",
      "og:image": "https://riverpod.dev/img/cover.png",
      "og:title": ".autoDispose | Riverpod",
      "viewport": "width=device-width, initial-scale=1.0",
      "generator": "Docusaurus v2.4.3",
      "sourceURL": "https://riverpod.dev/docs/concepts/modifiers/auto_dispose",
      "statusCode": 200,
      "description": "The content of this page may be outdated.",
      "twitter:card": "summary_large_image",
      "ogDescription": "The content of this page may be outdated.",
      "twitter:image": "https://riverpod.dev/img/cover.png",
      "docusaurus_tag": "docs-default-current",
      "og:description": "The content of this page may be outdated.",
      "docsearch:version": "current",
      "docusaurus_locale": "en",
      "ogLocaleAlternate": [],
      "docsearch:language": "en",
      "docusaurus_version": "current",
      "docsearch:docusaurus_tag": "docs-default-current"
    }
  },
  {
    "markdown": "[Skip to main content](#__docusaurus_skipToContent_fallback)\n\nOn this page\n\nAfter a long wait, the first stable version of Riverpod is finally released 👏\n\nTo see the full list of changes, consult the [Changelog](https://pub.dev/packages/flutter_riverpod/changelog#100).\n\nIn this page, we will focus on how to migrate an existing Riverpod application\nfrom version 0.14.x to version 1.0.0.\n\n## Using the migration tool to automatically upgrade your project to the new syntax [​](\\#using-the-migration-tool-to-automatically-upgrade-your-project-to-the-new-syntax \"Direct link to Using the migration tool to automatically upgrade your project to the new syntax\")\n\nBefore explaining the various changes, it is worth noting that Riverpod comes with\na command-line tool to automatically migrate your project for you.\n\n### Installing the command line tool [​](\\#installing-the-command-line-tool \"Direct link to Installing the command line tool\")\n\nTo install the migration tool, run:\n\n```codeBlockLines_e6Vv\ndart pub global activate riverpod_cli\n\n```\n\nYou should now be able to run:\n\n```codeBlockLines_e6Vv\nriverpod --help\n\n```\n\n### Usage [​](\\#usage \"Direct link to Usage\")\n\nNow that the command line is installed, we can start using it.\n\n- First, open the project you want to migrate in your terminal.\n\n- **Do not** upgrade Riverpod.\n\n\nThe migration tool will upgrade the version of Riverpod for you.\n\n\n\ndanger\n\n\n\n\n\nNot upgrading Riverpod is important.\n\n\nThe tool will not execute properly if you have already installed version 1.0.0.\nAs such, make sure that you are properly using an older version before starting the tool.\n\n- Make sure that your project does not contain errors.\n\n- Execute:\n\n\n\n\n\n```codeBlockLines_e6Vv\nriverpod migrate\n\n```\n\n\nThe tool will then analyze your project and suggest changes. For example you may see:\n\n```codeBlockLines_e6Vv\n-Widget build(BuildContext context, ScopedReader watch) {\n+Widget build(BuildContext context, Widget ref) {\n-  MyModel state = watch(provider);\n+  MyModel state = ref.watch(provider);\n}\n\nAccept change (y = yes, n = no [default], A = yes to all, q = quit)?\n\n```\n\nTo accept the change, simply press `y`. Otherwise to reject it, press `n`.\n\n## The changes [​](\\#the-changes \"Direct link to The changes\")\n\nNow that we've seen how to use the CLI to automatically upgrade your project,\nlet's see in detail the changes necessary.\n\n### Syntax unification [​](\\#syntax-unification \"Direct link to Syntax unification\")\n\nVersion 1.0.0 of Riverpod focused on the unification of the syntax for\ninteracting with providers.\n\nBefore, Riverpod had many similar yet different syntaxes for reading a provider,\nsuch as `ref.watch(provider)` vs `useProvider(provider)` vs `watch(provider)`.\n\nWith version 1.0.0, only one syntax remains: `ref.watch(provider)`. The\nothers were removed.\n\nAs such:\n\n- `useProvider` is removed in favor of `HookConsumerWidget`.\n\nBefore:\n\n\n\n\n\n```codeBlockLines_e6Vv\nclass Example extends HookWidget {\n    @override\n    Widget build(BuildContext context) {\n      useState(...);\n      int count = useProvider(counterProvider);\n      ...\n    }\n}\n\n```\n\n\n\n\n\n\n\n\n\nAfter:\n\n\n\n\n\n```codeBlockLines_e6Vv\nclass Example extends HookConsumerWidget {\n    @override\n    Widget build(BuildContext context, WidgetRef ref) {\n      useState(...);\n      int count = ref.watch(counterProvider);\n      ...\n    }\n}\n\n```\n\n- The prototype of `ConsumerWidget`'s `build` and `Consumer`'s `builder` changed.\n\nBefore:\n\n\n\n\n\n```codeBlockLines_e6Vv\nclass Example extends ConsumerWidget {\n    @override\n    Widget build(BuildContext context, ScopedReader watch) {\n      int count = watch(counterProvider);\n      ...\n    }\n}\n\nConsumer(\n    builder: (context, watch, child) {\n      int count = watch(counterProvider);\n      ...\n    }\n)\n\n```\n\n\n\n\n\n\n\n\n\nAfter:\n\n\n\n\n\n```codeBlockLines_e6Vv\nclass Example extends ConsumerWidget {\n    @override\n    Widget build(BuildContext context, WidgetRef ref) {\n      int count = ref.watch(counterProvider);\n      ...\n    }\n}\n\nConsumer(\n    builder: (context, ref, child) {\n      int count = ref.watch(counterProvider);\n      ...\n    }\n)\n\n```\n\n- `context.read` is removed in favor of `ref.read`.\n\nBefore:\n\n\n\n\n\n```codeBlockLines_e6Vv\nclass Example extends StatelessWidget {\n    @override\n    Widget build(BuildContext context) {\n      SomeButton(\n        onPressed: () => context.read(provider.notifier).doSomething(),\n      );\n    }\n}\n\n```\n\n\n\n\n\n\n\n\n\nAfter:\n\n\n\n\n\n```codeBlockLines_e6Vv\nclass Example extends ConsumerWidget {\n    @override\n    Widget build(BuildContext context, WidgetRef ref) {\n      SomeButton(\n        onPressed: () => ref.read(provider.notifier).doSomething(),\n      );\n    }\n}\n\n```\n\n\n### StateProvider update [​](\\#stateprovider-update \"Direct link to StateProvider update\")\n\n[StateProvider](/docs/providers/state_provider) was updated to match [StateNotifierProvider](/docs/providers/state_notifier_provider).\n\nBefore, doing `ref.watch(StateProvider)` returned a `StateController` instance.\nNow it only returns the state of the `StateController`.\n\nTo migrate you have a few solutions.\n\nIf your code only obtained the state without modifying it, you can change from:\n\n```codeBlockLines_e6Vv\nfinal provider = StateProvider<int>(...);\n\nConsumer(\n  builder: (context, ref, child) {\n    StateController<int> count = ref.watch(provider);\n\n    return Text('${count.state}');\n  }\n)\n\n```\n\nto:\n\n```codeBlockLines_e6Vv\nfinal provider = StateProvider<int>(...);\n\nConsumer(\n  builder: (context, ref, child) {\n    int count = ref.watch(provider);\n\n    return Text('${count}');\n  }\n)\n\n```\n\nAlternatively you can use the new `StateProvider.state` to keep the old behavior.\n\n```codeBlockLines_e6Vv\nfinal provider = StateProvider<int>(...);\n\nConsumer(\n  builder: (context, ref, child) {\n    StateController<int> count = ref.watch(provider.state);\n\n    return Text('${count.state}');\n  }\n)\n\n```\n\n- [Using the migration tool to automatically upgrade your project to the new syntax](#using-the-migration-tool-to-automatically-upgrade-your-project-to-the-new-syntax)\n  - [Installing the command line tool](#installing-the-command-line-tool)\n  - [Usage](#usage)\n- [The changes](#the-changes)\n  - [Syntax unification](#syntax-unification)\n  - [StateProvider update](#stateprovider-update)",
    "metadata": {
      "url": "https://riverpod.dev/docs/migration/0.14.0_to_1.0.0",
      "ogUrl": "https://riverpod.dev/docs/migration/0.14.0_to_1.0.0",
      "title": "^0.14.0 to ^1.0.0 | Riverpod",
      "og:url": "https://riverpod.dev/docs/migration/0.14.0_to_1.0.0",
      "ogImage": "https://riverpod.dev/img/cover.png",
      "ogTitle": "^0.14.0 to ^1.0.0 | Riverpod",
      "language": "en",
      "og:image": "https://riverpod.dev/img/cover.png",
      "og:title": "^0.14.0 to ^1.0.0 | Riverpod",
      "viewport": "width=device-width, initial-scale=1.0",
      "generator": "Docusaurus v2.4.3",
      "sourceURL": "https://riverpod.dev/docs/migration/0.14.0_to_1.0.0",
      "statusCode": 200,
      "description": "After a long wait, the first stable version of Riverpod is finally released 👏",
      "twitter:card": "summary_large_image",
      "ogDescription": "After a long wait, the first stable version of Riverpod is finally released 👏",
      "twitter:image": "https://riverpod.dev/img/cover.png",
      "docusaurus_tag": "docs-default-current",
      "og:description": "After a long wait, the first stable version of Riverpod is finally released 👏",
      "docsearch:version": "current",
      "docusaurus_locale": "en",
      "ogLocaleAlternate": [],
      "docsearch:language": "en",
      "docusaurus_version": "current",
      "docsearch:docusaurus_tag": "docs-default-current"
    }
  },
  {
    "markdown": "[Skip to main content](#__docusaurus_skipToContent_fallback)\n\nOn this page\n\ncaution\n\nThe content of this page may be outdated.\n\nIt will be updated in the future, but for now you may want to refer to the content\nin the top of the sidebar instead (introduction/essentials/case-studies/...)\n\n## What is Immutability? [​](\\#what-is-immutability \"Direct link to What is Immutability?\")\n\nImmutability is when all fields of an `Object` are final or late final.\nThey are set exactly once upon construction.\n\nImmutability is desireable for many different reasons\n\n- Value equality rather than reference equality\n- Local reasoning about a piece of code\n  - A far distant piece of code can't obtain a reference and change the object from underneath you\n- Easier to reason about for asynchronous and parallel tasks\n  - Other code can't mutate your object in between operations\n- Safety of APIs\n  - What you pass into a method cannot be changed by the callee / caller\n\nA copyWith method helps with reducing verbosity when creating a new object with just a few things changed.\n\nCopying is more efficient than you might think, since dart can reuse any references to sub-objects that have not changed.\n\ndanger\n\nMake sure your objects are deeply immutable, otherwise you'll have to implement some sort of deep copy mechanism.\n\n## Best Practices [​](\\#best-practices \"Direct link to Best Practices\")\n\nYou can use any package you want to create immutable state.\n\nFor immutable objects:\n\n- [package:freezed](https://pub.dev/packages/freezed)\n- [package:built\\_value](https://pub.dev/packages/built_value)\n\nFor immutable collections (Map, Set, List):\n\n- [package:fast\\_immutable\\_collections](https://pub.dev/packages/fast_immutable_collections)\n- [package:built\\_collection](https://pub.dev/packages/built_collection)\n- [package:kt\\_dart](https://pub.dev/packages/kt_dart)\n- [package:dartz](https://pub.dev/packages/dartz)\n\nIt is highly recommended to use [freezed](https://pub.dev/packages/freezed),\nsince it has several nice additions beyond just making immutable objects including:\n\n- A generated copyWith method\n- Deep copy (copyWith on nested freezed objects)\n- Union types\n- Union mapping functions\n\nYou do not need to use code generation to work with immutable state, but it makes it much easier.\n\ndanger\n\nIf you want to use the built-in collections, make sure to enforce a discipline of making copies of collections when updating them.\nThe issue with not copying a collection is that riverpod determines whether to emit a new state based on whether the reference to the object has changed.\nIf you just call a method that mutates an object, the reference is the same.\n\n### Using immutable state [​](\\#using-immutable-state \"Direct link to Using immutable state\")\n\nImmutable state is best fit for using a [Notifier](https://pub.dev/documentation/riverpod/latest/riverpod/Notifier-class.html) .\nA [Notifier](https://pub.dev/documentation/riverpod/latest/riverpod/Notifier-class.html) allows you to expose an interface through which you can 'mutate' the state.\nYou cannot mutate the state from outside the class you define that extends [Notifier](https://pub.dev/documentation/riverpod/latest/riverpod/Notifier-class.html).\nThis enforces a separation of concerns and keeps business logic outside of your UI.\n\nHere is an example of a simple immutable settings class for changing an app theme.\n\n```codeBlockLines_e6Vv\n\n@riverpod\nclass ThemeNotifier extends _$ThemeNotifier {\n  @override\n  ThemeSettings build() => const ThemeSettings(\n        mode: ThemeMode.light,\n        primaryColor: Colors.blue,\n      );\n\n  void toggle() {\n    state = state.copyWith(mode: state.mode.toggle);\n  }\n\n  void setDarkTheme() {\n    state = state.copyWith(mode: ThemeMode.dark);\n  }\n\n  void setLightTheme() {\n    state = state.copyWith(mode: ThemeMode.light);\n  }\n\n  void setSystemTheme() {\n    state = state.copyWith(mode: ThemeMode.system);\n  }\n\n  void setPrimaryColor(Color color) {\n    state = state.copyWith(primaryColor: color);\n  }\n}\n\n@freezed\nclass ThemeSettings with _$ThemeSettings {\n  const factory ThemeSettings({\n    required ThemeMode mode,\n    required Color primaryColor,\n  }) = _ThemeSettings;\n}\n\nextension ToggleTheme on ThemeMode {\n  ThemeMode get toggle {\n    switch (this) {\n      case ThemeMode.dark:\n        return ThemeMode.light;\n      case ThemeMode.light:\n        return ThemeMode.dark;\n      case ThemeMode.system:\n        return ThemeMode.system;\n    }\n  }\n}\n\n```\n\nTo use this code, remember to import `freezed_annotation`, add the part directive and run [build\\_runner](https://pub.dev/packages/build_runner) to generate the freezed classes!\n\n- [What is Immutability?](#what-is-immutability)\n- [Best Practices](#best-practices)\n  - [Using immutable state](#using-immutable-state)",
    "metadata": {
      "url": "https://riverpod.dev/docs/concepts/why_immutability",
      "ogUrl": "https://riverpod.dev/docs/concepts/why_immutability",
      "title": "Why Immutability | Riverpod",
      "og:url": "https://riverpod.dev/docs/concepts/why_immutability",
      "ogImage": "https://riverpod.dev/img/cover.png",
      "ogTitle": "Why Immutability | Riverpod",
      "language": "en",
      "og:image": "https://riverpod.dev/img/cover.png",
      "og:title": "Why Immutability | Riverpod",
      "viewport": "width=device-width, initial-scale=1.0",
      "generator": "Docusaurus v2.4.3",
      "sourceURL": "https://riverpod.dev/docs/concepts/why_immutability",
      "statusCode": 200,
      "description": "The content of this page may be outdated.",
      "twitter:card": "summary_large_image",
      "ogDescription": "The content of this page may be outdated.",
      "twitter:image": "https://riverpod.dev/img/cover.png",
      "docusaurus_tag": "docs-default-current",
      "og:description": "The content of this page may be outdated.",
      "docsearch:version": "current",
      "docusaurus_locale": "en",
      "ogLocaleAlternate": [],
      "docsearch:language": "en",
      "docusaurus_version": "current",
      "docsearch:docusaurus_tag": "docs-default-current"
    }
  },
  {
    "markdown": "[Skip to main content](#__docusaurus_skipToContent_fallback)\n\nOn this page\n\nThis in-depth article is meant to show why Riverpod is even a thing.\n\nIn particular, this section should answer the following:\n\n- Since Provider is widely popular, why would one migrate to Riverpod?\n- What concrete advantages do I get?\n- How can I migrate towards Riverpod?\n- Can I migrate incrementally?\n- etc.\n\nBy the end of this section you should be convinced that Riverpod is to be prefered over Provider.\n\n**Riverpod is indeed a more modern, recommended and reliable approach when compared to Provider**.\n\nRiverpod offers better State Management capabilities, better Caching strategies and a simplified Reactivty model.\n\nWhereas, Provider is currently lacking in many areas with no way forward.\n\n## Provider's Limitations [​](\\#providers-limitations \"Direct link to Provider's Limitations\")\n\nProvider has fundamental issues due to being restricted by the InheritedWidget API.\n\nInherently, Provider is a \"simpler `InheritedWidget`\";\nProvider is merely an InheritedWidget wrapper, and thus it's limited by it.\n\nHere's a list of known Provider issues.\n\n### Provider can't keep two (or more) providers of the same \"type\" [​](\\#provider-cant-keep-two-or-more-providers-of-the-same-type \"Direct link to Provider can't keep two (or more) providers of the same \\\"type\\\"\")\n\nDeclaring two `Provider<Item>` will result into unreliable behavior: `InheritedWidget`'s API will\nobtain only _one of the two_: the closest `Provider<Item>` ancestor.\n\nWhile a [workaround](https://pub.dev/packages/provider#can-i-obtain-two-different-providers-using-the-same-type) is explained in Provider's\ndocumentation, Riverpod simply doesn't have this problem.\n\nBy removing this limitation, we can freely split logic into tiny pieces, like so:\n\n```codeBlockLines_e6Vv\n\n@riverpod\nList<Item> items(Ref ref) {\n  return []; // ...\n}\n\n@riverpod\nList<Item> evenItems(Ref ref) {\n  final items = ref.watch(itemsProvider);\n  return [...items.whereIndexed((index, element) => index.isEven)];\n}\n\n```\n\n### Providers reasonably emit only one value at a time [​](\\#providers-reasonably-emit-only-one-value-at-a-time \"Direct link to Providers reasonably emit only one value at a time\")\n\nWhen reading an external RESTful API, it's quite common to show\nthe last read value, while a new call loads the next one.\n\nRiverpod allows this behavior via emitting two values at a time (i.e. a previous data value,\nand an incoming new loading value), via its `AsyncValue`'s APIs:\n\n```codeBlockLines_e6Vv\n\n@riverpod\nFuture<List<Item>> itemsApi(Ref ref) async {\n  final client = Dio();\n  final result = await client.get<List<dynamic>>('your-favorite-api');\n  final parsed = [...result.data!.map((e) => Item.fromJson(e as Json))];\n  return parsed;\n}\n\n@riverpod\nList<Item> evenItems(Ref ref) {\n  final asyncValue = ref.watch(itemsApiProvider);\n  if (asyncValue.isReloading) return [];\n  if (asyncValue.hasError) return const [Item(id: -1)];\n\n  final items = asyncValue.requireValue;\n\n  return [...items.whereIndexed((index, element) => index.isEven)];\n}\n\n```\n\nIn the previous snippet, watching `evenItemsProvider` will produce the following effects:\n\n1. Initially, the request is being made. We obtain an empty list;\n2. Then, say an error occurs. We obtain `[Item(id: -1)]`;\n3. Then, we retry the request with a pull-to-refresh logic (e.g. via `ref.invalidate`);\n4. While we reload the first provider, the second one still exposes `[Item(id: -1)]`;\n5. This time, some parsed data is received correctly: our even items are correctly returned.\n\nWith Provider, the above features aren't remotely achievable, and even less easy to workaround.\n\n### Combining providers is hard and error prone [​](\\#combining-providers-is-hard-and-error-prone \"Direct link to Combining providers is hard and error prone\")\n\nWith Provider we may be tempted to use `context.watch` inside provider's `create`.\n\nThis would be unreliable, as `didChangeDependencies` may be triggered even if no dependency\nhas changed (e.g. such as when there's a GlobalKey involved in the widget tree).\n\nNonetheless, Provider has an ad-hoc solution named `ProxyProvider`, but it's considered tedious and error-prone.\n\nCombining state is a core Riverpod mechanism, as we can combine and cache values reactively with zero overhead\nwith simple yet powerful utilites such as [ref.watch](/docs/concepts/reading#using-refwatch-to-observe-a-provider) and [ref.listen](/docs/concepts/reading#using-reflisten-to-react-to-a-provider-change):\n\n```codeBlockLines_e6Vv\n\n@riverpod\nint number(Ref ref) {\n  return Random().nextInt(10);\n}\n\n@riverpod\nint doubled(Ref ref) {\n  final number = ref.watch(numberProvider);\n\n  return number * 2;\n}\n\n```\n\nCombining values feels natural with Riverpod: dependencies are readable and the APIs remain the same.\n\n### Lack of safety [​](\\#lack-of-safety \"Direct link to Lack of safety\")\n\nWith Provider, it's common to end-up with a `ProviderNotFoundException` during refactors and / or during large changes.\n\nIndeed, this runtime exception _was_ one of the main reasons Riverpod was created in the first place.\n\nAlthough it brings much more utility than this, Riverpod simply can't throw this exception.\n\n### Disposing of state is difficult [​](\\#disposing-of-state-is-difficult \"Direct link to Disposing of state is difficult\")\n\n`InheritedWidget` [can't react when a consumer stops listening to them](https://github.com/flutter/flutter/issues/106546).\n\nThis prevents the ability for Provider\nto automatically destroy its providers' state when they're no-longer used.\n\nWith Provider, [we have to](https://github.com/flutter/flutter/issues/128432) rely on scoping providers to dispose the state when it stops being used.\n\nBut this isn't easy, as it gets tricky when state is shared between pages.\n\nRiverpod solves this with easy-to-understand APIs such as [autodispose](/docs/concepts/modifiers/auto_dispose) and [keepAlive](/docs/concepts/modifiers/auto_dispose#refkeepalive).\n\nThese two APIs enable flexible and creative caching strategies (e.g. time-based caching):\n\n```codeBlockLines_e6Vv\n\n// With code gen, .autoDispose is the default\n@riverpod\nint diceRoll(Ref ref) {\n  // Since this provider is .autoDispose, un-listening to it will dispose\n  // its current exposed state.\n  // Then, whenever this provider is listened to again,\n  // a new dice will be rolled and exposed again.\n  final dice = Random().nextInt(10);\n  return dice;\n}\n\n@riverpod\nint cachedDiceRoll(Ref ref) {\n  final coin = Random().nextInt(10);\n  if (coin > 5) throw Exception('Way too large.');\n  // The above condition might fail;\n  // If it doesn't, the following instruction tells the Provider\n  // to keep its cached state, even when no one listens to it anymore.\n  ref.keepAlive();\n  return coin;\n}\n\n```\n\nUnluckily, there's no way to implement this with a raw `InheritedWidget`, and thus with Provider.\n\n### Lack of a reliable parametrization mechanism [​](\\#lack-of-a-reliable-parametrization-mechanism \"Direct link to Lack of a reliable parametrization mechanism\")\n\nRiverpod allows its user to declare \"parametrized\" Providers with the [.family modifier](/docs/concepts/modifiers/family).\n\nIndeed, `.family` is one of Riverpod's most powerful feature and it is core to its innovations,\ne.g. it enables enormous [simplification of logic](/docs/concepts/modifiers/family#usage).\n\nIf we wanted to implement something similar using Provider, we would have to give\nup easiness of use _and_ type-safeness on such parameters.\n\nFurthermore, not being able to implement a similar `.autoDispose` mechanism with Provider\ninherently prevents any equivalent implementation of `.family`, [as these two features go hand-in-hand](/docs/concepts/modifiers/family#prefer-using-autodispose-when-the-parameter-is-not-constant).\n\nFinally, as shown before, [it turns out](https://github.com/flutter/flutter/issues/106549) that widgets _never_ stop to listen to an `InheritedWidget`.\n\nThis implies significant memory leaks if some provider state is \"dynamically mounted\", i.e. when using parameters\nto a build a Provider, which is exactly what `.family` does.\n\nThus, obtaining a `.family` equivalent for Provider is fundamentally impossible at the moment in time.\n\n### Testing is tedious [​](\\#testing-is-tedious \"Direct link to Testing is tedious\")\n\nTo be able to write a test, you _have to_ re-define providers inside each test.\n\nWith Riverpod, providers are ready to use inside tests, by default. Furthermore, Riverpod exposes a\nhandy collection of \"overriding\" utilites that are crucial when mocking Providers.\n\nTesting the combined state snippet above would be as simple as the following:\n\n```codeBlockLines_e6Vv\n\nvoid main() {\n  test('it doubles the value correctly', () async {\n    final container = ProviderContainer(\n      overrides: [numberProvider.overrideWith((ref) => 9)],\n    );\n    final doubled = container.read(doubledProvider);\n    expect(doubled, 9 * 2);\n  });\n}\n\n```\n\nFor more info about testing, see [Testing](/docs/cookbooks/testing).\n\n### Triggering side effects isn't straightforward [​](\\#triggering-side-effects-isnt-straightforward \"Direct link to Triggering side effects isn't straightforward\")\n\nSince `InheritedWidget` has no `onChange` callback, Provider can't have one.\n\nThis is problematic for navigation, such as for snackbars, modals, etc.\n\nInstead, Riverpod simply offers `ref.listen`, which [integrates well with Flutter](/docs/concepts/reading#using-reflisten-to-react-to-a-provider-change).\n\n```codeBlockLines_e6Vv\n\nclass DiceRollWidget extends ConsumerWidget {\n  const DiceRollWidget({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    ref.listen(diceRollProvider, (previous, next) {\n      ScaffoldMessenger.of(context).showSnackBar(\n        SnackBar(content: Text('Dice roll! We got: $next')),\n      );\n    });\n    return TextButton.icon(\n      onPressed: () => ref.invalidate(diceRollProvider),\n      icon: const Icon(Icons.casino),\n      label: const Text('Roll a dice'),\n    );\n  }\n}\n\n```\n\n## Towards Riverpod [​](\\#towards-riverpod \"Direct link to Towards Riverpod\")\n\nConceptually, Riverpod and Provider are fairly similar.\nBoth packages fill a similar role. Both try to:\n\n- cache and dispose some stateful objects;\n- offer a way to mock those objects during tests;\n- offer a way for Widgets to listen to those objects in a simple way.\n\nYou can think of Riverpod as what Provider could've been if it continued to mature for a few years.\n\n### Why a separate package? [​](\\#why-a-separate-package \"Direct link to Why a separate package?\")\n\nOriginally, a major version of Provider was planned to ship, as a way to solve\nthe aforementioned problems.\n\nBut it was then decided against it, as this would have been\n\"too breaking\" and even controversial, because of the new `ConsumerWidget` API.\n\nSince Provider is still one of the most used Flutter packages, it was instead decided\nto create a separate package, and thus Riverpod was created.\n\nCreating a separate package enabled:\n\n- Ease of migration for whoever wants to, by also enabling the temporary use of both approaches, _at the same time_;\n- Allow folks to stick to Provider if they dislike Riverpod in principle, or if they didn't find it reliable yet;\n- Experimentation, allowing for Riverpod to search for production-ready solutions to the various Provider's technical limitations.\n\nIndeed, Riverpod is designed to be the spiritual successor of Provider. Hence the name \"Riverpod\" (which is an anagram of \"Provider\").\n\n### The breaking change [​](\\#the-breaking-change \"Direct link to The breaking change\")\n\nThe only true downside of Riverpod is that it requires changing the widget type to work:\n\n- Instead of extending `StatelessWidget`, with Riverpod you should extend `ConsumerWidget`.\n- Instead of extending `StatefulWidget`, with Riverpod you should extend `ConsumerStatefulWidget`.\n\nBut this inconvenience is fairly minor in the grand scheme of things. And this requirement might, one day, disappear.\n\n### Choosing the right library [​](\\#choosing-the-right-library \"Direct link to Choosing the right library\")\n\nYou're probably asking yourself:\n_\"So, as a Provider user, should I use Provider or Riverpod?\"_.\n\nWe want to answer to this question very clearly:\n\n```codeBlockLines_e6Vv\nYou probably should be using Riverpod\n\n```\n\nRiverpod is overall better designed and could lead to drastic simplifications of your logic.\n\n- [Provider's Limitations](#providers-limitations)\n  - [Provider can't keep two (or more) providers of the same \"type\"](#provider-cant-keep-two-or-more-providers-of-the-same-type)\n  - [Providers reasonably emit only one value at a time](#providers-reasonably-emit-only-one-value-at-a-time)\n  - [Combining providers is hard and error prone](#combining-providers-is-hard-and-error-prone)\n  - [Lack of safety](#lack-of-safety)\n  - [Disposing of state is difficult](#disposing-of-state-is-difficult)\n  - [Lack of a reliable parametrization mechanism](#lack-of-a-reliable-parametrization-mechanism)\n  - [Testing is tedious](#testing-is-tedious)\n  - [Triggering side effects isn't straightforward](#triggering-side-effects-isnt-straightforward)\n- [Towards Riverpod](#towards-riverpod)\n  - [Why a separate package?](#why-a-separate-package)\n  - [The breaking change](#the-breaking-change)\n  - [Choosing the right library](#choosing-the-right-library)",
    "metadata": {
      "url": "https://riverpod.dev/docs/from_provider/motivation",
      "ogUrl": "https://riverpod.dev/docs/from_provider/motivation",
      "title": "Motivation | Riverpod",
      "og:url": "https://riverpod.dev/docs/from_provider/motivation",
      "ogImage": "https://riverpod.dev/img/cover.png",
      "ogTitle": "Motivation | Riverpod",
      "language": "en",
      "og:image": "https://riverpod.dev/img/cover.png",
      "og:title": "Motivation | Riverpod",
      "viewport": "width=device-width, initial-scale=1.0",
      "generator": "Docusaurus v2.4.3",
      "sourceURL": "https://riverpod.dev/docs/from_provider/motivation",
      "statusCode": 200,
      "description": "This in-depth article is meant to show why Riverpod is even a thing.",
      "twitter:card": "summary_large_image",
      "ogDescription": "This in-depth article is meant to show why Riverpod is even a thing.",
      "twitter:image": "https://riverpod.dev/img/cover.png",
      "docusaurus_tag": "docs-default-current",
      "og:description": "This in-depth article is meant to show why Riverpod is even a thing.",
      "docsearch:version": "current",
      "docusaurus_locale": "en",
      "ogLocaleAlternate": [],
      "docsearch:language": "en",
      "docusaurus_version": "current",
      "docsearch:docusaurus_tag": "docs-default-current"
    }
  },
  {
    "markdown": "[Skip to main content](https://riverpod.dev/docs/providers/state_provider#__docusaurus_skipToContent_fallback)\n\nOn this page\n\ncaution\n\nThe content of this page may be outdated.\n\nIt will be updated in the future, but for now you may want to refer to the content\nin the top of the sidebar instead (introduction/essentials/case-studies/...)\n\n`StateProvider` is a provider that exposes a way to modify its state.\nIt is a simplification of [NotifierProvider](https://riverpod.dev/docs/providers/notifier_provider), designed to avoid\nhaving to write a [Notifier](https://pub.dev/documentation/riverpod/latest/riverpod/Notifier-class.html) class for very simple use-cases.\n\n`StateProvider` exists primarily to allow the modification of\n**simple** variables by the User Interface.\n\nThe state of a `StateProvider` is typically one of:\n\n- an enum, such as a filter type\n- a String, typically the raw content of a text field\n- a boolean, for checkboxes\n- a number, for pagination or age form fields\n\nYou should not use `StateProvider` if:\n\n- your state needs validation logic\n- your state is a complex object (such as a custom class, a list/map, ...)\n- the logic for modifying your state is more advanced than a simple `count++`.\n\nFor more advanced cases, consider using [NotifierProvider](https://riverpod.dev/docs/providers/notifier_provider) instead and\ncreate a [Notifier](https://pub.dev/documentation/riverpod/latest/riverpod/Notifier-class.html) class.\n\nWhile the initial boilerplate will be a bit larger, having a custom\n[Notifier](https://pub.dev/documentation/riverpod/latest/riverpod/Notifier-class.html) class is critical for the long-term maintainability of your\nproject – as it centralizes the business logic of your state in a single place.\n\n## Usage example: Changing the filter type using a dropdown [​](https://riverpod.dev/docs/providers/state_provider\\#usage-example-changing-the-filter-type-using-a-dropdown \"Direct link to Usage example: Changing the filter type using a dropdown\")\n\nA real-world use-case of `StateProvider` would be to manage the state of\nsimple form components like dropdowns/text fields/checkboxes.\n\nIn particular, we will see how to use `StateProvider` to implement a dropdown\nthat allows changing how a list of products is sorted.\n\nFor the sake of simplicity, the list of products that we will obtain\nwill be built directly in the application and will be as follows:\n\n```codeBlockLines_e6Vv\n\nclass Product {\n  Product({required this.name, required this.price});\n\n  final String name;\n  final double price;\n}\n\nfinal _products = [\\\n  Product(name: 'iPhone', price: 999),\\\n  Product(name: 'cookie', price: 2),\\\n  Product(name: 'ps5', price: 500),\\\n];\n\nfinal productsProvider = Provider<List<Product>>((ref) {\n  return _products;\n});\n\n```\n\nIn a real-world application, this list would typically be obtained using\n[FutureProvider](https://riverpod.dev/docs/providers/future_provider) by making a network request.\n\nThe User Interface could then show the list of products by doing:\n\n```codeBlockLines_e6Vv\n\nWidget build(BuildContext context, WidgetRef ref) {\n  final products = ref.watch(productsProvider);\n  return Scaffold(\n    body: ListView.builder(\n      itemCount: products.length,\n      itemBuilder: (context, index) {\n        final product = products[index];\n        return ListTile(\n          title: Text(product.name),\n          subtitle: Text('${product.price} \\$'),\n        );\n      },\n    ),\n  );\n}\n\n```\n\nNow that we're done with the base, we can add a dropdown, which will\nallow filtering our products either by price or by name.\n\nFor that, we will use [DropDownButton](https://api.flutter.dev/flutter/material/DropdownButton-class.html).\n\n```codeBlockLines_e6Vv\n\n// An enum representing the filter type\nenum ProductSortType {\n  name,\n  price,\n}\n\nWidget build(BuildContext context, WidgetRef ref) {\n  final products = ref.watch(productsProvider);\n  return Scaffold(\n    appBar: AppBar(\n      title: const Text('Products'),\n      actions: [\\\n        DropdownButton<ProductSortType>(\\\n          value: ProductSortType.price,\\\n          onChanged: (value) {},\\\n          items: const [\\\n            DropdownMenuItem(\\\n              value: ProductSortType.name,\\\n              child: Icon(Icons.sort_by_alpha),\\\n            ),\\\n            DropdownMenuItem(\\\n              value: ProductSortType.price,\\\n              child: Icon(Icons.sort),\\\n            ),\\\n          ],\\\n        ),\\\n      ],\n    ),\n    body: ListView.builder(\n      // ... /* SKIP */\n      itemBuilder: (c, i) => Container(), /* SKIP END */\n    ),\n  );\n}\n\n```\n\nNow that we have a dropdown, let's create a `StateProvider` and\nsynchronize the state of the dropdown with our provider.\n\nFirst, let's create the `StateProvider`:\n\n```codeBlockLines_e6Vv\n\nfinal productSortTypeProvider = StateProvider<ProductSortType>(\n  // We return the default sort type, here name.\n  (ref) => ProductSortType.name,\n);\n\n```\n\nThen, we can connect this provider with our dropdown by doing:\n\n```codeBlockLines_e6Vv\nDropdownButton<ProductSortType>(\n  // When the sort type changes, this will rebuild the dropdown\n  // to update the icon shown.\n  value: ref.watch(productSortTypeProvider),\n  // When the user interacts with the dropdown, we update the provider state.\n  onChanged: (value) =>\n      ref.read(productSortTypeProvider.notifier).state = value!,\n  items: [\\\n    // ...\\\n  ],\n),\n\n```\n\nWith this, we should now be able to change the sort type.\n\nIt has no impact on the list of products yet though! It's now time for the\nfinal part: Updating our `productsProvider` to sort the list of products.\n\nA key component of implementing this is to use [ref.watch](https://riverpod.dev/docs/concepts/reading#using-refwatch-to-observe-a-provider), to have\nour `productsProvider` obtain the sort type and recompute the list of\nproducts whenever the sort type changes.\n\nThe implementation would be:\n\n```codeBlockLines_e6Vv\n\nfinal productsProvider = Provider<List<Product>>((ref) {\n  final sortType = ref.watch(productSortTypeProvider);\n  switch (sortType) {\n    case ProductSortType.name:\n      return _products.sorted((a, b) => a.name.compareTo(b.name));\n    case ProductSortType.price:\n      return _products.sorted((a, b) => a.price.compareTo(b.price));\n  }\n});\n\n```\n\nThat's all! This change is enough for the User Interface to automatically\nre-render the list of products when the sort type changes.\n\nHere is the complete example on Dartpad:\n\nDartPad\n\nCookies management controls\n\n```\nxxxxxxxxxx\n```\n\n6\n\n1\n\n```\nvoid main() {\n```\n\n2\n\n```\n  for (var i = 0; i < 10; i++) {\n```\n\n3\n\n```\n    print('hello ${i + 1}');\n```\n\n4\n\n```\n  }\n```\n\n5\n\n```\n}\n```\n\n6\n\n```\n​\n```\n\n## How to update the state based on the previous value without reading the provider twice [​](https://riverpod.dev/docs/providers/state_provider\\#how-to-update-the-state-based-on-the-previous-value-without-reading-the-provider-twice \"Direct link to How to update the state based on the previous value without reading the provider twice\")\n\nSometimes, you want to update the state of a `StateProvider` based on the previous value.\nNaturally, you may end-up writing:\n\n```codeBlockLines_e6Vv\n\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\nclass HomeView extends ConsumerWidget {\n  const HomeView({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    return Scaffold(\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          // We're updating the state from the previous value, we ended-up reading\n          // the provider twice!\n          ref.read(counterProvider.notifier).state = ref.read(counterProvider.notifier).state + 1;\n        },\n      ),\n    );\n  }\n}\n\n```\n\nWhile there's nothing particularly wrong with this snippet, the syntax is a bit inconvenient.\n\nTo make the syntax a bit better, we can use the `update` function.\nThis function will take a callback that will receive the current state and is expected\nto return the new state.\n\nWe can use it to refactor our previous code to:\n\n```codeBlockLines_e6Vv\n\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\nclass HomeView extends ConsumerWidget {\n  const HomeView({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    return Scaffold(\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          ref.read(counterProvider.notifier).update((state) => state + 1);\n        },\n      ),\n    );\n  }\n}\n\n```\n\nThis change achieves the same effect while making the syntax a bit better.\n\n- [Usage example: Changing the filter type using a dropdown](https://riverpod.dev/docs/providers/state_provider#usage-example-changing-the-filter-type-using-a-dropdown)\n- [How to update the state based on the previous value without reading the provider twice](https://riverpod.dev/docs/providers/state_provider#how-to-update-the-state-based-on-the-previous-value-without-reading-the-provider-twice)",
    "metadata": {
      "url": "https://riverpod.dev/docs/providers/state_provider",
      "ogUrl": "https://riverpod.dev/docs/providers/state_provider",
      "title": "StateProvider | RiverpodDartPad",
      "og:url": "https://riverpod.dev/docs/providers/state_provider",
      "ogImage": "https://riverpod.dev/img/cover.png",
      "ogTitle": "StateProvider | Riverpod",
      "language": "en",
      "og:image": "https://riverpod.dev/img/cover.png",
      "og:title": "StateProvider | Riverpod",
      "viewport": [
        "width=device-width, initial-scale=1.0",
        "width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
      ],
      "generator": [
        "Docusaurus v2.4.3",
        "Flutter"
      ],
      "sourceURL": "https://riverpod.dev/docs/providers/state_provider",
      "statusCode": 200,
      "description": [
        "The content of this page may be outdated.",
        "An online Dart editor with support for console and Flutter apps."
      ],
      "theme-color": "#445e91",
      "twitter:card": "summary_large_image",
      "ogDescription": "The content of this page may be outdated.",
      "twitter:image": "https://riverpod.dev/img/cover.png",
      "docusaurus_tag": "docs-default-current",
      "og:description": "The content of this page may be outdated.",
      "docsearch:version": "current",
      "docusaurus_locale": "en",
      "ogLocaleAlternate": [],
      "docsearch:language": "en",
      "docusaurus_version": "current",
      "docsearch:docusaurus_tag": "docs-default-current",
      "apple-mobile-web-app-title": "DartPad",
      "apple-mobile-web-app-capable": "yes",
      "apple-mobile-web-app-status-bar-style": "black"
    }
  },
  {
    "markdown": "[Skip to main content](#__docusaurus_skipToContent_fallback)\n\nOn this page\n\nUp until now, we've only seen cases where requests are independent of each\nother. But a common use-case is to have to trigger a request based on the\nresult of another request.\n\nWe _could_ be using the [Passing arguments to your requests](/docs/essentials/passing_args) mechanism to\ndo that, by passing the result of a provider as a parameter to another provider.\n\nBut this approach has a few downsides:\n\n- This leaks implementation details.\nNow, your UI needs to know about all the providers that are used\nby your other provider.\n- Whenever the parameter changes, a brand new state will be created.\nBy passing parameters, there is no way to keep the previous state\nwhen the parameter changes.\n- It makes combining requests harder.\n- This makes tooling less useful. A devtool wouldn't\nknow about the relationship between providers.\n\nTo improve this, Riverpod offers a different approach to combining requests.\n\n## The basics: Obtaining a \"ref\" [​](\\#the-basics-obtaining-a-ref \"Direct link to The basics: Obtaining a \\\"ref\\\"\")\n\nAll possible ways of combining requests have one thing in common:\nThey are all based on the `Ref` object.\n\nThe `Ref` object is an object to which all providers have access.\nIt grants them access to various life-cycle listeners, but also\nvarious methods to combine providers.\n\nThe place where `Ref` can be obtained depends on the type of provider.\n\nIn functional providers, the `Ref` is passed as a parameter to the\nprovider's function:\n\n```codeBlockLines_e6Vv\n@riverpod\nint example(Ref ref) {\n  // \"Ref\" can be used here to read other providers\n  final otherValue = ref.watch(otherProvider);\n\n  return 0;\n}\n\n```\n\nIn class variants, the `Ref` is a property of the Notifier class:\n\n```codeBlockLines_e6Vv\n@riverpod\nclass Example extends _$Example {\n  @override\n  int build() {\n    // \"Ref\" can be used here to read other providers\n    final otherValue = ref.watch(otherProvider);\n\n    return 0;\n  }\n}\n\n```\n\n## Using ref to read a provider. [​](\\#using-ref-to-read-a-provider \"Direct link to Using ref to read a provider.\")\n\n## The `ref.watch` method. [​](\\#the-refwatch-method \"Direct link to the-refwatch-method\")\n\nNow that we've obtained a `Ref`, we can use it to combine requests.\nThe main way to do so is by using `ref.watch`.\n\nIt is generally recommended to architecture your code such that you\ncan use `ref.watch` over other options, as it is generally easier to maintain.\n\nThe `ref.watch` method takes a provider, and returns its current state.\nThen, whenever the listened provider changes, our provider will be\ninvalidated and rebuilt next frame or on next read.\n\nBy using `ref.watch`, your logic becomes both \"reactive\" and \"declarative\".\n\nMeaning that your logic will automatically recompute when needed.\nAnd that the update mechanism doesn't rely on side-effects, such as an \"on change\".\nThis is similar to how StatelessWidgets behave.\n\nAs an example, we could define a provider that listens to the user's location.\nThen, we could use this location to fetch the list of restaurants near the user.\n\n```codeBlockLines_e6Vv\n@riverpod\nStream<({double longitude, double latitude})> location(Ref ref) {\n  // TO-DO: Return a stream which obtains the current location\n  return someStream;\n}\n\n@riverpod\nFuture<List<String>> restaurantsNearMe(Ref ref) async {\n  // We use \"ref.watch\" to obtain the latest location.\n  // By specifying that \".future\" after the provider, our code will wait\n  // for at least one location to be available.\n  final location = await ref.watch(locationProvider.future);\n\n  // We can now make a network request based on that location.\n  // For example, we could use the Google Map API:\n  // https://developers.google.com/maps/documentation/places/web-service/search-nearby\n  final response = await http.get(\n    Uri.https('maps.googleapis.com', 'maps/api/place/nearbysearch/json', {\n      'location': '${location.latitude},${location.longitude}',\n      'radius': '1500',\n      'type': 'restaurant',\n      'key': '<your api key>',\n    }),\n  );\n  // Obtain the restaurant names from the JSON\n  final json = jsonDecode(response.body) as Map;\n  final results = (json['results'] as List).cast<Map<Object?, Object?>>();\n  return results.map((e) => e['name']! as String).toList();\n}\n\n```\n\ninfo\n\nWhen the listened to provider changes and our request recomputes, the previous\nstate is kept until the new request is completed.\n\nAt the same time, while the request is pending, the \"isLoading\" and \"isReloading\"\nflags will be set.\n\nThis enables UI to either show the previous state or a loading indicator,\nor even both.\n\ninfo\n\nNotice how we used `ref.watch(locationProvider.future)` instead of `ref.watch(locationProvider)`.\nThat is because our `locationProvider` is asynchronous. As such, we want to\nawait for an initial value to be available.\n\nIf we omit that `.future`, we would receive an `AsyncValue`, which is a snapshot\nof the current state of the `locationProvider`. But if no location is available yet,\nwe won't be able to do anything.\n\ncaution\n\nIt is considered bad practice to call `ref.watch` inside code that is executed\n\"imperatively\". Meaning any code that is possibly not executed during the build\nphase of the provider. This includes \"listener\" callbacks or methods on Notifiers:\n\n```codeBlockLines_e6Vv\n@riverpod\nint example(Ref ref) {\n  ref.watch(otherProvider); // Good!\n  ref.onDispose(() => ref.watch(otherProvider)); // Bad!\n\n  final someListenable = ValueNotifier(0);\n  someListenable.addListener(() {\n    ref.watch(otherProvider); // Bad!\n  });\n\n  return 0;\n}\n\n@riverpod\nclass MyNotifier extends _$MyNotifier {\n  @override\n  int build() {\n    ref.watch(otherProvider); // Good!\n    ref.onDispose(() => ref.watch(otherProvider)); // Bad!\n\n    return 0;\n  }\n\n  void increment() {\n    ref.watch(otherProvider); // Bad!\n  }\n}\n\n```\n\n## The `ref.listen` methods. [​](\\#the-reflisten-methods \"Direct link to the-reflisten-methods\")\n\nThe `ref.listen` method is an alternative to `ref.watch`.\n\nIt is similar to your traditional \"listen\"/\"addListener\" method. It takes a provider\nand a callback, and will invoke said callback whenever the content of the provider\nchanges.\n\nRefactoring your code such that you can use `ref.watch` instead of `ref.listen`\nis generally recommended, as the latter is more error-prone due to its imperative nature.\n\nBut `ref.listen` can be helpful to add some quick logic without having to do\nsignificant refactor.\n\nWe could rewrite the `ref.watch` example to use `ref.listen` instead\n\n```codeBlockLines_e6Vv\n@riverpod\nint example(Ref ref) {\n  ref.listen(otherProvider, (previous, next) {\n    print('Changed from: $previous, next: $next');\n  });\n\n  return 0;\n}\n\n```\n\ninfo\n\nIt is entirely safe to use `ref.listen` during the build phase of a provider.\nIf the provider somehow is recomputed, previous listeners will be removed.\n\nAlternatively, you can use the return value of `ref.listen` to remove the listener\nmanually when you wish.\n\n## The `ref.read` method. [​](\\#the-refread-method \"Direct link to the-refread-method\")\n\nThe last option available is `ref.read`.\nIt is similar to `ref.watch` in that it returns the current state of a provider.\nBut unlike `ref.watch`, it doesn't listen to the provider.\n\nAs such, `ref.read` should only be used in places where you can't use\n`ref.watch`, such as inside methods of Notifiers.\n\n```codeBlockLines_e6Vv\n@riverpod\nclass MyNotifier extends _$MyNotifier {\n  @override\n  int build() {\n    // Bad! Do not use \"read\" here as it is not reactive\n    ref.read(otherProvider);\n\n    return 0;\n  }\n\n  void increment() {\n    ref.read(otherProvider); // Using \"read\" here is fine\n  }\n}\n\n```\n\ncaution\n\nBe careful when using `ref.read` on a provider as, since it doesn't listen to the\nprovider, said provider may decide to destroy its state if it isn't listened.\n\n- [The basics: Obtaining a \"ref\"](#the-basics-obtaining-a-ref)\n- [Using ref to read a provider.](#using-ref-to-read-a-provider)\n- [The `ref.watch` method.](#the-refwatch-method)\n- [The `ref.listen` methods.](#the-reflisten-methods)\n- [The `ref.read` method.](#the-refread-method)",
    "metadata": {
      "url": "https://riverpod.dev/docs/essentials/combining_requests",
      "ogUrl": "https://riverpod.dev/docs/essentials/combining_requests",
      "title": "Combining requests | Riverpod",
      "og:url": "https://riverpod.dev/docs/essentials/combining_requests",
      "ogImage": "https://riverpod.dev/img/cover.png",
      "ogTitle": "Combining requests | Riverpod",
      "language": "en",
      "og:image": "https://riverpod.dev/img/cover.png",
      "og:title": "Combining requests | Riverpod",
      "viewport": "width=device-width, initial-scale=1.0",
      "generator": "Docusaurus v2.4.3",
      "sourceURL": "https://riverpod.dev/docs/essentials/combining_requests",
      "statusCode": 200,
      "description": "Up until now, we've only seen cases where requests are independent of each",
      "twitter:card": "summary_large_image",
      "ogDescription": "Up until now, we've only seen cases where requests are independent of each",
      "twitter:image": "https://riverpod.dev/img/cover.png",
      "docusaurus_tag": "docs-default-current",
      "og:description": "Up until now, we've only seen cases where requests are independent of each",
      "docsearch:version": "current",
      "docusaurus_locale": "en",
      "ogLocaleAlternate": [],
      "docsearch:language": "en",
      "docusaurus_version": "current",
      "docsearch:docusaurus_tag": "docs-default-current"
    }
  },
  {
    "markdown": "[Skip to main content](#__docusaurus_skipToContent_fallback)\n\ncaution\n\nThe content of this page may be outdated.\n\nIt will be updated in the future, but for now you may want to refer to the content\nin the top of the sidebar instead (introduction/essentials/case-studies/...)\n\n`ChangeNotifierProvider` (flutter\\_riverpod/hooks\\_riverpod only) is a provider that\nis used to listen to and expose a [ChangeNotifier](https://api.flutter.dev/flutter/foundation/ChangeNotifier-class.html) from Flutter itself.\n\nUsing `ChangeNotifierProvider` is discouraged by Riverpod and exists primarily for:\n\n- an easy transition from `package:provider` when using its `ChangeNotifierProvider`\n- supporting mutable state, even though immutable state is preferred\n\ninfo\n\nPrefer using [NotifierProvider](/docs/providers/notifier_provider) instead.\n\nConsider using `ChangeNotifierProvider` only if you are absolutely certain\nthat you want mutable state.\n\nUsing mutable state instead of immutable state can sometimes be more efficient.\nThe downside is, it can be harder to maintain and may break various features.\n\nFor example, using `provider.select` to optimize rebuilds of your widgets\nmay not work if your state is mutable, as `select` will think that the value\nhasn't changed.\n\nAs such, using immutable data structures can sometimes be faster. Therefore\nit is important to make benchmarks specific to your use-case, to make sure\nthat you are truly gaining performance by using `ChangeNotifierProvider`.\n\nAs a usage example, we could use `ChangeNotifierProvider` to implement a todo-list.\nDoing so would allow us to expose methods such as `addTodo` to let the UI\nmodify the list of todos on user interactions:\n\n```codeBlockLines_e6Vv\n\nclass Todo {\n  Todo({\n    required this.id,\n    required this.description,\n    required this.completed,\n  });\n\n  String id;\n  String description;\n  bool completed;\n}\n\nclass TodosNotifier extends ChangeNotifier {\n  final todos = <Todo>[];\n\n  // Let's allow the UI to add todos.\n  void addTodo(Todo todo) {\n    todos.add(todo);\n    notifyListeners();\n  }\n\n  // Let's allow removing todos\n  void removeTodo(String todoId) {\n    todos.remove(todos.firstWhere((element) => element.id == todoId));\n    notifyListeners();\n  }\n\n  // Let's mark a todo as completed\n  void toggle(String todoId) {\n    final todo = todos.firstWhere((todo) => todo.id == todoId);\n    todo.completed = !todo.completed;\n    notifyListeners();\n  }\n}\n\n// Finally, we are using ChangeNotifierProvider to allow the UI to interact with\n// our TodosNotifier class.\nfinal todosProvider = ChangeNotifierProvider<TodosNotifier>((ref) {\n  return TodosNotifier();\n});\n\n```\n\nNow that we have defined a `ChangeNotifierProvider`, we can use it to interact\nwith the list of todos in our UI:\n\n```codeBlockLines_e6Vv\n\nclass TodoListView extends ConsumerWidget {\n  const TodoListView({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // rebuild the widget when the todo list changes\n    List<Todo> todos = ref.watch(todosProvider).todos;\n\n    // Let's render the todos in a scrollable list view\n    return ListView(\n      children: [\\\n        for (final todo in todos)\\\n          CheckboxListTile(\\\n            value: todo.completed,\\\n            // When tapping on the todo, change its completed status\\\n            onChanged: (value) =>\\\n                ref.read(todosProvider.notifier).toggle(todo.id),\\\n            title: Text(todo.description),\\\n          ),\\\n      ],\n    );\n  }\n}\n\n```",
    "metadata": {
      "url": "https://riverpod.dev/docs/providers/change_notifier_provider",
      "ogUrl": "https://riverpod.dev/docs/providers/change_notifier_provider",
      "title": "ChangeNotifierProvider | Riverpod",
      "og:url": "https://riverpod.dev/docs/providers/change_notifier_provider",
      "ogImage": "https://riverpod.dev/img/cover.png",
      "ogTitle": "ChangeNotifierProvider | Riverpod",
      "language": "en",
      "og:image": "https://riverpod.dev/img/cover.png",
      "og:title": "ChangeNotifierProvider | Riverpod",
      "viewport": "width=device-width, initial-scale=1.0",
      "generator": "Docusaurus v2.4.3",
      "sourceURL": "https://riverpod.dev/docs/providers/change_notifier_provider",
      "statusCode": 200,
      "description": "The content of this page may be outdated.",
      "twitter:card": "summary_large_image",
      "ogDescription": "The content of this page may be outdated.",
      "twitter:image": "https://riverpod.dev/img/cover.png",
      "docusaurus_tag": "docs-default-current",
      "og:description": "The content of this page may be outdated.",
      "docsearch:version": "current",
      "docusaurus_locale": "en",
      "ogLocaleAlternate": [],
      "docsearch:language": "en",
      "docusaurus_version": "current",
      "docsearch:docusaurus_tag": "docs-default-current"
    }
  },
  {
    "markdown": "[Skip to main content](#__docusaurus_skipToContent_fallback)\n\nOn this page\n\ncaution\n\nThe content of this page may be outdated.\n\nIt will be updated in the future, but for now you may want to refer to the content\nin the top of the sidebar instead (introduction/essentials/case-studies/...)\n\nFor any medium to large-scale applications, it is critical to test the application.\n\nTo successfully test our application, we will want the following things:\n\n- No state should be preserved between `test`/ `testWidgets`.\n\n\nThat means no global state in the application, or all global states should reset after each test.\n\n- Being able to force our providers to have a specific state, either through\nmocking or by manipulating them until we reach the desired state.\n\n\nLet's see one by one how [Riverpod](https://github.com/rrousselgit/riverpod) helps you with these.\n\n## No state should be preserved between `test`/ `testWidgets`. [​](\\#no-state-should-be-preserved-between-testtestwidgets \"Direct link to no-state-should-be-preserved-between-testtestwidgets\")\n\nSince providers are usually declared as global variables, you might worry about\nthat one.\n\nAfter all, global state makes testing very difficult, because it can require\nlengthy `setUp`/ `tearDown`.\n\nBut the reality is: While providers are declared as globals, the state of a provider\nis **not** global.\n\nInstead, it is stored in an object named [ProviderContainer](https://pub.dev/documentation/riverpod/latest/riverpod/ProviderContainer-class.html), which you may have\nseen if you looked at the dart-only examples.\n\nIf you haven't, know that this [ProviderContainer](https://pub.dev/documentation/riverpod/latest/riverpod/ProviderContainer-class.html) object is implicitly created\nby [ProviderScope](https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/ProviderScope-class.html), the widget that enables [Riverpod](https://github.com/rrousselgit/riverpod) on our project.\n\nConcretely what this means is, two `testWidgets` using providers do not share\nany state.\n\nAs such, there is no need for any `setUp`/ `tearDown` at all.\n\nBut an example is better than lengthy explanations:\n\n- testWidgets (Flutter)\n- test (Dart only)\n\n```codeBlockLines_e6Vv\n\n// A Counter implemented and tested using Flutter\n\n// We declared a provider globally, and we will use it in two tests, to see\n// if the state correctly resets to `0` between tests.\n\nfinal counterProvider = StateProvider((ref) => 0);\n\n// Renders the current state and a button that allows incrementing the state\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Consumer(builder: (context, ref, _) {\n        final counter = ref.watch(counterProvider);\n        return ElevatedButton(\n          onPressed: () => ref.read(counterProvider.notifier).state++,\n          child: Text('$counter'),\n        );\n      }),\n    );\n  }\n}\n\nvoid main() {\n  testWidgets('update the UI when incrementing the state', (tester) async {\n    await tester.pumpWidget(ProviderScope(child: MyApp()));\n\n    // The default value is `0`, as declared in our provider\n    expect(find.text('0'), findsOneWidget);\n    expect(find.text('1'), findsNothing);\n\n    // Increment the state and re-render\n    await tester.tap(find.byType(ElevatedButton));\n    await tester.pump();\n\n    // The state have properly incremented\n    expect(find.text('1'), findsOneWidget);\n    expect(find.text('0'), findsNothing);\n  });\n\n  testWidgets('the counter state is not shared between tests', (tester) async {\n    await tester.pumpWidget(ProviderScope(child: MyApp()));\n\n    // The state is `0` once again, with no tearDown/setUp needed\n    expect(find.text('0'), findsOneWidget);\n    expect(find.text('1'), findsNothing);\n  });\n}\n\n```\n\n```codeBlockLines_e6Vv\n\n// A Counter implemented and tested with Dart only (no dependency on Flutter)\n\n// We declared a provider globally, and we will use it in two tests, to see\n// if the state correctly resets to `0` between tests.\n\nfinal counterProvider = StateProvider((ref) => 0);\n\n// Using mockito to keep track of when a provider notify its listeners\nclass Listener extends Mock {\n  void call(int? previous, int value);\n}\n\nvoid main() {\n  test('defaults to 0 and notify listeners when value changes', () {\n    // An object that will allow us to read providers\n    // Do not share this between tests.\n    final container = ProviderContainer();\n    addTearDown(container.dispose);\n    final listener = Listener();\n\n    // Observe a provider and spy the changes.\n    container.listen<int>(\n      counterProvider,\n      listener.call,\n      fireImmediately: true,\n    );\n\n    // the listener is called immediately with 0, the default value\n    verify(listener(null, 0)).called(1);\n    verifyNoMoreInteractions(listener);\n\n    // We increment the value\n    container.read(counterProvider.notifier).state++;\n\n    // The listener was called again, but with 1 this time\n    verify(listener(0, 1)).called(1);\n    verifyNoMoreInteractions(listener);\n  });\n\n  test('the counter state is not shared between tests', () {\n    // We use a different ProviderContainer to read our provider.\n    // This ensure that no state is reused between tests\n    final container = ProviderContainer();\n    addTearDown(container.dispose);\n    final listener = Listener();\n\n    container.listen<int>(\n      counterProvider,\n      listener.call,\n      fireImmediately: true,\n    );\n\n    // The new test correctly uses the default value: 0\n    verify(listener(null, 0)).called(1);\n    verifyNoMoreInteractions(listener);\n  });\n}\n\n```\n\nAs you can see, while `counterProvider` was declared as a global, no state was\nshared between tests.\n\nAs such, we do not have to worry about our tests potentially behaving differently\nif executed in a different order, since they are running in complete isolation.\n\n## Overriding the behavior of a provider during tests. [​](\\#overriding-the-behavior-of-a-provider-during-tests \"Direct link to Overriding the behavior of a provider during tests.\")\n\nA common real-world application may have the following objects:\n\n- It will have a `Repository` class, which provides a type-safe and simple API\nto perform HTTP requests.\n\n- An object that manages the application state, and may use `Repository` to perform\nHTTP requests based on different factors.\nThis may be a `ChangeNotifier`, `Bloc`, or even a provider.\n\n\nUsing [Riverpod](https://github.com/rrousselgit/riverpod), this may be represented as follows:\n\n```codeBlockLines_e6Vv\n\nclass Repository {\n  Future<List<Todo>> fetchTodos() async => [];\n}\n\n// We expose our instance of Repository in a provider\nfinal repositoryProvider = Provider((ref) => Repository());\n\n/// The list of todos. Here, we are simply fetching them from the server using\n/// [Repository] and doing nothing else.\nfinal todoListProvider = FutureProvider((ref) async {\n  // Obtains the Repository instance\n  final repository = ref.watch(repositoryProvider);\n\n  // Fetch the todos and expose them to the UI.\n  return repository.fetchTodos();\n});\n\n```\n\nIn this situation, when making a unit/widget test, we will typically want to\nreplace our `Repository` instance with a fake implementation that returns\na pre-defined response instead of making a real HTTP request.\n\nWe will then want our `todoListProvider` or equivalent to use the mocked implementation\nof `Repository`.\n\nTo achieve this, we can use the `overrides` parameter of [ProviderScope](https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/ProviderScope-class.html)/ [ProviderContainer](https://pub.dev/documentation/riverpod/latest/riverpod/ProviderContainer-class.html)\nto override the behavior of `repositoryProvider`:\n\n- ProviderScope (Flutter)\n- ProviderContainer (Dart only)\n\n```codeBlockLines_e6Vv\n\ntestWidgets('override repositoryProvider', (tester) async {\n  await tester.pumpWidget(\n    ProviderScope(\n      overrides: [\\\n        // Override the behavior of repositoryProvider to return\\\n        // FakeRepository instead of Repository.\\\n        repositoryProvider.overrideWithValue(FakeRepository())\\\n        // We do not have to override `todoListProvider`, it will automatically\\\n        // use the overridden repositoryProvider\\\n      ],\n      child: MyApp(),\n    ),\n  );\n});\n\n```\n\n```codeBlockLines_e6Vv\n\ntest('override repositoryProvider', () async {\n  final container = ProviderContainer(\n    overrides: [\\\n      // Override the behavior of repositoryProvider to return\\\n      // FakeRepository instead of Repository.\\\n      repositoryProvider.overrideWithValue(FakeRepository())\\\n      // We do not have to override `todoListProvider`, it will automatically\\\n      // use the overridden repositoryProvider\\\n    ],\n  );\n\n  // The first read if the loading state\n  expect(\n    container.read(todoListProvider),\n    const AsyncValue<List<Todo>>.loading(),\n  );\n\n  /// Wait for the request to finish\n  await container.read(todoListProvider.future);\n\n  // Exposes the data fetched\n  expect(container.read(todoListProvider).value, [\\\n    isA<Todo>()\\\n        .having((s) => s.id, 'id', '42')\\\n        .having((s) => s.label, 'label', 'Hello world')\\\n        .having((s) => s.completed, 'completed', false),\\\n  ]);\n});\n\n```\n\nAs you can see by the highlighted code, [ProviderScope](https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/ProviderScope-class.html)/ [ProviderContainer](https://pub.dev/documentation/riverpod/latest/riverpod/ProviderContainer-class.html)\nallows replacing the implementation of a provider with a different behavior.\n\ninfo\n\nSome providers expose simplified ways to override their behavior.\n\nFor example, [FutureProvider](/docs/providers/future_provider) allows overriding the provider with an `AsyncValue`:\n\n```codeBlockLines_e6Vv\n\nfinal todoListProvider = FutureProvider((ref) async => <Todo>[]);\n// ...\n/* SKIP */\nfinal foo =\n/* SKIP END */\n    ProviderScope(\n  overrides: [\\\n    /// Allows overriding a FutureProvider to return a fixed value\\\n    todoListProvider.overrideWithValue(\\\n      AsyncValue.data([Todo(id: '42', label: 'Hello', completed: true)]),\\\n    ),\\\n  ],\n  child: const MyApp(),\n);\n\n```\n\n**Note**: As part of the 2.0.0 release, `overrideWithValue` methods are temporarily\nremoved. They will be added back in later versions.\n\ninfo\n\nThe syntax for overriding a provider with the `family` modifier is slightly different.\n\nIf you used a provider like this:\n\n```codeBlockLines_e6Vv\nfinal response = ref.watch(myProvider('12345'));\n\n```\n\nYou could override the provider as:\n\n```codeBlockLines_e6Vv\nmyProvider('12345').overrideWithValue(...));\n\n```\n\n## Full widget test example [​](\\#full-widget-test-example \"Direct link to Full widget test example\")\n\nWrapping up, here is the entire full code for our Flutter test.\n\n```codeBlockLines_e6Vv\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:flutter_test/flutter_test.dart';\n\nclass Repository {\n  Future<List<Todo>> fetchTodos() async => [];\n}\n\nclass Todo {\n  Todo({\n    required this.id,\n    required this.label,\n    required this.completed,\n  });\n\n  final String id;\n  final String label;\n  final bool completed;\n}\n\n// We expose our instance of Repository in a provider\nfinal repositoryProvider = Provider((ref) => Repository());\n\n/// The list of todos. Here, we are simply fetching them from the server using\n/// [Repository] and doing nothing else.\nfinal todoListProvider = FutureProvider((ref) async {\n  // Obtains the Repository instance\n  final repository = ref.read(repositoryProvider);\n\n  // Fetch the todos and expose them to the UI.\n  return repository.fetchTodos();\n});\n\n/// A mocked implementation of Repository that returns a pre-defined list of todos\nclass FakeRepository implements Repository {\n  @override\n  Future<List<Todo>> fetchTodos() async {\n    return [\\\n      Todo(id: '42', label: 'Hello world', completed: false),\\\n    ];\n  }\n}\n\nclass TodoItem extends StatelessWidget {\n  const TodoItem({super.key, required this.todo});\n  final Todo todo;\n  @override\n  Widget build(BuildContext context) {\n    return Text(todo.label);\n  }\n}\n\nvoid main() {\n  testWidgets('override repositoryProvider', (tester) async {\n    await tester.pumpWidget(\n      ProviderScope(\n        overrides: [\\\n          repositoryProvider.overrideWithValue(FakeRepository())\\\n        ],\n        // Our application, which will read from todoListProvider to display the todo-list.\n        // You may extract this into a MyApp widget\n        child: MaterialApp(\n          home: Scaffold(\n            body: Consumer(builder: (context, ref, _) {\n              final todos = ref.watch(todoListProvider);\n              // The list of todos is loading or in error\n              if (todos.asData == null) {\n                return const CircularProgressIndicator();\n              }\n              return ListView(\n                children: [\\\n                  for (final todo in todos.asData!.value) TodoItem(todo: todo)\\\n                ],\n              );\n            }),\n          ),\n        ),\n      ),\n    );\n\n    // The first frame is a loading state.\n    expect(find.byType(CircularProgressIndicator), findsOneWidget);\n\n    // Re-render. TodoListProvider should have finished fetching the todos by now\n    await tester.pump();\n\n    // No longer loading\n    expect(find.byType(CircularProgressIndicator), findsNothing);\n\n    // Rendered one TodoItem with the data returned by FakeRepository\n    expect(tester.widgetList(find.byType(TodoItem)), [\\\n      isA<TodoItem>()\\\n          .having((s) => s.todo.id, 'todo.id', '42')\\\n          .having((s) => s.todo.label, 'todo.label', 'Hello world')\\\n          .having((s) => s.todo.completed, 'todo.completed', false),\\\n    ]);\n  });\n}\n\n```\n\n- [No state should be preserved between `test`/ `testWidgets`.](#no-state-should-be-preserved-between-testtestwidgets)\n- [Overriding the behavior of a provider during tests.](#overriding-the-behavior-of-a-provider-during-tests)\n- [Full widget test example](#full-widget-test-example)",
    "metadata": {
      "url": "https://riverpod.dev/docs/cookbooks/testing",
      "ogUrl": "https://riverpod.dev/docs/cookbooks/testing",
      "title": "Testing | Riverpod",
      "og:url": "https://riverpod.dev/docs/cookbooks/testing",
      "ogImage": "https://riverpod.dev/img/cover.png",
      "ogTitle": "Testing | Riverpod",
      "language": "en",
      "og:image": "https://riverpod.dev/img/cover.png",
      "og:title": "Testing | Riverpod",
      "viewport": "width=device-width, initial-scale=1.0",
      "generator": "Docusaurus v2.4.3",
      "sourceURL": "https://riverpod.dev/docs/cookbooks/testing",
      "statusCode": 200,
      "description": "The content of this page may be outdated.",
      "twitter:card": "summary_large_image",
      "ogDescription": "The content of this page may be outdated.",
      "twitter:image": "https://riverpod.dev/img/cover.png",
      "docusaurus_tag": "docs-default-current",
      "og:description": "The content of this page may be outdated.",
      "docsearch:version": "current",
      "docusaurus_locale": "en",
      "ogLocaleAlternate": [],
      "docsearch:language": "en",
      "docusaurus_version": "current",
      "docsearch:docusaurus_tag": "docs-default-current"
    }
  },
  {
    "markdown": "[Skip to main content](#__docusaurus_skipToContent_fallback)\n\nOn this page\n\ncaution\n\nThe content of this page may be outdated.\n\nIt will be updated in the future, but for now you may want to refer to the content\nin the top of the sidebar instead (introduction/essentials/case-studies/...)\n\nScoping in Riverpod is a very powerful feature, but like all powerful features, it should be used wisely and intentionally.\n\nA few of the things that scoping enables are:\n\n- Override the state of providers for a specific subtree (similar to how theming and `InheritedWidgets` work in flutter) [(see example)](#subtree-scope)\n- Creating synchronous providers for normally async APIs [(see example)](#initialization-of-synchronous-provider-for-async-apis)\n- Allowing `Dialog` s and `Overlay` s to inherit the state of providers from the widget subtree that cause them to be shown [(see example)](#showing-dialogs)\n- Optimizing rebuilds of widgets by removing parameters from Widget constructors allowing you to make them `const`\n\nIf you are wanting to use scope for the first point, chances are you can use families instead.\nFamilies have the advantages of allowing you to access each of those instances of the state from anywhere in the widget tree rather than just the state scoped to the specific subtree that you are in.\n\nUsing scope to create multiple instances of a provider's state is similar to how `package:provider` works.\n\nHowever, using scope to accomplish that task, is more restrictive, as you cannot decide to access other instances from that scope.\n\nAs such, before scoping every provider you use, consider carefully why you want to scope the provider.\n\n## ProviderScope and ProviderContainer [​](\\#providerscope-and-providercontainer \"Direct link to ProviderScope and ProviderContainer\")\n\nA scope is introduced by a [ProviderContainer](https://pub.dev/documentation/riverpod/latest/riverpod/ProviderContainer-class.html). This container holds the current state of all of your providers.\nIt manages the lookup and subscriptions between providers.\n\nIn Flutter you should use the [ProviderScope](https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/ProviderScope-class.html) widget, which contains a [ProviderContainer](https://pub.dev/documentation/riverpod/latest/riverpod/ProviderContainer-class.html)\ninternally, and provides a way to access that container to the rest of the widget tree.\n\n```codeBlockLines_e6Vv\nfinal valueProvider = StateProvider((ref) => 0);\n\n// DO this\nvoid main() {\n  runApp(ProviderScope(child: MyApp()));\n}\n\n//DON'T do this:\nfinal myProviderContainer = ProviderContainer();\nvoid main(){\n  runApp(MyApp());\n}\n\n```\n\ndanger\n\nDo not use multiple [ProviderContainer](https://pub.dev/documentation/riverpod/latest/riverpod/ProviderContainer-class.html) s, without an understanding of how they work.\nEach will have it's own separate thread of states, which will not be able to access each other.\nTests are an example of when you might want to use separate [ProviderContainer](https://pub.dev/documentation/riverpod/latest/riverpod/ProviderContainer-class.html) s\nin order to make each test's state independent of the others.\n\nOnly create a [ProviderContainer](https://pub.dev/documentation/riverpod/latest/riverpod/ProviderContainer-class.html) without a [ProviderScope](https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/ProviderScope-class.html) for testing and dart-only usage.\n\n## How Riverpod Finds a Provider [​](\\#how-riverpod-finds-a-provider \"Direct link to How Riverpod Finds a Provider\")\n\nWhen a widget or provider requests the value of a provider, Riverpod looks up the state of that provider in the nearest\n[ProviderScope](https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/ProviderScope-class.html) widget. If neither the provider nor one of it's explicitly listed dependencies is overridden in that scope Riverpod continues it's lookup up the widget tree.\nIf the provider has not been overridden in any Widget subtrees the lookup defaults to the [ProviderContainer](https://pub.dev/documentation/riverpod/latest/riverpod/ProviderContainer-class.html) in the root [ProviderScope](https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/ProviderScope-class.html).\n\nOnce this process locates the scope in which the provider should reside it determines if the provider has been created yet.\nIf so, it will return the state of the provider.\nHowever, if the provider has been invalidated or is not currently initialized it will create the state using the provider's build method.\n\n## Initialization of Synchronous Provider for Async APIs [​](\\#initialization-of-synchronous-provider-for-async-apis \"Direct link to Initialization of Synchronous Provider for Async APIs\")\n\nOften you might have some async initialization of a dependency such as `SharedPreferences` or `FirebaseApp`.\nMany other providers might rely on this, and dealing with the error / loading states in each of those providers is redundant.\n\nYou might be able to guarantee that those providers will not have errors and will load quickly when the app is started.\n\nSo how do you makes these sorts of provider states available synchronously?\n\nHere is an example that shows how scoping allows you override a dummy provider when your asynchronous API is ready.\n\n```codeBlockLines_e6Vv\nfinal countProvider = NotifierProvider<CountNotifier, int>(CountNotifier.new);\n\nclass CountNotifier extends Notifier<int> {\n  @override\n  int build() {\n    // We'd like to obtain an instance of shared preferences synchronously in a provider\n    final preferences = ref.watch(sharedPreferencesProvider);\n    final currentValue = preferences.getInt('count') ?? 0;\n    listenSelf((prev, next) {\n      preferences.setInt('count', next);\n    });\n    return currentValue;\n  }\n\n  void increment() => state++;\n}\n\n// We don't have an actual instance of SharedPreferences, and we can't get one except asynchronously\nfinal sharedPreferencesProvider =\n    Provider<SharedPreferences>((ref) => throw UnimplementedError());\n\nFuture<void> main() async {\n  // Show a loading indicator before running the full app (optional)\n  // The platform's loading screen will be used while awaiting if you omit this.\n  runApp(const LoadingScreen());\n\n  // Get the instance of shared preferences\n  final prefs = await SharedPreferences.getInstance();\n  return runApp(\n    ProviderScope(\n      overrides: [\\\n        // Override the unimplemented provider with the value gotten from the plugin\\\n        sharedPreferencesProvider.overrideWithValue(prefs),\\\n      ],\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends ConsumerWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // Use the provider without dealing with async issues\n    final count = ref.watch(countProvider);\n    return Text('$count');\n  }\n}\n\n```\n\n## Subtree Scoping [​](\\#subtree-scoping \"Direct link to Subtree Scoping\")\n\nScoping allows you to override the state of a provider for a specific subtree of your widget tree.\nIn this way it can provide a similar mechanism to `InheritedWidget` from flutter, or the providers from `package:provider`.\n\nFor example, in flutter you can override the `Theme` for a particular subtree of your widget tree, by wrapping it in a `Theme` widget.\n\n```codeBlockLines_e6Vv\n\nvoid main() {\n  runApp(\n    ProviderScope(\n      child: MaterialApp(\n        theme: ThemeData(primaryColor: Colors.blue),\n        home: const Home(),\n      ),\n    ),\n  );\n}\n\n// Have a counter that is being incremented\nfinal counterProvider = StateProvider(\n  (ref) => 0,\n);\n\nclass Home extends ConsumerWidget {\n  const Home({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    return Scaffold(\n        body: Column(\n      children: [\\\n        // This counter will have a primary color of green\\\n        Theme(\\\n          data: Theme.of(context).copyWith(primaryColor: Colors.green),\\\n          child: const CounterDisplay(),\\\n        ),\\\n        // This counter will have a primary color of blue\\\n        const CounterDisplay(),\\\n        ElevatedButton(\\\n          onPressed: () {\\\n            ref.read(counterProvider.notifier).state++;\\\n          },\\\n          child: const Text('Increment Count'),\\\n        ),\\\n      ],\n    ));\n  }\n}\n\nclass CounterDisplay extends ConsumerWidget {\n  const CounterDisplay({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final count = ref.watch(counterProvider);\n    final theme = Theme.of(context);\n    return Column(\n      mainAxisSize: MainAxisSize.min,\n      children: [\\\n        Text(\\\n          '$count',\\\n          style: theme.textTheme.displayMedium\\\n              ?.copyWith(color: theme.primaryColor),\\\n        ),\\\n      ],\n    );\n  }\n}\n\n```\n\nUnder the hood, `Theme` is an `InheritedWidget` and when widgets look up the `Theme` they get the `Theme` from the nearest `Theme` widget above it in the widget tree.\n\nRiverpod works differently, since all of the state of your application is typically stored in a root [ProviderScope](https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/ProviderScope-class.html) widget.\nDon't worry, this doesn't cause your whole application to rebuild when the state changes, it just allows you to access the state from anywhere in your widget tree.\n\nWhat if you want different providers depending on which page you are in?\n\nThe first thing that you should consider is whether the provided behavior will differ in any way.\n\nIf so -> just create a new provider with a different name and use it in that page\n\nIf not -> Consider using a [.family](/docs/concepts/modifiers/family).\n\nOften you start by thinking that you only need a provider on a particular page, but end up wanting to use it in another page later on.\nFamilies protect you against this eventuality, and are a major difference in how you should adjust your thinking if you are coming from `package:provider`.\n\nIf families really do not fit your use case, the following example shows you how to override a provider for a particular subtree.\n\n```codeBlockLines_e6Vv\n\n/// A counter that is being incremented by each [CounterDisplay]'s ElevatedButton\nfinal counterProvider = StateProvider(\n  (ref) => 0,\n);\n\nfinal adjustedCountProvider = Provider(\n  (ref) => ref.watch(counterProvider) * 2,\n  // Note that if a provider depends on a provider that is overridden for a subtree,\n  // you must explicitly list that provider in your dependencies list.\n  dependencies: [counterProvider],\n);\n\nclass Home extends ConsumerWidget {\n  const Home({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    return Scaffold(\n        body: Column(\n      children: [\\\n        ProviderScope(\\\n          /// Just specify which provider you want to have a copy of in the subtree\\\n          ///\\\n          /// Note that dependant providers such as [adjustedCountProvider] will\\\n          /// also be copied for this subtree. If that is not the behavior you want,\\\n          /// consider using families instead\\\n          overrides: [counterProvider],\\\n          child: const CounterDisplay(),\\\n        ),\\\n        ProviderScope(\\\n          // You can change the provider's behavior in a particular subtree\\\n          overrides: [counterProvider.overrideWith((ref) => 1)],\\\n          child: const CounterDisplay(),\\\n        ),\\\n        ProviderScope(\\\n          overrides: [\\\n            counterProvider,\\\n            // You can also change dependent provider's behaviors\\\n            adjustedCountProvider.overrideWith(\\\n              (ref) => ref.watch(counterProvider) * 3,\\\n            ),\\\n          ],\\\n          child: const CounterDisplay(),\\\n        ),\\\n        // This particular display will use the provider state from the root ProviderScope\\\n        const CounterDisplay(),\\\n      ],\n    ));\n  }\n}\n\nclass CounterDisplay extends ConsumerWidget {\n  const CounterDisplay({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final count = ref.watch(counterProvider);\n    return Column(\n      mainAxisSize: MainAxisSize.min,\n      children: [\\\n        Text('$count'),\\\n        ElevatedButton(\\\n          onPressed: () {\\\n            ref.read(counterProvider.notifier).state++;\\\n          },\\\n          child: const Text('Increment Count'),\\\n        ),\\\n      ],\n    );\n  }\n}\n\n```\n\n## When to choose Scoped Providers or Families [​](\\#when-to-choose-scoped-providers-or-families \"Direct link to When to choose Scoped Providers or Families\")\n\nWhile scopes are important to understand, it is easy to get carried away when using scopes.\n\nIf you want a different instance of a provider's state depending on where it is in the widget tree you have a few alternatives available to you: `Scoping`, `Families`, or a combination.\nThe appropriate choice depends on your use case.\n\nFamilies:\n\n- Pro: You can show multiple of the states no matter which subtree you are in\n- Pro: This makes it a more flexible and scalable solution for many use cases\n\nScoping:\n\n- Con: You end up with more nesting of [ProviderScope](https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/ProviderScope-class.html) widgets in your widget tree\n- Con: You can only access the one override in your section of the widget tree\n- Con: You end up having to explicitly list the dependencies of most of your providers\n- Pro: You can reduce the number of parameters in your widget constructors\n- Pro: You get a slight performance advantage, and can potentially make some of your widget constructors `const`\n\nUsing a combination of the two approaches, you can get the pros of both approaches, but you still have to deal with the cons of scoping.\n\ndanger\n\nRemember that scopes introduce a new instance of the state of every provider that is overridden or has listed a dependency on a provider that was overridden.\nIf you override with the same parameter in a different subtree of the app, it will **not** be the same instance of the provider's state.\nFamilies are more flexible in general, and with the upcoming code generation feature it is easy to use multiple parameters for a family.\nOften a good combination is to use both families and scoping. Use a family to provide general access to a piece of state anywhere in your app, and then use scoping to\nprovide a specific instance of the family's state depending on where you are in the widget tree.\n\n### Less common usages of Scopes [​](\\#less-common-usages-of-scopes \"Direct link to Less common usages of Scopes\")\n\nSometimes you may want to override a whole set of providers in a specific subtree of your app.\nBy listing a common provider in the dependencies list of each of those providers, you can easily create new states for all of them at once, by overriding the common one.\n\nNote that if you try to use families for this, you will end up with many families that all have the same parameter, and you could end up passing that parameter all over the widget tree.\nIn this case it is also acceptable to use scopes.\n\ndanger\n\nOnce you start using scope, make sure to always list your dependencies and keep them up to date, to prevent runtime exceptions.\nTo help with this we have created [riverpod\\_lint](https://github.com/rrousselGit/riverpod/tree/master/packages/riverpod_lint) which will warn you if there is a missing dependency.\nAdditionally with [riverpod\\_generator](https://github.com/rrousselGit/riverpod/tree/master/packages/riverpod_generator) the code generator automatically generates the dependency list.\n\n- [ProviderScope and ProviderContainer](#providerscope-and-providercontainer)\n- [How Riverpod Finds a Provider](#how-riverpod-finds-a-provider)\n- [Initialization of Synchronous Provider for Async APIs](#initialization-of-synchronous-provider-for-async-apis)\n- [Subtree Scoping](#subtree-scoping)\n- [When to choose Scoped Providers or Families](#when-to-choose-scoped-providers-or-families)\n  - [Less common usages of Scopes](#less-common-usages-of-scopes)",
    "metadata": {
      "url": "https://riverpod.dev/docs/concepts/scopes",
      "ogUrl": "https://riverpod.dev/docs/concepts/scopes",
      "title": "Scopes | Riverpod",
      "og:url": "https://riverpod.dev/docs/concepts/scopes",
      "ogImage": "https://riverpod.dev/img/cover.png",
      "ogTitle": "Scopes | Riverpod",
      "language": "en",
      "og:image": "https://riverpod.dev/img/cover.png",
      "og:title": "Scopes | Riverpod",
      "viewport": "width=device-width, initial-scale=1.0",
      "generator": "Docusaurus v2.4.3",
      "sourceURL": "https://riverpod.dev/docs/concepts/scopes",
      "statusCode": 200,
      "description": "The content of this page may be outdated.",
      "twitter:card": "summary_large_image",
      "ogDescription": "The content of this page may be outdated.",
      "twitter:image": "https://riverpod.dev/img/cover.png",
      "docusaurus_tag": "docs-default-current",
      "og:description": "The content of this page may be outdated.",
      "docsearch:version": "current",
      "docusaurus_locale": "en",
      "ogLocaleAlternate": [],
      "docsearch:language": "en",
      "docusaurus_version": "current",
      "docsearch:docusaurus_tag": "docs-default-current"
    }
  },
  {
    "markdown": "[Skip to main content](#__docusaurus_skipToContent_fallback)\n\nOn this page\n\nCode generation is the idea of using a tool to generate code for us.\nIn Dart, it comes with the downside of requiring an extra step to \"compile\"\nan application. Although this problem may be solved in the near future, as the\nDart team is working on a potential solution to this problem.\n\nIn the context of Riverpod, code generation is about slightly changing the syntax\nfor defining a \"provider\". For example, instead of:\n\n```codeBlockLines_e6Vv\nfinal fetchUserProvider = FutureProvider.autoDispose.family<User, int>((ref, userId) async {\n  final json = await http.get('api/user/$userId');\n  return User.fromJson(json);\n});\n\n```\n\nUsing code generation, we would write:\n\n```codeBlockLines_e6Vv\n@riverpod\nFuture<User> fetchUser(Ref ref, {required int userId}) async {\n  final json = await http.get('api/user/$userId');\n  return User.fromJson(json);\n}\n\n```\n\nWhen using Riverpod, code generation is completely optional. It is entirely possible\nto use Riverpod without.\nAt the same time, Riverpod embraces code generation and recommends using it.\n\nFor information on how to install and use Riverpod's code generator, refer to\nthe [Getting started](/docs/introduction/getting_started) page. Make sure to enable code generation\nin the documentation's sidebar.\n\n## Should I use code generation? [​](\\#should-i-use-code-generation \"Direct link to Should I use code generation?\")\n\nCode generation is optional in Riverpod.\nWith that in mind, you may wonder if you should use it or not.\n\nThe answer is: **Most likely Yes**.\n\nUsing code generation is the recommended way to use Riverpod. It\nis the more future-proof approach and will allow you to use Riverpod to its full\npotential.\n\nAt the same time, many applications already use code generation with packages such\nas [Freezed](https://pub.dev/packages/freezed) or [json\\_serializable](https://pub.dev/packages/json_serializable).\nIn that case, your project probably is already set up for code generation, and\nusing Riverpod should be simple.\n\nCurrently, code generation is optional because `build_runner` is disliked by many.\nBut once [Static Metaprogramming](https://github.com/dart-lang/language/issues/1482)\nis available in Dart, `build_runner` will no longer be an issue. At that point,\nthe code generation syntax will be the only syntax available in Riverpod.\n\nIf using `build_runner` is a deal-breaker for you, then and only then you should\nconsider not using code generation.\nBut keep in mind that you will be missing out on some features, and that\nyou will have to migrate to code generation in the future.\n\nAlthough when that happens, Riverpod will provide a migration tool to make\nthe transition as smoothly as possible.\n\n## What are the benefits of using code generation? [​](\\#what-are-the-benefits-of-using-code-generation \"Direct link to What are the benefits of using code generation?\")\n\nYou may be wondering: \"If code generation is optional in Riverpod, why use it?\"\n\nAs always with packages: To make your life easier.\nThis includes but is not limited to:\n\n- Better syntax, more readable/flexible, and with a reduced learning curve.\n  - No need to worry about the type of provider. Write your logic,\n    and Riverpod will pick the most suitable provider for you.\n  - The syntax no longer looks like we're defining a \"dirty global variable\".\n    Instead we are defining a custom function/class.\n  - Passing parameters to providers is now unrestricted. Instead of being limited to\n    using [.family](/docs/concepts/modifiers/family) and passing a single positional parameter,\n    you can now pass any parameter. This includes named parameters, optional ones,\n    and even default values.\n- **Stateful hot-reload** of the code written in Riverpod.\n- Better debugging, through the generation of extra metadata that the debugger then picks up.\n- Some Riverpod features will be available only with code generation.\n\n## The Syntax [​](\\#the-syntax \"Direct link to The Syntax\")\n\n### Defining a provider: [​](\\#defining-a-provider \"Direct link to Defining a provider:\")\n\nWhen defining a provider using code generation, it is helpful to keep in mind the following points:\n\n- Providers can be defined either as an annotated function or\nas an annotated class. They are pretty much the same,\nbut Class-based provider has the advantage of including public methods that enable\nexternal objects to modify the state of the provider (side-effects). Functional providers\nare syntax sugar for writing a Class-based provider with nothing but a `build` method,\nand as such cannot be modified by the UI.\n- All Dart async primitives (Future, FutureOr, and Stream) are supported.\n- When a function is marked as async, the provider automatically handles\nerrors/loading states and exposes an AsyncValue.\n\n|  | Functional<br>(Can’t perform side-effects<br>using public methods) | Class-Based<br>(Can perform side-effects<br>using public methods) |\n| Sync | ```codeBlockLines_e6Vv<br>@riverpod<br>String example(Ref ref) {<br>  return 'foo';<br>}<br>``` | ```codeBlockLines_e6Vv<br>@riverpod<br>class Example extends _$Example {<br>  @override<br>  String build() {<br>    return 'foo';<br>  }<br>  // Add methods to mutate the state<br>}<br>``` |\n| Async - Future | ```codeBlockLines_e6Vv<br>@riverpod<br>Future<String> example(Ref ref) async {<br>  return Future.value('foo');<br>}<br>``` | ```codeBlockLines_e6Vv<br>@riverpod<br>class Example extends _$Example {<br>  @override<br>  Future<String> build() async {<br>    return Future.value('foo');<br>  }<br>  // Add methods to mutate the state<br>}<br>``` |\n| Async - Stream | ```codeBlockLines_e6Vv<br>@riverpod<br>Stream<String> example(Ref ref) async* {<br>  yield 'foo';<br>}<br>``` | ```codeBlockLines_e6Vv<br>@riverpod<br>class Example extends _$Example {<br>  @override<br>  Stream<String> build() async* {<br>    yield 'foo';<br>  }<br>  // Add methods to mutate the state<br>}<br>``` |\n\n### Enabling/disable autoDispose: [​](\\#enablingdisable-autodispose \"Direct link to Enabling/disable autoDispose:\")\n\nWhen using code generation, providers are autoDispose by default. That means that they will automatically\ndispose of themselves when there are no listeners attached to them (ref.watch/ref.listen).\n\nThis default setting better aligns with Riverpod's philosophy. Initially with the non-code generation variant,\nautoDispose was off by default to accommodate users migrating from `package:provider`.\n\nIf you want to disable autoDispose, you can do so by passing `keepAlive: true` to the annotation.\n\n```codeBlockLines_e6Vv\n// AutoDispose provider (keepAlive is false by default)\n@riverpod\nString example1(Ref ref) => 'foo';\n\n// Non autoDispose provider\n@Riverpod(keepAlive: true)\nString example2(Ref ref) => 'foo';\n\n```\n\n### Passing parameters to a provider (family): [​](\\#passing-parameters-to-a-provider-family \"Direct link to Passing parameters to a provider (family):\")\n\nWhen using code generation, we no-longer need to rely on the `family` modifier to pass parameters to a provider.\nInstead, the main function of our provider can accept any number of parameters, including named, optional, or default values.\n\nDo note however that these parameters should have still have a consistent ==.\nMeaning either the values should be cached, or the parameters should override ==.\n\n| Functional | Class-Based |\n| ```codeBlockLines_e6Vv<br>@riverpod<br>String example(<br>  Ref ref,<br>  int param1, {<br>  String param2 = 'foo',<br>}) {<br>  return 'Hello $param1 & param2';<br>}<br>``` | ```codeBlockLines_e6Vv<br>@riverpod<br>class Example extends _$Example {<br>  @override<br>  String build(<br>    int param1, {<br>    String param2 = 'foo',<br>  }) {<br>    return 'Hello $param1 & param2';<br>  }<br>  // Add methods to mutate the state<br>}<br>``` |\n\n## Migrate from non-code-generation variant: [​](\\#migrate-from-non-code-generation-variant \"Direct link to Migrate from non-code-generation variant:\")\n\nWhen using non-code-generation variant, it is necessary to manually determine the type of your provider.\nThe following are the corresponding options for transitioning into code-generation variant:\n\n|     |     |\n| --- | --- |\n| Provider |\n| Before | ```codeBlockLines_e6Vv<br>final exampleProvider = Provider.autoDispose<String>(<br>  (ref) {<br>    return 'foo';<br>  },<br>);<br>``` |\n| After | ```codeBlockLines_e6Vv<br>@riverpod<br>String example(Ref ref) {<br>  return 'foo';<br>}<br>``` |\n| NotifierProvider |\n| Before | ```codeBlockLines_e6Vv<br>final exampleProvider = NotifierProvider.autoDispose<ExampleNotifier, String>(<br>  ExampleNotifier.new,<br>);<br>class ExampleNotifier extends AutoDisposeNotifier<String> {<br>  @override<br>  String build() {<br>    return 'foo';<br>  }<br>  // Add methods to mutate the state<br>}<br>``` |\n| After | ```codeBlockLines_e6Vv<br>@riverpod<br>class Example extends _$Example {<br>  @override<br>  String build() {<br>    return 'foo';<br>  }<br>  // Add methods to mutate the state<br>}<br>``` |\n| FutureProvider |\n| Before | ```codeBlockLines_e6Vv<br>final exampleProvider =<br>    FutureProvider.autoDispose<String>((ref) async {<br>  return Future.value('foo');<br>});<br>``` |\n| After | ```codeBlockLines_e6Vv<br>@riverpod<br>Future<String> example(Ref ref) async {<br>  return Future.value('foo');<br>}<br>``` |\n| StreamProvider |\n| Before | ```codeBlockLines_e6Vv<br>final exampleProvider =<br>    StreamProvider.autoDispose<String>((ref) async* {<br>  yield 'foo';<br>});<br>``` |\n| After | ```codeBlockLines_e6Vv<br>@riverpod<br>Stream<String> example(Ref ref) async* {<br>  yield 'foo';<br>}<br>``` |\n| AsyncNotifierProvider |\n| Before | ```codeBlockLines_e6Vv<br>final exampleProvider =<br>    AsyncNotifierProvider.autoDispose<ExampleNotifier, String>(<br>  ExampleNotifier.new,<br>);<br>class ExampleNotifier extends AutoDisposeAsyncNotifier<String> {<br>  @override<br>  Future<String> build() async {<br>    return Future.value('foo');<br>  }<br>  // Add methods to mutate the state<br>}<br>``` |\n| After | ```codeBlockLines_e6Vv<br>@riverpod<br>class Example extends _$Example {<br>  @override<br>  Future<String> build() async {<br>    return Future.value('foo');<br>  }<br>  // Add methods to mutate the state<br>}<br>``` |\n| StreamNotifierProvider |\n| Before | ```codeBlockLines_e6Vv<br>final exampleProvider =<br>    StreamNotifierProvider.autoDispose<ExampleNotifier, String>(() {<br>  return ExampleNotifier();<br>});<br>class ExampleNotifier extends AutoDisposeStreamNotifier<String> {<br>  @override<br>  Stream<String> build() async* {<br>    yield 'foo';<br>  }<br>  // Add methods to mutate the state<br>}<br>``` |\n| After | ```codeBlockLines_e6Vv<br>@riverpod<br>class Example extends _$Example {<br>  @override<br>  Stream<String> build() async* {<br>    yield 'foo';<br>  }<br>  // Add methods to mutate the state<br>}<br>``` |\n\n- [Should I use code generation?](#should-i-use-code-generation)\n- [What are the benefits of using code generation?](#what-are-the-benefits-of-using-code-generation)\n- [The Syntax](#the-syntax)\n  - [Defining a provider:](#defining-a-provider)\n  - [Enabling/disable autoDispose:](#enablingdisable-autodispose)\n  - [Passing parameters to a provider (family):](#passing-parameters-to-a-provider-family)\n- [Migrate from non-code-generation variant:](#migrate-from-non-code-generation-variant)",
    "metadata": {
      "url": "https://riverpod.dev/docs/concepts/about_code_generation",
      "ogUrl": "https://riverpod.dev/docs/concepts/about_code_generation",
      "title": "About code generation | Riverpod",
      "og:url": "https://riverpod.dev/docs/concepts/about_code_generation",
      "ogImage": "https://riverpod.dev/img/cover.png",
      "ogTitle": "About code generation | Riverpod",
      "language": "en",
      "og:image": "https://riverpod.dev/img/cover.png",
      "og:title": "About code generation | Riverpod",
      "viewport": "width=device-width, initial-scale=1.0",
      "generator": "Docusaurus v2.4.3",
      "sourceURL": "https://riverpod.dev/docs/concepts/about_code_generation",
      "statusCode": 200,
      "description": "Code generation is the idea of using a tool to generate code for us.",
      "twitter:card": "summary_large_image",
      "ogDescription": "Code generation is the idea of using a tool to generate code for us.",
      "twitter:image": "https://riverpod.dev/img/cover.png",
      "docusaurus_tag": "docs-default-current",
      "og:description": "Code generation is the idea of using a tool to generate code for us.",
      "docsearch:version": "current",
      "docusaurus_locale": "en",
      "ogLocaleAlternate": [],
      "docsearch:language": "en",
      "docusaurus_version": "current",
      "docsearch:docusaurus_tag": "docs-default-current"
    }
  },
  {
    "markdown": "[Skip to main content](#__docusaurus_skipToContent_fallback)\n\nOn this page\n\ncaution\n\nThe content of this page may be outdated.\n\nIt will be updated in the future, but for now you may want to refer to the content\nin the top of the sidebar instead (introduction/essentials/case-studies/...)\n\nBefore reading this guide, make sure to [Providers](/docs/concepts/providers) first.\n\nIn this guide, we will see how to consume a provider.\n\n## Obtaining a \"ref\" object [​](\\#obtaining-a-ref-object \"Direct link to Obtaining a \\\"ref\\\" object\")\n\nFirst and foremost, before reading a provider, we need to obtain a \"ref\" object.\n\nThis object is what allows us to interact with providers, be it from a widget\nor another provider.\n\n### Obtaining a \"ref\" from a provider [​](\\#obtaining-a-ref-from-a-provider \"Direct link to Obtaining a \\\"ref\\\" from a provider\")\n\nAll providers receive a \"ref\" as a parameter:\n\n```codeBlockLines_e6Vv\n\n@riverpod\nString value(Ref ref) {\n  // use ref to obtain other providers\n  final repository = ref.watch(repositoryProvider);\n  return repository.get();\n}\n\n```\n\nThis parameter is safe to pass to the value exposed by the provider.\n\n```codeBlockLines_e6Vv\n\n@riverpod\nclass Counter extends _$Counter {\n  @override\n  int build() => 0;\n\n  void increment() {\n    // Counter can use the \"ref\" to read other providers\n    final repository = ref.read(repositoryProvider);\n    repository.post('...');\n  }\n}\n\n```\n\nDoing so allows our `Counter` class to read providers.\n\n### Obtaining a \"ref\" from a widget [​](\\#obtaining-a-ref-from-a-widget \"Direct link to Obtaining a \\\"ref\\\" from a widget\")\n\nWidgets naturally do not have a ref parameter. But [Riverpod](https://github.com/rrousselgit/riverpod) offers multiple\nsolutions to obtain one from widgets.\n\n#### Extending ConsumerWidget instead of StatelessWidget [​](\\#extending-consumerwidget-instead-of-statelesswidget \"Direct link to Extending ConsumerWidget instead of StatelessWidget\")\n\nThe most common way to obtain a ref in the widget tree is\nto replace [StatelessWidget](https://api.flutter.dev/flutter/widgets/StatelessWidget-class.html) with [ConsumerWidget](https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/ConsumerWidget-class.html).\n\n[ConsumerWidget](https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/ConsumerWidget-class.html) is identical in use to [StatelessWidget](https://api.flutter.dev/flutter/widgets/StatelessWidget-class.html), with the only\ndifference being that it has an extra parameter on its build method: the \"ref\" object.\n\nA typical [ConsumerWidget](https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/ConsumerWidget-class.html) looks like:\n\n```codeBlockLines_e6Vv\n\nclass HomeView extends ConsumerWidget {\n  const HomeView({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // use ref to listen to a provider\n    final counter = ref.watch(counterProvider);\n    return Text('$counter');\n  }\n}\n\n```\n\n#### Extending ConsumerStatefulWidget+ConsumerState instead of StatefulWidget+State [​](\\#extending-consumerstatefulwidgetconsumerstate-instead-of-statefulwidgetstate \"Direct link to Extending ConsumerStatefulWidget+ConsumerState instead of StatefulWidget+State\")\n\nSimilar to [ConsumerWidget](https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/ConsumerWidget-class.html), [ConsumerStatefulWidget](https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/ConsumerState-class.html) and [ConsumerState](https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/ConsumerStatefulWidget-class.html) are the equivalent of a\n[StatefulWidget](https://api.flutter.dev/flutter/widgets/StatefulWidget-class.html) with its [State](https://api.flutter.dev/flutter/widgets/State-class.html), with the difference that the state has a \"ref\" object.\n\nThis time, the \"ref\" isn't passed as parameter of the build method, but is\na property of the [ConsumerState](https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/ConsumerStatefulWidget-class.html) object:\n\n```codeBlockLines_e6Vv\n\nclass HomeView extends ConsumerStatefulWidget {\n  const HomeView({super.key});\n\n  @override\n  HomeViewState createState() => HomeViewState();\n}\n\nclass HomeViewState extends ConsumerState<HomeView> {\n  @override\n  void initState() {\n    super.initState();\n    // \"ref\" can be used in all life-cycles of a StatefulWidget.\n    ref.read(counterProvider);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // We can also use \"ref\" to listen to a provider inside the build method\n    final counter = ref.watch(counterProvider);\n    return Text('$counter');\n  }\n}\n\n```\n\n## Using ref to interact with providers [​](\\#using-ref-to-interact-with-providers \"Direct link to Using ref to interact with providers\")\n\nNow that we have a \"ref\", we can start using it.\n\nThere are three primary usages for \"ref\":\n\n- obtaining the value of a provider and listening to changes, such that when\nthis value changes, this will rebuild the widget or provider that subscribed\nto the value.\nThis is done using `ref.watch`\n- adding a listener on a provider, to execute an action such as navigating to a new\npage or showing a modal whenever that provider changes.\n\nThis is done using `ref.listen`.\n- obtaining the value of a provider while ignoring changes.\nThis is useful when we need the value of a provider in an event\nsuch as \"on click\".\nThis is done using `ref.read`.\n\nnote\n\nWhenever possible, prefer using `ref.watch` over `ref.read` or `ref.listen` to\nimplement a feature.\n\nBy relying on `ref.watch`, your application becomes both reactive\nand declarative, which makes it more maintainable.\n\n### Using ref.watch to observe a provider [​](\\#using-refwatch-to-observe-a-provider \"Direct link to Using ref.watch to observe a provider\")\n\n`ref.watch` is used inside the `build` method of a widget or\ninside the body of a provider to have the widget/provider listen to a provider:\n\nFor example, a provider could use `ref.watch` to combine multiple providers\ninto a new value.\n\nAn example would be filtering a todo-list.\nWe could have two providers:\n\n- `filterTypeProvider`, a provider that exposes the current type of filter\n(none, show only completed tasks, ...)\n- `todosProvider`, a provider that exposes the entire list of tasks\n\nAnd by using `ref.watch`, we could make a third provider that combines both providers to\ncreate a filtered list of tasks:\n\n```codeBlockLines_e6Vv\n\n@riverpod\nFilterType filterType(Ref ref) {\n  return FilterType.none;\n}\n\n@riverpod\nclass Todos extends _$Todos {\n  @override\n  List<Todo> build() {\n    return [];\n  }\n}\n\n@riverpod\nList<Todo> filteredTodoList(Ref ref) {\n  // obtains both the filter and the list of todos\n  final FilterType filter = ref.watch(filterTypeProvider);\n  final List<Todo> todos = ref.watch(todosProvider);\n\n  switch (filter) {\n    case FilterType.completed:\n      // return the completed list of todos\n      return todos.where((todo) => todo.isCompleted).toList();\n    case FilterType.none:\n      // returns the unfiltered list of todos\n      return todos;\n  }\n}\n\n```\n\nWith this code, `filteredTodoListProvider` now exposes the filtered list of tasks.\n\nThe filtered list will also automatically update if either the filter or the list of tasks\nchanged. At the same time, the filtered list will not be recomputed if\nneither the filter nor the list of tasks changed.\n\nSimilarly, a widget can use `ref.watch` to show\nthe content from a provider and update the user interface whenever that content changes:\n\n```codeBlockLines_e6Vv\n\n@riverpod\nint counter(Ref ref) => 0;\n\nclass HomeView extends ConsumerWidget {\n  const HomeView({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // use ref to listen to a provider\n    final counter = ref.watch(counterProvider);\n\n    return Text('$counter');\n  }\n}\n\n```\n\nThis snippet shows a widget that listens to a provider which stores a `count`.\nAnd if that `count` changes, the widget will rebuild and the UI will update\nto show the new value.\n\ncaution\n\nThe `watch` method should not be called asynchronously,\nlike inside an `onPressed` of an [ElevatedButton](https://api.flutter.dev/flutter/material/ElevatedButton-class.html). Nor should it be used\ninside `initState` and other [State](https://api.flutter.dev/flutter/widgets/State-class.html) life-cycles.\n\nIn those cases, consider using `ref.read` instead.\n\n### Using ref.listen to react to a provider change [​](\\#using-reflisten-to-react-to-a-provider-change \"Direct link to Using ref.listen to react to a provider change\")\n\nSimilarly to `ref.watch`, it is possible to use `ref.listen` to observe a provider.\n\nThe main difference between them is that, rather than rebuilding the widget/provider\nif the listened to provider changes, using `ref.listen` will instead call a custom function.\n\nThat can be useful for performing actions when a certain change happens, such\nas showing a snackbar when an error happens.\n\nThe `ref.listen` method needs 2 positional arguments, the first one is the Provider and the second one is the callback function that we want to execute when the state changes.\nThe callback function when called will be passed 2 values, the value of the previous State and the value of the new State.\n\nThe `ref.listen` method can be used inside the body of a provider:\n\n```codeBlockLines_e6Vv\n\n@riverpod\nvoid another(Ref ref) {\n  ref.listen<int>(counterProvider, (int? previousCount, int newCount) {\n    print('The counter changed $newCount');\n  });\n  // ...\n}\n\n```\n\nor inside the `build` method of a widget:\n\n```codeBlockLines_e6Vv\n\n@riverpod\nclass Counter extends _$Counter {\n  @override\n  int build() => 0;\n}\n\nclass HomeView extends ConsumerWidget {\n  const HomeView({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    ref.listen<int>(counterProvider, (int? previousCount, int newCount) {\n      print('The counter changed $newCount');\n    });\n\n    return Container();\n  }\n}\n\n```\n\ncaution\n\nThe `listen` method should not be called asynchronously,\nlike inside an `onPressed` of an [ElevatedButton](https://api.flutter.dev/flutter/material/ElevatedButton-class.html). Nor should it be used\ninside `initState` and other [State](https://api.flutter.dev/flutter/widgets/State-class.html) life-cycles.\n\n### Using ref.read to obtain the state of a provider [​](\\#using-refread-to-obtain-the-state-of-a-provider \"Direct link to Using ref.read to obtain the state of a provider\")\n\nThe `ref.read` method is a way to obtain the state of a provider without listening to it.\n\nIt is commonly used inside functions triggered by user interactions.\nFor example, we can use `ref.read` to increment a counter when a user clicks a button:\n\n```codeBlockLines_e6Vv\n\n@riverpod\nclass Counter extends _$Counter {\n  @override\n  int build() => 0;\n  void increment() => state = state + 1;\n}\n\nclass HomeView extends ConsumerWidget {\n  const HomeView({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    return Scaffold(\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          // Call `increment()` on the `Counter` class\n          ref.read(counterProvider.notifier).increment();\n        },\n      ),\n    );\n  }\n}\n\n```\n\nnote\n\nUsing `ref.read` should be avoided as much as possible because it is not reactive.\n\nIt exists for cases where using `watch` or `listen` would cause issues.\nIf you can, it is almost always better to use `watch`/ `listen`, especially `watch`.\n\n#### **DON'T** use `ref.read` inside the build method [​](\\#dont-use-refread-inside-the-build-method \"Direct link to dont-use-refread-inside-the-build-method\")\n\nYou might be tempted to use `ref.read` to optimize the performance of a widget\nby doing:\n\n```codeBlockLines_e6Vv\n\n@riverpod\nclass Counter extends _$Counter {\n  @override\n  int build() => 0;\n  void increment() => state = state + 1;\n}\n\nWidget build(BuildContext context, WidgetRef ref) {\n  // use \"read\" to ignore updates on a provider\n  final counter = ref.read(counterProvider.notifier);\n  return ElevatedButton(\n    onPressed: counter.increment,\n    child: const Text('button'),\n  );\n}\n\n```\n\nBut this is a very bad practice and can cause bugs that are difficult to track.\n\nUsing `ref.read` this way is commonly associated with the thought \"The value\nexposed by a provider never changes so using 'ref.read' is safe\". The problem\nwith this assumption is that, while today that provider may indeed never update\nits value, there is no guarantee that tomorrow will be the same.\n\nSoftware tends to change a lot, and it is likely that in the future, a value\nthat previously never changed will need to change.\n\nIf you use `ref.read`, when that value needs to change, you have\nto go through your entire codebase to change `ref.read` into `ref.watch` –\nwhich is error prone and you are likely to forget some cases.\n\nIf you use `ref.watch` to begin with, you will have fewer problems when refactoring.\n\n**_But I wanted to use `ref.read` to reduce the number of times my widget rebuilds_**\n\nWhile the goal is commendable, it is important to note that you can achieve the\nexact same effect (reducing the number of builds) using `ref.watch` instead.\n\nProviders offer various ways to obtain a value while reducing the number of\nrebuilds, which you could use instead.\n\nFor example instead of\n\n```codeBlockLines_e6Vv\n\n@riverpod\nclass Counter extends _$Counter {\n  @override\n  int build() => 0;\n  void increment() => state = state + 1;\n}\n\nWidget build(BuildContext context, WidgetRef ref) {\n  Counter counter = ref.read(counterProvider.notifier);\n  return ElevatedButton(\n    onPressed: () => counter.increment(),\n    child: const Text('button'),\n  );\n}\n\n```\n\nwe could do:\n\n```codeBlockLines_e6Vv\n\n@riverpod\nclass Counter extends _$Counter {\n  @override\n  int build() => 0;\n  void increment() => state = state + 1;\n}\n\nWidget build(BuildContext context, WidgetRef ref) {\n  Counter counter = ref.watch(counterProvider.notifier);\n  return ElevatedButton(\n    onPressed: () => counter.increment(),\n    child: const Text('button'),\n  );\n}\n\n```\n\nBoth snippets achieve the same effect: our button will not rebuild when the\ncounter increments.\n\nOn the other hand, the second approach supports cases where the counter is reset.\nFor example, another part of the application could call:\n\n```codeBlockLines_e6Vv\nref.refresh(counterProvider);\n\n```\n\nwhich would recreate the `Counter` object.\n\nIf we used `ref.read` here, our button would still use the previous `Counter`\ninstance, which was disposed and should no-longer be used. Whereas using\n`ref.watch` correctly rebuilds the button to use the new `Counter`.\n\n## Deciding what to read [​](\\#deciding-what-to-read \"Direct link to Deciding what to read\")\n\nDepending on the provider you want to listen to, you may have multiple possible\nvalues that you can listen to.\n\nAs an example, consider the following [StreamProvider](/docs/providers/stream_provider):\n\n```codeBlockLines_e6Vv\nfinal userProvider = StreamProvider<User>(...);\n\n```\n\nWhen reading this `userProvider`, you can:\n\n- synchronously read the current state by listening to `userProvider` itself:\n\n\n\n\n\n```codeBlockLines_e6Vv\nWidget build(BuildContext context, WidgetRef ref) {\n    AsyncValue<User> user = ref.watch(userProvider);\n\n    return switch (user) {\n      AsyncData(:final value) => Text(value.name),\n      AsyncError(:final error) => const Text('Oops $error'),\n      _ => const CircularProgressIndicator(),\n    };\n}\n\n```\n\n- obtain the associated [Stream](https://api.dart.dev/stable/2.13.4/dart-async/Stream-class.html), by listening to `userProvider.stream`:\n\n\n\n\n\n```codeBlockLines_e6Vv\nWidget build(BuildContext context, WidgetRef ref) {\n    Stream<User> user = ref.watch(userProvider.stream);\n}\n\n```\n\n- obtain a [Future](https://api.dart.dev/stable/2.13.4/dart-async/Future-class.html) that resolves with the latest value emitted, by listening to `userProvider.future`:\n\n\n\n\n\n```codeBlockLines_e6Vv\nWidget build(BuildContext context, WidgetRef ref) {\n    Future<User> user = ref.watch(userProvider.future);\n}\n\n```\n\n\nOther providers may offer different alternative values.\n\nFor more information, refer to the documentation of each provider by\nconsulting the [API reference](https://pub.dev/documentation/riverpod/latest/riverpod/riverpod-library.html).\n\n## Using \"select\" to filter rebuilds [​](\\#using-select-to-filter-rebuilds \"Direct link to Using \\\"select\\\" to filter rebuilds\")\n\nOne final feature to mention related to reading providers is the ability to\nreduce the number of times a widget/provider rebuilds from `ref.watch`, or how often `ref.listen`\nexecutes a function.\n\nThis is important to keep in mind as, by default, listening to a provider\nlistens to the entire object state. But sometimes, a widget/provider may only\ncare about changes to some properties instead of the whole object.\n\nFor example, a provider may expose a `User`:\n\n```codeBlockLines_e6Vv\nabstract class User {\n  String get name;\n  int get age;\n}\n\n```\n\nBut a widget may only use the user name:\n\n```codeBlockLines_e6Vv\nWidget build(BuildContext context, WidgetRef ref) {\n  User user = ref.watch(userProvider);\n  return Text(user.name);\n}\n\n```\n\nIf we naively used `ref.watch`, this would rebuild the widget when the user's\n`age` changes.\n\nThe solution is to use `select` to explicitly tell Riverpod that we only\nwant to listen to the name property of the `User`.\n\nThe updated code would be:\n\n```codeBlockLines_e6Vv\nWidget build(BuildContext context, WidgetRef ref) {\n  String name = ref.watch(userProvider.select((user) => user.name));\n  return Text(name);\n}\n\n```\n\nBy using `select`, we are able to specify a function\nthat returns the property that we care about.\n\nWhenever the `User` changes, Riverpod will call this function and\ncompare the previous and new result. If they are different (such as when the name\nchanged), Riverpod will rebuild the widget.\n\nHowever, if they are equal (such as when the age changed), Riverpod will not\nrebuild the widget.\n\ninfo\n\nIt is also possible to use `select` with `ref.listen`:\n\n```codeBlockLines_e6Vv\nref.listen<String>(\n  userProvider.select((user) => user.name),\n  (String? previousName, String newName) {\n    print('The user name changed $newName');\n  }\n);\n\n```\n\nDoing so will call the listener only when the name changes.\n\ntip\n\nYou don't have to return a property of the object. Any value that\noverrides == will work. For example you could do:\n\n```codeBlockLines_e6Vv\nfinal label = ref.watch(userProvider.select((user) => 'Mr ${user.name}'));\n\n```\n\n- [Obtaining a \"ref\" object](#obtaining-a-ref-object)\n  - [Obtaining a \"ref\" from a provider](#obtaining-a-ref-from-a-provider)\n  - [Obtaining a \"ref\" from a widget](#obtaining-a-ref-from-a-widget)\n- [Using ref to interact with providers](#using-ref-to-interact-with-providers)\n  - [Using ref.watch to observe a provider](#using-refwatch-to-observe-a-provider)\n  - [Using ref.listen to react to a provider change](#using-reflisten-to-react-to-a-provider-change)\n  - [Using ref.read to obtain the state of a provider](#using-refread-to-obtain-the-state-of-a-provider)\n- [Deciding what to read](#deciding-what-to-read)\n- [Using \"select\" to filter rebuilds](#using-select-to-filter-rebuilds)",
    "metadata": {
      "url": "https://riverpod.dev/docs/concepts/reading",
      "ogUrl": "https://riverpod.dev/docs/concepts/reading",
      "title": "Reading a Provider | Riverpod",
      "og:url": "https://riverpod.dev/docs/concepts/reading",
      "ogImage": "https://riverpod.dev/img/cover.png",
      "ogTitle": "Reading a Provider | Riverpod",
      "language": "en",
      "og:image": "https://riverpod.dev/img/cover.png",
      "og:title": "Reading a Provider | Riverpod",
      "viewport": "width=device-width, initial-scale=1.0",
      "generator": "Docusaurus v2.4.3",
      "sourceURL": "https://riverpod.dev/docs/concepts/reading",
      "statusCode": 200,
      "description": "The content of this page may be outdated.",
      "twitter:card": "summary_large_image",
      "ogDescription": "The content of this page may be outdated.",
      "twitter:image": "https://riverpod.dev/img/cover.png",
      "docusaurus_tag": "docs-default-current",
      "og:description": "The content of this page may be outdated.",
      "docsearch:version": "current",
      "docusaurus_locale": "en",
      "ogLocaleAlternate": [],
      "docsearch:language": "en",
      "docusaurus_version": "current",
      "docsearch:docusaurus_tag": "docs-default-current"
    }
  },
  {
    "markdown": "[Skip to main content](#__docusaurus_skipToContent_fallback)\n\nOn this page\n\nRiverpod natively supports pull-to-refresh thanks to its declarative nature.\n\nIn general, pull-to-refreshes can be complex due as there are multiple\nproblems to solve:\n\n- Upon first entering a page, we want to show a spinner.\nBut during refresh, we want to show the refresh indicator instead.\nWe shouldn't show both the refresh indicator _and_ spinner.\n- While a refresh is pending, we want to show the previous data/error.\n- We need to show the refresh indicator for as long as the refresh is happening.\n\nLet's see how to solve this using Riverpod.\n\nFor this, we will make a simple example which recommends a random activity to users.\n\nAnd doing a pull-to-refresh will trigger a new suggestion:\n\n![A gif of the previously described application working](/img/case_studies/pull_to_refresh/app.gif)\n\n## Making a bare-bones application. [​](\\#making-a-bare-bones-application \"Direct link to Making a bare-bones application.\")\n\nBefore implement a pull-to-refresh, we first need something to refresh.\n\nWe can make a simple application which uses [Bored API](https://www.boredapi.com/)\nto suggests a random activity to users.\n\nFirst, let's define an `Activity` class:\n\n```codeBlockLines_e6Vv\n@freezed\nclass Activity with _$Activity {\n  factory Activity({\n    required String activity,\n    required String type,\n    required int participants,\n    required double price,\n  }) = _Activity;\n\n  factory Activity.fromJson(Map<String, dynamic> json) =>\n      _$ActivityFromJson(json);\n}\n\n```\n\nThat class will be responsible for representing a suggested activity\nin a type-safe manner, and handle JSON encoding/decoding.\n\nUsing Freezed/json\\_serializable is not required, but it is recommended.\n\nNow, we'll want to define a provider making a HTTP GET request to fetch\na single activity:\n\n```codeBlockLines_e6Vv\n@riverpod\nFuture<Activity> activity(Ref ref) async {\n  final response = await http.get(\n    Uri.https('www.boredapi.com', '/api/activity'),\n  );\n\n  final json = jsonDecode(response.body) as Map;\n  return Activity.fromJson(Map.from(json));\n}\n\n```\n\nWe can now use this provider to display a random activity.\n\nFor now, we will not handle the loading/error state, and simply\ndisplay the activity when available:\n\n```codeBlockLines_e6Vv\nclass ActivityView extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final activity = ref.watch(activityProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Pull to refresh')),\n      body: Center(\n        // If we have an activity, display it, otherwise wait\n        child: Text(activity.valueOrNull?.activity ?? ''),\n      ),\n    );\n  }\n}\n\n```\n\n## Adding `RefreshIndicator` [​](\\#adding-refreshindicator \"Direct link to adding-refreshindicator\")\n\nNow that we have a simple application, we can add a `RefreshIndicator` to it.\n\nThat widget is an official Material widget responsible for displaying a refresh indicator\nwhen the user pulls down the screen.\n\nUsing `RefreshIndicator` requires a scrollable surface. But so far, we don't have\nany. We can fix that by using a `ListView`/ `GridView`/ `SingleChildScrollView`/etc:\n\n```codeBlockLines_e6Vv\nclass ActivityView extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final activity = ref.watch(activityProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Pull to refresh')),\n      body: RefreshIndicator(\n        onRefresh: () async => print('refresh'),\n        child: ListView(\n          children: [\\\n            Text(activity.valueOrNull?.activity ?? ''),\\\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n```\n\nUsers can now pull down the screen. But our data isn't refreshed yet.\n\n## Adding the refresh logic [​](\\#adding-the-refresh-logic \"Direct link to Adding the refresh logic\")\n\nWhen users pull down the screen, `RefreshIndicator` will invoke\nthe `onRefresh` callback. We can use that callback to refresh our data.\nIn there, we can use `ref.refresh` to refresh the provider of our choice.\n\n**Note**: `onRefresh` is expected to return a `Future`.\nAnd it is important for that future to complete when the refresh is done.\n\nTo obtain such a future, we can read our provider's `.future` property.\nThis will return a future which completes when our provider has resolved.\n\nWe can therefore update our `RefreshIndicator` to look like this:\n\n```codeBlockLines_e6Vv\nclass ActivityView extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final activity = ref.watch(activityProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Pull to refresh')),\n      body: RefreshIndicator(\n        // By refreshing \"activityProvider.future\", and returning that result,\n        // the refresh indicator will keep showing until the new activity is\n        // fetched.\n        onRefresh: () => ref.refresh(activityProvider.future),\n        child: ListView(\n          children: [\\\n            Text(activity.valueOrNull?.activity ?? ''),\\\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n```\n\n## Showing a spinner only during initial load and handling errors. [​](\\#showing-a-spinner-only-during-initial-load-and-handling-errors \"Direct link to Showing a spinner only during initial load and handling errors.\")\n\nAt the moment, our UI does not handle the error/loading states.\n\nInstead the data magically pops up when the loading/refresh is done.\n\nLet's change this by gracefully handling those states. There are two\ncases:\n\n- During the initial load, we want to show a full-screen spinner.\n- During a refresh, we want to show the refresh indicator\nand the previous data/error.\n\nFortunately, when listening to an asynchronous provider in Riverpod,\nRiverpod gives us an `AsyncValue`, which offers everything we need.\n\nThat `AsyncValue` can then be combined with Dart 3.0's pattern matching\nas followed:\n\n```codeBlockLines_e6Vv\nclass ActivityView extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final activity = ref.watch(activityProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Pull to refresh')),\n      body: RefreshIndicator(\n        onRefresh: () => ref.refresh(activityProvider.future),\n        child: ListView(\n          children: [\\\n            switch (activity) {\\\n              // If some data is available, we display it.\\\n              // Note that data will still be available during a refresh.\\\n              AsyncValue<Activity>(:final valueOrNull?) => Text(valueOrNull.activity),\\\n              // An error is available, so we render it.\\\n              AsyncValue(:final error?) => Text('Error: $error'),\\\n              // No data/error, so we're in loading state.\\\n              _ => const CircularProgressIndicator(),\\\n            },\\\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n```\n\ncaution\n\nWe use `valueOrNull` here, as currently, using `value` throws\nif in error/loading state.\n\nRiverpod 3.0 will change this to have `value` behave like `valueOrNull`.\nBut for now, let's stick to `valueOrNull`.\n\ntip\n\nNotice the usage of the `:final valueOrNull?` syntax in our pattern matching.\nThis syntax can be used only because `activityProvider` returns a non-nullable\n`Activity`.\n\nIf your data can be `null`, you can instead use `AsyncValue(hasData: true, :final valueOrNull)`.\nThis will correctly handle cases where the data is `null`, at the cost of\na few extra characters.\n\n## Wrapping up: full application [​](\\#wrapping-up-full-application \"Direct link to Wrapping up: full application\")\n\nHere is the combined source of everything we've covered so far:\n\n```codeBlockLines_e6Vv\nimport 'dart:convert';\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:freezed_annotation/freezed_annotation.dart';\nimport 'package:http/http.dart' as http;\nimport 'package:riverpod_annotation/riverpod_annotation.dart';\n\npart 'codegen.g.dart';\npart 'codegen.freezed.dart';\n\nvoid main() => runApp(ProviderScope(child: MyApp()));\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(home: ActivityView());\n  }\n}\n\nclass ActivityView extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final activity = ref.watch(activityProvider);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Pull to refresh')),\n      body: RefreshIndicator(\n        onRefresh: () => ref.refresh(activityProvider.future),\n        child: ListView(\n          children: [\\\n            switch (activity) {\\\n              AsyncValue<Activity>(:final valueOrNull?) =>\\\n                Text(valueOrNull.activity),\\\n              AsyncValue(:final error?) => Text('Error: $error'),\\\n              _ => const CircularProgressIndicator(),\\\n            },\\\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n@riverpod\nFuture<Activity> activity(Ref ref) async {\n  final response = await http.get(\n    Uri.https('www.boredapi.com', '/api/activity'),\n  );\n\n  final json = jsonDecode(response.body) as Map;\n  return Activity.fromJson(Map.from(json));\n}\n\n@freezed\nclass Activity with _$Activity {\n  factory Activity({\n    required String activity,\n    required String type,\n    required int participants,\n    required double price,\n  }) = _Activity;\n\n  factory Activity.fromJson(Map<String, dynamic> json) =>\n      _$ActivityFromJson(json);\n}\n\n```\n\n- [Making a bare-bones application.](#making-a-bare-bones-application)\n- [Adding `RefreshIndicator`](#adding-refreshindicator)\n- [Adding the refresh logic](#adding-the-refresh-logic)\n- [Showing a spinner only during initial load and handling errors.](#showing-a-spinner-only-during-initial-load-and-handling-errors)\n- [Wrapping up: full application](#wrapping-up-full-application)",
    "metadata": {
      "url": "https://riverpod.dev/docs/case_studies/pull_to_refresh",
      "ogUrl": "https://riverpod.dev/docs/case_studies/pull_to_refresh",
      "title": "Pull to refresh | Riverpod",
      "og:url": "https://riverpod.dev/docs/case_studies/pull_to_refresh",
      "ogImage": "https://riverpod.dev/img/cover.png",
      "ogTitle": "Pull to refresh | Riverpod",
      "language": "en",
      "og:image": "https://riverpod.dev/img/cover.png",
      "og:title": "Pull to refresh | Riverpod",
      "viewport": "width=device-width, initial-scale=1.0",
      "generator": "Docusaurus v2.4.3",
      "sourceURL": "https://riverpod.dev/docs/case_studies/pull_to_refresh",
      "statusCode": 200,
      "description": "Riverpod natively supports pull-to-refresh thanks to its declarative nature.",
      "twitter:card": "summary_large_image",
      "ogDescription": "Riverpod natively supports pull-to-refresh thanks to its declarative nature.",
      "twitter:image": "https://riverpod.dev/img/cover.png",
      "docusaurus_tag": "docs-default-current",
      "og:description": "Riverpod natively supports pull-to-refresh thanks to its declarative nature.",
      "docsearch:version": "current",
      "docusaurus_locale": "en",
      "ogLocaleAlternate": [],
      "docsearch:language": "en",
      "docusaurus_version": "current",
      "docsearch:docusaurus_tag": "docs-default-current"
    }
  },
  {
    "markdown": "[Skip to main content](#__docusaurus_skipToContent_fallback)\n\nOn this page\n\nThis page explains what are hooks and how they are related to Riverpod.\n\n\"Hooks\" are utilities common from a separate package, independent from Riverpod:\n[flutter\\_hooks](https://github.com/rrousselGit/flutter_hooks).\n\nAlthough [flutter\\_hooks](https://github.com/rrousselGit/flutter_hooks) is a completely separate package and does not have anything\nto do with Riverpod (at least directly), it is common to pair Riverpod\nand [flutter\\_hooks](https://github.com/rrousselGit/flutter_hooks) together.\n\n## Should you use hooks? [​](\\#should-you-use-hooks \"Direct link to Should you use hooks?\")\n\nHooks are a powerful tool, but they are not for everyone.\n\nIf you are a newcomer to Riverpod, you should probably avoid using hooks.\n\nAlthough useful, hooks are not necessary for Riverpod.\n\nYou shouldn't start using hooks because of Riverpod. Rather, you should start\nusing hooks because you want to use hooks.\n\nUsing hooks is a tradeoff. They can be great for producing robust and reusable\ncode, but they are also a new concept to learn, and they can be confusing at first.\nHooks aren't a core Flutter concept. As such, they will feel out of place in Flutter/Dart.\n\n## What are hooks? [​](\\#what-are-hooks \"Direct link to What are hooks?\")\n\nHooks are functions used inside widgets. They are designed as an alternative\nto [StatefulWidget](https://api.flutter.dev/flutter/widgets/StatefulWidget-class.html) s, to make logic more reusable and composable.\n\nHooks are a concept coming from [React](https://reactjs.org/), and [flutter\\_hooks](https://github.com/rrousselGit/flutter_hooks)\nis merely a port of the React implementation to Flutter.\n\nAs such, yes, hooks may feel a bit out of place in Flutter. Ideally,\nin the future we would have a solution to the problem that hooks solves,\ndesigned specifically for Flutter.\n\nIf Riverpod's providers are for \"global\" application state, hooks are for\nlocal widget state. Hooks are typically used for dealing with stateful UI objects,\nsuch as [TextEditingController](https://api.flutter.dev/flutter/widgets/TextEditingController-class.html),\n[AnimationController](https://api.flutter.dev/flutter/animation/AnimationController-class.html).\n\nThey can also serve as a replacement to the \"builder\" pattern, replacing widgets\nsuch as [FutureBuilder](https://api.flutter.dev/flutter/widgets/FutureBuilder-class.html)/ [TweenAnimatedBuilder](https://api.flutter.dev/flutter/widgets/TweenAnimationBuilder-class.html)\nby an alterative that does not invole \"nesting\" – drastically improving readability.\n\nIn general, hooks are helpful for:\n\n- Forms\n- Animations\n- Reacting to user events\n- etc.\n\nAs an example, we could use hooks to manually implement a fade-in animation,\nwhere a widget starts invisible and slowly appears.\n\nIf we were to use [StatefulWidget](https://api.flutter.dev/flutter/widgets/StatefulWidget-class.html), the code would look like this:\n\n```codeBlockLines_e6Vv\nclass FadeIn extends StatefulWidget {\n  const FadeIn({Key? key, required this.child}) : super(key: key);\n\n  final Widget child;\n\n  @override\n  State<FadeIn> createState() => _FadeInState();\n}\n\nclass _FadeInState extends State<FadeIn> with SingleTickerProviderStateMixin {\n  late final AnimationController animationController = AnimationController(\n    vsync: this,\n    duration: const Duration(seconds: 2),\n  );\n\n  @override\n  void initState() {\n    super.initState();\n    animationController.forward();\n  }\n\n  @override\n  void dispose() {\n    animationController.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return AnimatedBuilder(\n      animation: animationController,\n      builder: (context, child) {\n        return Opacity(\n          opacity: animationController.value,\n          child: widget.child,\n        );\n      },\n    );\n  }\n}\n\n```\n\nUsing hooks, the equivalent would be:\n\n```codeBlockLines_e6Vv\nclass FadeIn extends HookWidget {\n  const FadeIn({Key? key, required this.child}) : super(key: key);\n\n  final Widget child;\n\n  @override\n  Widget build(BuildContext context) {\n    // Create an AnimationController. The controller will automatically be\n    // disposed when the widget is unmounted.\n    final animationController = useAnimationController(\n      duration: const Duration(seconds: 2),\n    );\n\n    // useEffect is the equivalent of initState + didUpdateWidget + dispose.\n    // The callback passed to useEffect is executed the first time the hook is\n    // invoked, and then whenever the list passed as second parameter changes.\n    // Since we pass an empty const list here, that's strictly equivalent to `initState`.\n    useEffect(() {\n      // start the animation when the widget is first rendered.\n      animationController.forward();\n      // We could optionally return some \"dispose\" logic here\n      return null;\n    }, const []);\n\n    // Tell Flutter to rebuild this widget when the animation updates.\n    // This is equivalent to AnimatedBuilder\n    useAnimation(animationController);\n\n    return Opacity(\n      opacity: animationController.value,\n      child: child,\n    );\n  }\n}\n\n```\n\nThere are a few interesting things to note in this code:\n\n- There is no memory leak. This code does not recreate a new `AnimationController` whenever the\nwidget rebuilds, and the controller is correctly released when the widget is unmounted.\n\n- It is possible to use hooks as many time as we want within the same widget.\nAs such, we can create multiple `AnimationController` if we want:\n\n\n\n\n\n```codeBlockLines_e6Vv\n@override\nWidget build(BuildContext context) {\n    final animationController = useAnimationController(\n      duration: const Duration(seconds: 2),\n    );\n    final anotherController = useAnimationController(\n      duration: const Duration(seconds: 2),\n    );\n\n    ...\n}\n\n```\n\n\n\n\n\n\n\n\n\nThis creates two controllers, without any sort of negative consequence.\n\n- If we wanted, we could refactor this logic into a separate reusable function:\n\n\n\n\n\n```codeBlockLines_e6Vv\ndouble useFadeIn() {\n    final animationController = useAnimationController(\n      duration: const Duration(seconds: 2),\n    );\n    useEffect(() {\n      animationController.forward();\n      return null;\n    }, const []);\n    useAnimation(animationController);\n    return animationController.value;\n}\n\n```\n\n\n\n\n\n\n\n\n\nWe could then use this function inside our widgets, as long as that widget is a [HookWidget](https://pub.dev/documentation/flutter_hooks/latest/flutter_hooks/HookWidget-class.html):\n\n\n\n\n\n```codeBlockLines_e6Vv\nclass FadeIn extends HookWidget {\n    const FadeIn({Key? key, required this.child}) : super(key: key);\n\n    final Widget child;\n\n    @override\n    Widget build(BuildContext context) {\n      final fade = useFadeIn();\n\n      return Opacity(opacity: fade, child: child);\n    }\n}\n\n```\n\n\n\n\n\n\n\n\n\nNote how our `useFadeIn` function is completely independent from our\n`FadeIn` widget.\n\n\nIf we wanted, we could use that `useFadeIn` function in a completely different\nwidget, and it would still work!\n\n\n## The rules of hooks [​](\\#the-rules-of-hooks \"Direct link to The rules of hooks\")\n\nHooks comes with unique constraints:\n\n- They can only be used within the `build` method of a widget that extends [HookWidget](https://pub.dev/documentation/flutter_hooks/latest/flutter_hooks/HookWidget-class.html):\n\n**Good**:\n\n\n\n\n\n```codeBlockLines_e6Vv\nclass Example extends HookWidget {\n    @override\n    Widget build(BuildContext context) {\n      final controller = useAnimationController();\n      ...\n    }\n}\n\n```\n\n\n\n\n\n\n\n\n\n**Bad**:\n\n\n\n\n\n```codeBlockLines_e6Vv\n// Not a HookWidget\nclass Example extends StatelessWidget {\n    @override\n    Widget build(BuildContext context) {\n      final controller = useAnimationController();\n      ...\n    }\n}\n\n```\n\n\n\n\n\n\n\n\n\n**Bad**:\n\n\n\n\n\n```codeBlockLines_e6Vv\nclass Example extends HookWidget {\n    @override\n    Widget build(BuildContext context) {\n      return ElevatedButton(\n        onPressed: () {\n          // Not _actually_ inside the \"build\" method, but instead inside\n          // a user interaction lifecycle (here \"on pressed\").\n          final controller = useAnimationController();\n        },\n        child: Text('click me'),\n      );\n    }\n}\n\n```\n\n- They cannot be used conditionally or in a loop.\n\n**Bad**:\n\n\n\n\n\n```codeBlockLines_e6Vv\nclass Example extends HookWidget {\n    const Example({required this.condition, super.key});\n    final bool condition;\n    @override\n    Widget build(BuildContext context) {\n      if (condition) {\n        // Hooks should not be used inside \"if\"s/\"for\"s, ...\n        final controller = useAnimationController();\n      }\n      ...\n    }\n}\n\n```\n\n\nFor more information about hooks, see [flutter\\_hooks](https://github.com/rrousselGit/flutter_hooks).\n\n## Hooks and Riverpod [​](\\#hooks-and-riverpod \"Direct link to Hooks and Riverpod\")\n\n### Installation [​](\\#installation \"Direct link to Installation\")\n\nSince hooks are independent from Riverpod, it is necessary to install hooks\nseparately. If you want to use them, installing [hooks\\_riverpod](https://pub.dev/packages/hooks_riverpod) is not\nenough. You will still need to add [flutter\\_hooks](https://github.com/rrousselGit/flutter_hooks) to your dependencies.\nSee [Getting started](/docs/introduction/getting_started#installing-the-package)) for more information.\n\n### Usage [​](\\#usage \"Direct link to Usage\")\n\nIn some cases, you may want to write a Widget that uses both hooks and Riverpod.\nBut as you may have already noticed, both hooks and Riverpod provide their\nown custom widget base type: [HookWidget](https://pub.dev/documentation/flutter_hooks/latest/flutter_hooks/HookWidget-class.html) and [ConsumerWidget](https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/ConsumerWidget-class.html).\n\nBut classes can only extend one superclass at a time.\n\nTo solve this problem, you can use the [hooks\\_riverpod](https://pub.dev/packages/hooks_riverpod) package.\nThis package provides a [HookConsumerWidget](https://pub.dev/documentation/hooks_riverpod/latest/hooks_riverpod/HookConsumerWidget-class.html) class that combines both\n[HookWidget](https://pub.dev/documentation/flutter_hooks/latest/flutter_hooks/HookWidget-class.html) and [ConsumerWidget](https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/ConsumerWidget-class.html) into a single type.\n\nYou can therefore subclass [HookConsumerWidget](https://pub.dev/documentation/hooks_riverpod/latest/hooks_riverpod/HookConsumerWidget-class.html) instead of [HookWidget](https://pub.dev/documentation/flutter_hooks/latest/flutter_hooks/HookWidget-class.html):\n\n```codeBlockLines_e6Vv\n\n// We extend HookConsumerWidget instead of HookWidget\nclass Example extends HookConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // We can use both hooks and providers here\n    final counter = useState(0);\n    final value = ref.watch(myProvider);\n\n    return Text('Hello $counter $value');\n  }\n}\n\n```\n\nAlternatively, you can use the \"builders\" provided by both packages.\n\nFor example, we could stick to using `StatelessWidget`, and use both\n`HookBuilder` and `Consumer`.\n\n```codeBlockLines_e6Vv\n\nclass Example extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    // We can use the builders provided by both packages\n    return Consumer(\n      builder: (context, ref, child) {\n        return HookBuilder(builder: (context) {\n          final counter = useState(0);\n          final value = ref.watch(myProvider);\n\n          return Text('Hello $counter $value');\n        });\n      },\n    );\n  }\n}\n\n```\n\nnote\n\nThis approach would work without using [hooks\\_riverpod](https://pub.dev/packages/hooks_riverpod). Only [flutter\\_riverpod](https://pub.dev/packages/flutter_riverpod)\nis needed.\n\nIf you like this approach, [hooks\\_riverpod](https://pub.dev/packages/hooks_riverpod) streamlines it by providing [HookConsumer](https://pub.dev/documentation/hooks_riverpod/latest/hooks_riverpod/HookConsumer-class.html),\nwhich is the combination of both builders in one:\n\n```codeBlockLines_e6Vv\n\nclass Example extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    // Equivalent to using both Consumer and HookBuilder.\n    return HookConsumer(\n      builder: (context, ref, child) {\n        final counter = useState(0);\n        final value = ref.watch(myProvider);\n\n        return Text('Hello $counter $value');\n      },\n    );\n  }\n}\n\n```\n\n- [Should you use hooks?](#should-you-use-hooks)\n- [What are hooks?](#what-are-hooks)\n- [The rules of hooks](#the-rules-of-hooks)\n- [Hooks and Riverpod](#hooks-and-riverpod)\n  - [Installation](#installation)\n  - [Usage](#usage)",
    "metadata": {
      "url": "https://riverpod.dev/docs/concepts/about_hooks",
      "ogUrl": "https://riverpod.dev/docs/concepts/about_hooks",
      "title": "About hooks | Riverpod",
      "og:url": "https://riverpod.dev/docs/concepts/about_hooks",
      "ogImage": "https://riverpod.dev/img/cover.png",
      "ogTitle": "About hooks | Riverpod",
      "language": "en",
      "og:image": "https://riverpod.dev/img/cover.png",
      "og:title": "About hooks | Riverpod",
      "viewport": "width=device-width, initial-scale=1.0",
      "generator": "Docusaurus v2.4.3",
      "sourceURL": "https://riverpod.dev/docs/concepts/about_hooks",
      "statusCode": 200,
      "description": "This page explains what are hooks and how they are related to Riverpod.",
      "twitter:card": "summary_large_image",
      "ogDescription": "This page explains what are hooks and how they are related to Riverpod.",
      "twitter:image": "https://riverpod.dev/img/cover.png",
      "docusaurus_tag": "docs-default-current",
      "og:description": "This page explains what are hooks and how they are related to Riverpod.",
      "docsearch:version": "current",
      "docusaurus_locale": "en",
      "ogLocaleAlternate": [],
      "docsearch:language": "en",
      "docusaurus_version": "current",
      "docsearch:docusaurus_tag": "docs-default-current"
    }
  },
  {
    "markdown": "[Skip to main content](#__docusaurus_skipToContent_fallback)\n\nOn this page\n\nAlong with [Riverpod 2.0](https://pub.dev/packages/flutter_riverpod/changelog#200), new classes\nwere introduced: `Notifier` / `AsyncNotifer`.\n\n`StateNotifier` is now discouraged in favor of those new APIs.\n\nThis page shows how to migrate from the deprecated `StateNotifier` to the new APIs.\n\nThe main benefit introduced by `AsyncNotifier` is a better `async` support; indeed,\n`AsyncNotifier` can be thought as a `FutureProvider` which can expose ways to be modified from the UI..\n\nFurthermore, the new `(Async)Notifier` s:\n\n- Expose a `Ref` object inside its class\n- Offer similar syntax between codegen and non-codegen approaches\n- Offer similar syntax between their sync and async versions\n- Move away logic from Providers and centralize it into the Notifiers themselves\n\nLet's see how to define a `Notifier`, how it compares with `StateNotifier` and how to migrate\nthe new `AsyncNotifier` for asynchronous state.\n\n## New syntax comparison [​](\\#new-syntax-comparison \"Direct link to New syntax comparison\")\n\nBe sure to know how to define a `Notifier` before diving into this comparison.\nSee [Performing side effects](/docs/essentials/side_effects#defining-a-notifier).\n\nLet's write an example, using the old `StateNotifier` syntax:\n\n```codeBlockLines_e6Vv\nclass CounterNotifier extends StateNotifier<int> {\n  CounterNotifier() : super(0);\n\n  void increment() => state++;\n  void decrement() => state--;\n}\n\nfinal counterNotifierProvider = StateNotifierProvider<CounterNotifier, int>((ref) {\n  return CounterNotifier();\n});\n\n```\n\nHere's the same example, built with the new `Notifier` APIs, which roughly translates to:\n\n```codeBlockLines_e6Vv\n@riverpod\nclass CounterNotifier extends _$CounterNotifier {\n  @override\n  int build() => 0;\n\n  void increment() => state++;\n  void decrement() => state--;\n}\n\n```\n\nComparing `Notifier` with `StateNotifier`, one can observe these main differences:\n\n- `StateNotifier`'s reactive dependencies are declared in its provider, whereas `Notifier`\ncentralizes this logic in its `build` method\n- `StateNotifier`'s whole initialization process is split between its provider and its constructor,\nwhereas `Notifier` reserves a single place to place such logic\n- Notice how, as opposed to `StateNotifier`, no logic is ever written into a `Notifier`'s constructor\n\nSimilar conclusions can be made with `AsyncNotifer`, `Notifier`'s asynchronous equivalent.\n\n## Migrating asynchronous `StateNotifier` s [​](\\#migrating-asynchronous-statenotifiers \"Direct link to migrating-asynchronous-statenotifiers\")\n\nThe main appeal of the new API syntax is an improved DX on asynchronous data.\n\nTake the following example:\n\n```codeBlockLines_e6Vv\nclass AsyncTodosNotifier extends StateNotifier<AsyncValue<List<Todo>>> {\n  AsyncTodosNotifier() : super(const AsyncLoading()) {\n    _postInit();\n  }\n\n  Future<void> _postInit() async {\n    state = await AsyncValue.guard(() async {\n      final json = await http.get('api/todos');\n\n      return [...json.map(Todo.fromJson)];\n    });\n  }\n\n  // ...\n}\n\n```\n\nHere's the above example, rewritten with the new `AsyncNotifier` APIs:\n\n```codeBlockLines_e6Vv\n@riverpod\nclass AsyncTodosNotifier extends _$AsyncTodosNotifier {\n  @override\n  FutureOr<List<Todo>> build() async {\n    final json = await http.get('api/todos');\n\n    return [...json.map(Todo.fromJson)];\n  }\n\n  // ...\n}\n\n```\n\n`AsyncNotifer`, just like `Notifier`, brings a simpler and more uniform API.\nHere, it's easy to see `AsyncNotifer` as a `FutureProvider` with methods.\n\n`AsyncNotifer` comes with a set of utilities and getters that `StateNotifier` doesn't have, such as e.g.\n[`future`](https://pub.dev/documentation/riverpod/latest/riverpod/AutoDisposeAsyncNotifier/future.html)\nand [`update`](https://pub.dev/documentation/riverpod/latest/riverpod/AutoDisposeAsyncNotifier/update.html).\nThis enables us to write much simpler logic when handling asynchronous mutations and side-effects.\nSee also [Performing side effects](/docs/essentials/side_effects).\n\ntip\n\nMigrating from `StateNotifier<AsyncValue<T>>` to a `AsyncNotifer<T>` boils down to:\n\n- Putting initialization logic into `build`\n- Removing any `catch`/ `try` blocks in initialization or in side effects methods\n- Remove any `AsyncValue.guard` from `build`, as it converts `Future` s into `AsyncValue` s\n\n### Advantages [​](\\#advantages \"Direct link to Advantages\")\n\nAfter these few examples, let's now highlight the main advantages of `Notifier` and `AsyncNotifer`:\n\n- The new syntax should feel way simpler and more readable, especially for asynchronous state\n- New APIs are likely to have less boilerplate code in general\n- Syntax is now unified, no matter the type of provider you're writing, enabling code generation\n(see [About code generation](/docs/concepts/about_code_generation))\n\nLet's go further down and highlight more differences and similarities.\n\n## Explicit `.family` and `.autoDispose` modifications [​](\\#explicit-family-and-autodispose-modifications \"Direct link to explicit-family-and-autodispose-modifications\")\n\nAnother important difference is how families and auto dispose is handled with the new APIs.\n\n`Notifier`, has its own `.family` and `.autoDispose` counterparts, such as `FamilyNotifier`\nand `AutoDisposeNotifier`.\n\nAs always, such modifications can be combined (aka `AutoDisposeFamilyNotifier`).\n\n`AsyncNotifer` has its asynchronous equivalent, too (e.g. `AutoDisposeFamilyAsyncNotifier`).\n\nModifications are explicitly stated inside the class; any parameters are directly injected in the\n`build` method, so that they're available to the initialization logic.\n\nThis should bring better readability, more conciseness and overall less mistakes.\n\nTake the following example, in which a `StateNotifierProvider.family` is being defined.\n\n```codeBlockLines_e6Vv\nclass BugsEncounteredNotifier extends StateNotifier<AsyncValue<int>> {\n  BugsEncounteredNotifier({\n    required this.ref,\n    required this.featureId,\n  }) : super(const AsyncData(99));\n  final String featureId;\n  final Ref ref;\n\n  Future<void> fix(int amount) async {\n    state = await AsyncValue.guard(() async {\n      final old = state.requireValue;\n      final result = await ref.read(taskTrackerProvider).fix(id: featureId, fixed: amount);\n      return max(old - result, 0);\n    });\n  }\n}\n\nfinal bugsEncounteredNotifierProvider =\n    StateNotifierProvider.family.autoDispose<BugsEncounteredNotifier, int, String>((ref, id) {\n  return BugsEncounteredNotifier(ref: ref, featureId: id);\n});\n\n```\n\n`BugsEncounteredNotifier` feels... heavy / hard to read.\n\nLet's take a look at its migrated `AsyncNotifier` counterpart:\n\n```codeBlockLines_e6Vv\n@riverpod\nclass BugsEncounteredNotifier extends _$BugsEncounteredNotifier {\n  @override\n  FutureOr<int> build(String featureId) {\n    return 99;\n  }\n\n  Future<void> fix(int amount) async {\n    final old = await future;\n    final result = await ref.read(taskTrackerProvider).fix(id: this.featureId, fixed: amount);\n    state = AsyncData(max(old - result, 0));\n  }\n}\n\n```\n\nIts migrated counterpart should feel like a light read.\n\ninfo\n\n`(Async)Notifier`'s `.family` parameters are available via `this.arg` (or `this.paramName` when using codegen)\n\n## Lifecycles have a different behavior [​](\\#lifecycles-have-a-different-behavior \"Direct link to Lifecycles have a different behavior\")\n\nLifecycles between `Notifier`/ `AsyncNotifier` and `StateNotifier` differ substantially.\n\nThis example showcases - again - how the old API have sparse logic:\n\n```codeBlockLines_e6Vv\nclass MyNotifier extends StateNotifier<int> {\n  MyNotifier(this.ref, this.period) : super(0) {\n    // 1 init logic\n    _timer = Timer.periodic(period, (t) => update()); // 2 side effect on init\n  }\n  final Duration period;\n  final Ref ref;\n  late final Timer _timer;\n\n  Future<void> update() async {\n    await ref.read(repositoryProvider).update(state + 1); // 3 mutation\n    if (mounted) state++; // 4 check for mounted props\n  }\n\n  @override\n  void dispose() {\n    _timer.cancel(); // 5 custom dispose logic\n    super.dispose();\n  }\n}\n\nfinal myNotifierProvider = StateNotifierProvider<MyNotifier, int>((ref) {\n  // 6 provider definition\n  final period = ref.watch(durationProvider); // 7 reactive dependency logic\n  return MyNotifier(ref, period); // 8 pipe down `ref`\n});\n\n```\n\nHere, if `durationProvider` updates, `MyNotifier` _disposes_: its instance is then re-instantiated\nand its internal state is then re-initialized.\n\nFurthermore, unlike every other provider, the `dispose` callback is to be defined\nin the class, separately.\n\nFinally, it is still possible to write `ref.onDispose` in its _provider_, showing once again how\nsparse the logic can be with this API; potentially, the developer might have to look into eight (8!)\ndifferent places to understand this Notifier behavior!\n\nThese ambiguities are solved with `Riverpod 2.0`.\n\n### Old `dispose` vs `ref.onDispose` [​](\\#old-dispose-vs-refondispose \"Direct link to old-dispose-vs-refondispose\")\n\n`StateNotifier`'s `dispose` method refers to the dispose event of the notifier itself, aka it's a\ncallback that gets called _before disposing of itself_.\n\n`(Async)Notifier` s don't have this property, since _they don't get disposed of on rebuild_; only\ntheir _internal state_ is.\n\nIn the new notifiers, dispose lifecycles are taken care of in only _one_ place, via `ref.onDispose`\n(and others), just like any other provider.\nThis simplifies the API, and hopefully the DX, so that there is only _one_ place to look at to\nunderstand lifecycle side-effects: its `build` method.\n\nShortly: to register a callback that fires before its _internal state_ rebuilds, we can use\n`ref.onDispose` like every other provider.\n\nYou can migrate the above snippet like so:\n\n```codeBlockLines_e6Vv\n@riverpod\nclass MyNotifier extends _$MyNotifier {\n  @override\n  int build() {\n    // Just read/write the code here, in one place\n    final period = ref.watch(durationProvider);\n    final timer = Timer.periodic(period, (t) => update());\n    ref.onDispose(timer.cancel);\n\n    return 0;\n  }\n\n  Future<void> update() async {\n    await ref.read(repositoryProvider).update(state + 1);\n    // `mounted` is no more!\n    state++; // This might throw.\n  }\n}\n\n```\n\nIn this last snippet there sure is some simplification, but there's still an open problem: we\nare now unable to understand whether or not our notifiers are still alive while performing `update`.\n\nThis might arise an unwanted `StateError` s.\n\n### No more `mounted` [​](\\#no-more-mounted \"Direct link to no-more-mounted\")\n\nThis happens because `(Async)Notifier` s lacks a `mounted` property, which was available on\n`StateNotifier`.\n\nConsidering their difference in lifecycle, this makes perfect sense; while possible, a `mounted`\nproperty would be misleading on the new notifiers: `mounted` would _almost always_ be `true`.\n\nWhile it would be possible to craft a [custom workaround](https://github.com/rrousselGit/riverpod/issues/1879#issuecomment-1303189191),\nit's recomended to work around this by canceling the asynchronous operation.\n\nCanceling an operation can be done with a custom [Completer](https://api.flutter.dev/flutter/dart-async/Completer-class.html),\nor any custom derivative.\n\nFor example, if you're using `Dio` to perform network requests, consider using a [cancel token](https://pub.dev/documentation/dio/latest/dio/CancelToken-class.html)\n(see also [Clearing cache and reacting to state disposal](/docs/essentials/auto_dispose)).\n\nTherefore, the above example migrates to the following:\n\n```codeBlockLines_e6Vv\n@riverpod\nclass MyNotifier extends _$MyNotifier {\n  @override\n  int build() {\n    // Just read/write the code here, in one place\n    final period = ref.watch(durationProvider);\n    final timer = Timer.periodic(period, (t) => update());\n    ref.onDispose(timer.cancel);\n\n    return 0;\n  }\n\n  Future<void> update() async {\n    final cancelToken = CancelToken();\n    ref.onDispose(cancelToken.cancel);\n    await ref.read(repositoryProvider).update(state + 1, token: cancelToken);\n    // When `cancelToken.cancel` is invoked, a custom Exception is thrown\n    state++;\n  }\n}\n\n```\n\n## Mutations APIs are the same as before [​](\\#mutations-apis-are-the-same-as-before \"Direct link to Mutations APIs are the same as before\")\n\nUp until now we've shown the differences between `StateNotifier` and the new APIs.\n\nInstead, one thing `Notifier`, `AsyncNotifer` and `StateNotifier` share is how their states\ncan be consumed and mutated.\n\nConsumers can obtain data from these three providers with the same syntax, which is great in case\nyou're migrating away from `StateNotifier`; this applies for notifiers methods, too.\n\n```codeBlockLines_e6Vv\nclass SomeConsumer extends ConsumerWidget {\n  const SomeConsumer({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final counter = ref.watch(counterNotifierProvider);\n    return Column(\n      children: [\\\n        Text(\"You've counted up until $counter, good job!\"),\\\n        TextButton(\\\n          onPressed: ref.read(counterNotifierProvider.notifier).increment,\\\n          child: const Text('Count even more!'),\\\n        )\\\n      ],\n    );\n  }\n}\n\n```\n\n## Other migrations [​](\\#other-migrations \"Direct link to Other migrations\")\n\nLet's explore the less-impactful differences between `StateNotifier` and `Notifier` (or `AsyncNotifier`)\n\n### From `.addListener` and `.stream` [​](\\#from-addlistener-and-stream \"Direct link to from-addlistener-and-stream\")\n\n`StateNotifier`'s `.addListener` and `.stream` can be used to listen for state changes.\nThese two APIs are now to be considered outdated.\n\nThis is intentional due to the desire to reach full API uniformity with `Notifier`, `AsyncNotifier` and other providers.\n\nIndeed, using a `Notifier` or an `AsyncNotifier` shouldn't be any different from any other provider.\n\nTherefore this:\n\n```codeBlockLines_e6Vv\nclass MyNotifier extends StateNotifier<int> {\n  MyNotifier() : super(0);\n\n  void add() => state++;\n}\n\nfinal myNotifierProvider = StateNotifierProvider<MyNotifier, int>((ref) {\n  final notifier = MyNotifier();\n\n  final cleanup = notifier.addListener((state) => debugPrint('$state'));\n  ref.onDispose(cleanup);\n\n  // Or, equivalently:\n  // final listener = notifier.stream.listen((event) => debugPrint('$event'));\n  // ref.onDispose(listener.cancel);\n\n  return notifier;\n});\n\n```\n\nBecomes this:\n\n```codeBlockLines_e6Vv\n@riverpod\nclass MyNotifier extends _$MyNotifier {\n  @override\n  int build() {\n    listenSelf((_, next) => debugPrint('$next'));\n    return 0;\n  }\n\n  void add() => state++;\n}\n\n```\n\nIn a nutshell: if you want to listen to a `Notifier`/ `AsyncNotifer`, just use `ref.listen`.\nSee [Combining requests](/docs/essentials/combining_requests#the-reflistenlistenself-methods).\n\n### From `.debugState` in tests [​](\\#from-debugstate-in-tests \"Direct link to from-debugstate-in-tests\")\n\n`StateNotifier` exposes `.debugState`: this property is used for pkg:state\\_notifier users to enable\nstate access from outside the class when in development mode, for testing purposes.\n\nIf you're using `.debugState` to access state in tests, chances are that you need to drop this\napproach.\n\n`Notifier` / `AsyncNotifer` don't have a `.debugState`; instead, they directly expose `.state`,\nwhich is `@visibleForTesting`.\n\ndanger\n\nAVOID accessing `.state` from tests; if you have to, do it _if and only if_ you had already have\na `Notifier` / `AsyncNotifer` properly instantied;\nthen, you could access `.state` inside tests freely.\n\nIndeed, `Notifier` / `AsyncNotifier` _should not_ be instantiated by hand; instead, they should be\ninteracted with by using its provider: failing to do so will _break_ the notifier,\ndue to ref and family args not being initialized.\n\nDon't have a `Notifier` instance?\n\nNo problem, you can obtain one with `ref.read`, just like you would read its exposed state:\n\n```codeBlockLines_e6Vv\nvoid main(List<String> args) {\n  test('my test', () {\n    final container = ProviderContainer();\n    addTearDown(container.dispose);\n\n    // Obtaining a notifier\n    final AutoDisposeNotifier<int> notifier = container.read(myNotifierProvider.notifier);\n\n    // Obtaining its exposed state\n    final int state = container.read(myNotifierProvider);\n\n    // TODO write your tests\n  });\n}\n\n```\n\nLearn more about testing in its dedicated guide. See [Testing your providers](/docs/essentials/testing).\n\n### From `StateProvider` [​](\\#from-stateprovider \"Direct link to from-stateprovider\")\n\n`StateProvider` was exposed by Riverpod since its release, and it was made to save a few LoC for\nsimplified versions of `StateNotifierProvider`.\n\nSince `StateNotifierProvider` is deprecated, `StateProvider` is to be avoided, too.\n\nFurthermore, as of now, there is no `StateProvider` equivalent for the new APIs.\n\nNonetheless, migrating from `StateProvider` to `Notifier` is simple.\n\nThis:\n\n```codeBlockLines_e6Vv\nfinal counterProvider = StateProvider<int>((ref) {\n  return 0;\n});\n\n```\n\nBecomes:\n\n```codeBlockLines_e6Vv\n@riverpod\nclass CounterNotifier extends _$CounterNotifier {\n  @override\n  int build() => 0;\n\n  @override\n  set state(int newState) => super.state = newState;\n  int update(int Function(int state) cb) => state = cb(state);\n}\n\n```\n\nEven though it costs us a few more LoC, migrating away from `StateProvider` enables us to\ndefinetively archive `StateNotifier`.\n\n- [New syntax comparison](#new-syntax-comparison)\n- [Migrating asynchronous `StateNotifier` s](#migrating-asynchronous-statenotifiers)\n  - [Advantages](#advantages)\n- [Explicit `.family` and `.autoDispose` modifications](#explicit-family-and-autodispose-modifications)\n- [Lifecycles have a different behavior](#lifecycles-have-a-different-behavior)\n  - [Old `dispose` vs `ref.onDispose`](#old-dispose-vs-refondispose)\n  - [No more `mounted`](#no-more-mounted)\n- [Mutations APIs are the same as before](#mutations-apis-are-the-same-as-before)\n- [Other migrations](#other-migrations)\n  - [From `.addListener` and `.stream`](#from-addlistener-and-stream)\n  - [From `.debugState` in tests](#from-debugstate-in-tests)\n  - [From `StateProvider`](#from-stateprovider)",
    "metadata": {
      "url": "https://riverpod.dev/docs/migration/from_state_notifier",
      "ogUrl": "https://riverpod.dev/docs/migration/from_state_notifier",
      "title": "From `StateNotifier` | Riverpod",
      "og:url": "https://riverpod.dev/docs/migration/from_state_notifier",
      "ogImage": "https://riverpod.dev/img/cover.png",
      "ogTitle": "From `StateNotifier` | Riverpod",
      "language": "en",
      "og:image": "https://riverpod.dev/img/cover.png",
      "og:title": "From `StateNotifier` | Riverpod",
      "viewport": "width=device-width, initial-scale=1.0",
      "generator": "Docusaurus v2.4.3",
      "sourceURL": "https://riverpod.dev/docs/migration/from_state_notifier",
      "statusCode": 200,
      "description": "Along with Riverpod 2.0, new classes",
      "twitter:card": "summary_large_image",
      "ogDescription": "Along with Riverpod 2.0, new classes",
      "twitter:image": "https://riverpod.dev/img/cover.png",
      "docusaurus_tag": "docs-default-current",
      "og:description": "Along with Riverpod 2.0, new classes",
      "docsearch:version": "current",
      "docusaurus_locale": "en",
      "ogLocaleAlternate": [],
      "docsearch:language": "en",
      "docusaurus_version": "current",
      "docsearch:docusaurus_tag": "docs-default-current"
    }
  },
  {
    "markdown": "[Skip to main content](https://riverpod.dev/docs/introduction/getting_started#__docusaurus_skipToContent_fallback)\n\nOn this page\n\n## Try Riverpod online [​](https://riverpod.dev/docs/introduction/getting_started\\#try-riverpod-online \"Direct link to Try Riverpod online\")\n\nTo get a feel of Riverpod, try it online on [Dartpad](https://dartpad.dev/?null_safety=true&id=ef06ab3ce0b822e6cc5db0575248e6e2)\nor on [Zapp](https://zapp.run/new):\n\nRiverpod Todo app\n\nRiverpod Todo app\n\nOpen in Zapp!\n\nmain.dart\n\n# Riverpod Todo app\n\nA basic Todo application implemented with hooks\\_riverpod.\n\n![Photo](https://avatars.githubusercontent.com/u/20165741?v=4)Remi Rousselet\n\n### Explorer\n\n.dart\\_tool\n\nbuild\n\nlib\n\nmain.dart\n\ntodo.dart\n\nweb\n\npubspec.lock\n\npubspec.yaml\n\nmain.dart✕\n\nlib\n\nmain.dart\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\n15\n\n16\n\n17\n\n18\n\n19\n\n20\n\n21\n\n22\n\n23\n\n24\n\n25\n\n26\n\n27\n\n28\n\n29\n\n30\n\n31\n\n32\n\n33\n\n34\n\n35\n\n36\n\n37\n\n38\n\n39\n\n40\n\n41\n\n42\n\n43\n\n44\n\n45\n\n46\n\n47\n\n48\n\n49\n\n50\n\n51\n\n52\n\n53\n\n54\n\nimport 'package:flutter/material.dart';\n\nimport 'package:flutter\\_hooks/flutter\\_hooks.dart';\n\nimport 'package:hooks\\_riverpod/hooks\\_riverpod.dart';\n\nimport 'todo.dart';\n\n/// Some keys used for testing\n\nfinal addTodoKey = UniqueKey();\n\nfinal activeFilterKey = UniqueKey();\n\nfinal completedFilterKey = UniqueKey();\n\nfinal allFilterKey = UniqueKey();\n\n/// Creates a \\[TodoList\\] and initialise it with pre-defined values.\n\n///\n\n/// We are using \\[StateNotifierProvider\\] here as a \\`List<Todo>\\` is a complex\n\n/// object, with advanced business logic like how to edit a todo.\n\nfinal todoListProvider = NotifierProvider<TodoList, List<Todo>>(TodoList.new);\n\n/// The different ways to filter the list of todos\n\nenum TodoListFilter {\n\nall,\n\nactive,\n\ncompleted,\n\n}\n\n/// The currently active filter.\n\n///\n\n/// We use \\[StateProvider\\] here as there is no fancy logic behind manipulating\n\n/// the value since it's just enum.\n\nfinal todoListFilter = StateProvider((\\_) => TodoListFilter.all);\n\n/// The number of uncompleted todos\n\n///\n\n/// By using \\[Provider\\], this value is cached, making it performant.\\\n\n/// Even multiple widgets try to read the number of uncompleted todos,\n\n/// the value will be computed only once (until the todo-list changes).\n\n///\n\n/// This will also optimise unneeded rebuilds if the todo-list changes, but the\n\n/// number of uncompleted todos doesn't (such as when editing a todo).\n\nfinal uncompletedTodosCount = Provider<int>((ref){\n\nreturn ref.watch(todoListProvider).where((todo) => !todo.completed).length;\n\n});\n\n/// The list of todos after applying of \\[todoListFilter\\].\n\n///\n\n/// This too uses \\[Provider\\], to avoid recomputing the filtered list unless either\n\n/// the filter of or the todo-list updates.\n\nfinal filteredTodos = Provider<List<Todo>>((ref){\n\nfinal filter = ref.watch(todoListFilter);\n\nfinal todos = ref.watch(todoListProvider);\n\nswitch (filter){\n\n    case TodoListFilter.completed:\n\n      return todos.where((todo) => todo.completed).toList();\n\nLogsProblemsOutput\n\nLoading environment, please wait...\n\n## Installing the package [​](https://riverpod.dev/docs/introduction/getting_started\\#installing-the-package \"Direct link to Installing the package\")\n\nOnce you know what package you want to install, proceed to add the dependency to your app in a single line like this:\n\n- Flutter\n- Dart only\n\n```codeBlockLines_e6Vv\nflutter pub add flutter_riverpod\nflutter pub add riverpod_annotation\nflutter pub add dev:riverpod_generator\nflutter pub add dev:build_runner\nflutter pub add dev:custom_lint\nflutter pub add dev:riverpod_lint\n\n```\n\nAlternatively, you can manually add the dependency to your app from within your `pubspec.yaml`:\n\n- Flutter\n- Dart only\n\npubspec.yaml\n\n```codeBlockLines_e6Vv\nname: my_app_name\nenvironment:\n  sdk: \">=3.0.0 <4.0.0\"\n  flutter: \">=3.0.0\"\n\ndependencies:\n  flutter:\n    sdk: flutter\n  flutter_riverpod: ^2.6.1\n  riverpod_annotation: ^2.6.1\n\ndev_dependencies:\n  build_runner:\n  custom_lint:\n  riverpod_generator: ^2.6.1\n  riverpod_lint: ^2.6.1\n\n```\n\nThen, install packages with `flutter pub get`.\n\nYou can now run the code-generator with `dart run build_runner watch`.\n\nThat's it. You've added [Riverpod](https://github.com/rrousselgit/riverpod) to your app!\n\n## Enabling riverpod\\_lint/custom\\_lint [​](https://riverpod.dev/docs/introduction/getting_started\\#enabling-riverpod_lintcustom_lint \"Direct link to Enabling riverpod_lint/custom_lint\")\n\nRiverpod comes with an optional [riverpod\\_lint](https://pub.dev/packages/riverpod_lint)\npackage that provides lint rules to help you write better code, and\nprovide custom refactoring options.\n\nThe package should already be installed if you followed the previous steps, but a\nseparate step is necessary to enable it.\n\nTo enable [riverpod\\_lint](https://pub.dev/packages/riverpod_lint), you need add an `analysis_options.yaml` placed next to\nyour `pubspec.yaml` and include the following:\n\nanalysis\\_options.yaml\n\n```codeBlockLines_e6Vv\nanalyzer:\n  plugins:\n    - custom_lint\n\n```\n\nYou should now see warnings in your IDE if you made mistakes when using Riverpod\nin your codebase.\n\nTo see the full list of warnings and refactorings, head to the [riverpod\\_lint](https://pub.dev/packages/riverpod_lint) page.\n\nnote\n\nThose warnings will not show-up in the `dart analyze` command.\n\nIf you want to check those warnings in the CI/terminal, you can run the following:\n\n```codeBlockLines_e6Vv\ndart run custom_lint\n\n```\n\n## Usage example: Hello world [​](https://riverpod.dev/docs/introduction/getting_started\\#usage-example-hello-world \"Direct link to Usage example: Hello world\")\n\nNow that we have installed [Riverpod](https://github.com/rrousselgit/riverpod), we can start using it.\n\nThe following snippets showcase how to use our new dependency to make a \"Hello world\":\n\n- Flutter\n- Dart only\n\nlib/main.dart\n\n```codeBlockLines_e6Vv\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:riverpod_annotation/riverpod_annotation.dart';\n\npart 'main.g.dart';\n\n// We create a \"provider\", which will store a value (here \"Hello world\").\n// By using a provider, this allows us to mock/override the value exposed.\n@riverpod\nString helloWorld(Ref ref) {\n  return 'Hello world';\n}\n\nvoid main() {\n  runApp(\n    // For widgets to be able to read providers, we need to wrap the entire\n    // application in a \"ProviderScope\" widget.\n    // This is where the state of our providers will be stored.\n    ProviderScope(\n      child: MyApp(),\n    ),\n  );\n}\n\n// Extend ConsumerWidget instead of StatelessWidget, which is exposed by Riverpod\nclass MyApp extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final String value = ref.watch(helloWorldProvider);\n\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Example')),\n        body: Center(\n          child: Text(value),\n        ),\n      ),\n    );\n  }\n}\n\n```\n\nThen, start the application with `flutter run`.\n\nThis will render \"Hello world\" on your device.\n\n## Going further: Installing code snippets [​](https://riverpod.dev/docs/introduction/getting_started\\#going-further-installing-code-snippets \"Direct link to Going further: Installing code snippets\")\n\nIf you are using `Flutter` and `VS Code` , consider using [Flutter Riverpod Snippets](https://marketplace.visualstudio.com/items?itemName=robert-brunhage.flutter-riverpod-snippets)\n\nIf you are using `Flutter` and `Android Studio` or `IntelliJ`, consider using [Flutter Riverpod Snippets](https://plugins.jetbrains.com/plugin/14641-flutter-riverpod-snippets)\n\n![img](https://riverpod.dev/assets/images/greetingProvider-47179931ef18184e7ab68f4e701ca916.gif)\n\n## Choose your next step [​](https://riverpod.dev/docs/introduction/getting_started\\#choose-your-next-step \"Direct link to Choose your next step\")\n\nLearn some basic concepts:\n\n- [Providers](https://riverpod.dev/docs/concepts/providers)\n\nFollow a cookbook:\n\n- [Testing](https://riverpod.dev/docs/cookbooks/testing)\n\n- [Try Riverpod online](https://riverpod.dev/docs/introduction/getting_started#try-riverpod-online)\n- [Installing the package](https://riverpod.dev/docs/introduction/getting_started#installing-the-package)\n- [Enabling riverpod\\_lint/custom\\_lint](https://riverpod.dev/docs/introduction/getting_started#enabling-riverpod_lintcustom_lint)\n- [Usage example: Hello world](https://riverpod.dev/docs/introduction/getting_started#usage-example-hello-world)\n- [Going further: Installing code snippets](https://riverpod.dev/docs/introduction/getting_started#going-further-installing-code-snippets)\n- [Choose your next step](https://riverpod.dev/docs/introduction/getting_started#choose-your-next-step)",
    "metadata": {
      "url": "https://riverpod.dev/docs/introduction/getting_started",
      "ogUrl": "https://riverpod.dev/docs/introduction/getting_started",
      "title": "Getting started | RiverpodRiverpod Todo app",
      "og:url": [
        "https://riverpod.dev/docs/introduction/getting_started",
        "https://zapp.run"
      ],
      "ogImage": "https://riverpod.dev/img/cover.png",
      "ogTitle": "Getting started | Riverpod",
      "language": "en",
      "og:image": [
        "https://riverpod.dev/img/cover.png",
        "https://cdn.smmstudio.app/hCknlZzz46KhZ29xUGPz/social-preview/zv2060sv306.png"
      ],
      "og:title": [
        "Getting started | Riverpod",
        "Riverpod Todo app"
      ],
      "viewport": [
        "width=device-width, initial-scale=1.0",
        "width=device-width, initial-scale=1"
      ],
      "generator": "Docusaurus v2.4.3",
      "sourceURL": "https://riverpod.dev/docs/introduction/getting_started",
      "statusCode": 200,
      "description": [
        "Try Riverpod online",
        "A basic Todo application implemented with hooks_riverpod."
      ],
      "theme-color": "#333333",
      "twitter:card": [
        "summary_large_image",
        "summary_large_image"
      ],
      "ogDescription": "Try Riverpod online",
      "twitter:image": [
        "https://riverpod.dev/img/cover.png",
        "https://cdn.smmstudio.app/hCknlZzz46KhZ29xUGPz/social-preview/zv2060sv306.png"
      ],
      "twitter:title": "Riverpod Todo app",
      "docusaurus_tag": "docs-default-current",
      "og:description": [
        "Try Riverpod online",
        "A basic Todo application implemented with hooks_riverpod."
      ],
      "twitter:creator": "@zapp_run",
      "docsearch:version": "current",
      "docusaurus_locale": "en",
      "ogLocaleAlternate": [],
      "docsearch:language": "en",
      "docusaurus_version": "current",
      "twitter:description": "A basic Todo application implemented with hooks_riverpod.",
      "msapplication-config": "/favicons/browserconfig.xml",
      "msapplication-TileColor": "#333333",
      "docsearch:docusaurus_tag": "docs-default-current"
    }
  },
  {
    "markdown": "[Skip to main content](#__docusaurus_skipToContent_fallback)\n\n# Page Not Found\n\nWe could not find what you were looking for.\n\nPlease contact the owner of the site that linked you to the original URL and let them know their link is broken.",
    "metadata": {
      "url": "https://riverpod.dev/docs",
      "error": "Not Found",
      "ogUrl": "https://riverpod.dev/docs",
      "title": "Page Not Found | Riverpod",
      "og:url": "https://riverpod.dev/docs",
      "ogImage": "https://riverpod.dev/img/cover.png",
      "ogTitle": "Page Not Found | Riverpod",
      "language": "en",
      "og:image": "https://riverpod.dev/img/cover.png",
      "og:title": "Page Not Found | Riverpod",
      "viewport": "width=device-width, initial-scale=1.0",
      "generator": "Docusaurus v2.4.3",
      "sourceURL": "https://riverpod.dev/docs",
      "statusCode": 404,
      "twitter:card": "summary_large_image",
      "twitter:image": "https://riverpod.dev/img/cover.png",
      "docusaurus_tag": "default",
      "docusaurus_locale": "en",
      "ogLocaleAlternate": [],
      "docsearch:language": "en",
      "docsearch:docusaurus_tag": "default"
    }
  }
]